/*
 * Licensed to Elasticsearch B.V. under one or more contributor
 * license agreements. See the NOTICE file distributed with
 * this work for additional information regarding copyright
 * ownership. Elasticsearch B.V. licenses this file to you under
 * the Apache License, Version 2.0 (the "License"); you may
 * not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
             
package co.elastic.plugin.documentation;

import com.intellij.platform.backend.documentation.DocumentationResult;

import javax.annotation.Nullable;
import java.util.Map;

//----------------------------------------------------------------
//       THIS CODE IS GENERATED. MANUAL EDITS WILL BE LOST.
//----------------------------------------------------------------

public final class EsqlDocsMap {

    private static Map<String, String> rawDocs = Map.ofEntries(
                            Map.entry("min_over_time", """
<h2 id="min_over_time"><code>MIN_OVER_TIME</code></h2>\n<pre><code>stack: preview 9.2.0\nserverless: preview</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/min_over_time.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> </definition> </definitions></p>\n<p><strong>Description</strong> Calculates the minimum over time value of a field. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>aggregate_metric_double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>boolean</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>date</td>\n<td>date</td>\n</tr>\n<tr class="even">\n<td>date_nanos</td>\n<td>date_nanos</td>\n</tr>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>ip</td>\n<td>ip</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>unsigned_long <code>stack: ga 9.2.0</code></td>\n<td>unsigned_long</td>\n</tr>\n<tr class="even">\n<td>version</td>\n<td>version</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>TS k8s\n| STATS cost=SUM(MIN_OVER_TIME(network.cost)) BY cluster, time_bucket = TBUCKET(1minute)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>cost:double</th>\n<th>cluster:keyword</th>\n<th>time_bucket:datetime</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>29.0</td>\n<td>prod</td>\n<td>2024-05-10T00:19:00.000Z</td>\n</tr>\n<tr class="even">\n<td>27.625</td>\n<td>qa</td>\n<td>2024-05-10T00:06:00.000Z</td>\n</tr>\n<tr class="odd">\n<td>24.25</td>\n<td>qa</td>\n<td>2024-05-10T00:09:00.000Z</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("first_over_time", """
<h2 id="first_over_time"><code>FIRST_OVER_TIME</code></h2>\n<pre><code>stack: preview 9.2.0\nserverless: preview</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/first_over_time.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> </definition> </definitions></p>\n<p><strong>Description</strong> Calculates the earliest value of a field, where recency determined by the <code>@timestamp</code> field. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>counter_double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>counter_integer</td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>counter_long</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>integer</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>long</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>TS k8s\n| STATS max_cost=MAX(FIRST_OVER_TIME(network.cost)) BY cluster, time_bucket = TBUCKET(1minute)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>max_cost:double</th>\n<th>cluster:keyword</th>\n<th>time_bucket:datetime</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>12.375</td>\n<td>prod</td>\n<td>2024-05-10T00:17:00.000Z</td>\n</tr>\n<tr class="even">\n<td>12.375</td>\n<td>qa</td>\n<td>2024-05-10T00:01:00.000Z</td>\n</tr>\n<tr class="odd">\n<td>12.25</td>\n<td>prod</td>\n<td>2024-05-10T00:19:00.000Z</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("to_timeduration", """
<h2 id="to_timeduration"><code>TO_TIMEDURATION</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/to_timeduration.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> Input value. The input is a valid constant time duration expression. </definition> </definitions></p>\n<p><strong>Description</strong> Converts an input value into a <code>time_duration</code> value. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>keyword</td>\n<td>time_duration</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>time_duration</td>\n</tr>\n<tr class="odd">\n<td>time_duration</td>\n<td>time_duration</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW x = &quot;2024-01-01&quot;::datetime\n| EVAL y = x + &quot;3 hours&quot;::time_duration, z = x - TO_TIMEDURATION(&quot;3 hours&quot;);</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>x:datetime</th>\n<th>y:datetime</th>\n<th>z:datetime</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>2024-01-01</td>\n<td>2024-01-01T03:00:00.000Z</td>\n<td>2023-12-31T21:00:00.000Z</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("increase", """
<h2 id="increase"><code>INCREASE</code></h2>\n<pre><code>stack: preview 9.2.0\nserverless: preview</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/increase.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> </definition> </definitions></p>\n<p><strong>Description</strong> Calculates the absolute increase of a counter field in a time window. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>counter_double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>counter_integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>counter_long</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>TS k8s\n| WHERE pod == &quot;one&quot;\n| STATS increase_bytes_in = SUM(INCREASE(network.total_bytes_in)) BY cluster, time_bucket = TBUCKET(10minute)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>increase_bytes_in:double</th>\n<th>cluster:keyword</th>\n<th>time_bucket:datetime</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>2418.8749174917493</td>\n<td>prod</td>\n<td>2024-05-10T00:00:00.000Z</td>\n</tr>\n<tr class="even">\n<td>5973.5</td>\n<td>qa</td>\n<td>2024-05-10T00:00:00.000Z</td>\n</tr>\n<tr class="odd">\n<td>2545.467283950617</td>\n<td>staging</td>\n<td>2024-05-10T00:00:00.000Z</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("cbrt", """
<h2 id="cbrt"><code>CBRT</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/cbrt.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="number"> Numeric expression. If <code>null</code>, the function returns <code>null</code>. </definition> </definitions></p>\n<p><strong>Description</strong> Returns the cube root of a number. The input can be any numeric value, the return value is always a double. Cube roots of infinities are null. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>number</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW d = 1000.0\n| EVAL c = CBRT(d)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>d: double</th>\n<th>c:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>1000.0</td>\n<td>10.0</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("left", """
<h2 id="left"><code>LEFT</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/left.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="string"> The string from which to return a substring. </definition> <definition term="length"> The number of characters to return. </definition> </definitions></p>\n<p><strong>Description</strong> Returns the substring that extracts <em>length</em> chars from <em>string</em> starting from the left. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>string</th>\n<th>length</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>keyword</td>\n<td>integer</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>integer</td>\n<td>keyword</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>FROM employees\n| KEEP last_name\n| EVAL left = LEFT(last_name, 3)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>last_name:keyword</th>\n<th>left:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>Awdeh</td>\n<td>Awd</td>\n</tr>\n<tr class="even">\n<td>Azuma</td>\n<td>Azu</td>\n</tr>\n<tr class="odd">\n<td>Baek</td>\n<td>Bae</td>\n</tr>\n<tr class="even">\n<td>Bamford</td>\n<td>Bam</td>\n</tr>\n<tr class="odd">\n<td>Bernatsky</td>\n<td>Ber</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("url_decode", """
<h2 id="url_decode"><code>URL_DECODE</code></h2>\n<pre><code>stack: ga 9.2.0</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/url_decode.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="string"> The URL-encoded string to decode. </definition> </definitions></p>\n<p><strong>Description</strong> URL-decodes the input, or returns <code>null</code> and adds a warning header to the response if the input cannot be decoded. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>string</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>keyword</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW u = &quot;https%3A%2F%2Fexample.com%2F%3Fx%3Dfoo%20bar%26y%3Dbaz&quot;\n| EVAL u = URL_DECODE(u)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>u:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>https://example.com/?x=foo bar&amp;y=baz</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("ceil", """
<h2 id="ceil"><code>CEIL</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/ceil.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="number"> Numeric expression. If <code>null</code>, the function returns <code>null</code>. </definition> </definitions></p>\n<strong>Description</strong> Round a number up to the nearest integer.\n<note>\nThis is a noop for <code>long</code> (including unsigned) and <code>integer</code>. For <code>double</code> this picks the closest <code>double</code> value to the integer similar to <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Math.html#ceil(double)">Math.ceil</a>.\n</note>\n<p><strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>number</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>unsigned_long</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW a=1.8\n| EVAL a=CEIL(a)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>2</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("replace", """
<h2 id="replace"><code>REPLACE</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/replace.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="string"> String expression. </definition> <definition term="regex"> Regular expression. </definition> <definition term="newString"> Replacement string. </definition> </definitions></p>\n<p><strong>Description</strong> The function substitutes in the string <code>str</code> any match of the regular expression <code>regex</code> with the replacement string <code>newStr</code>. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>string</th>\n<th>regex</th>\n<th>newString</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>keyword</td>\n<td>keyword</td>\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>keyword</td>\n<td>text</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>keyword</td>\n<td>text</td>\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>text</td>\n<td>text</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>keyword</td>\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>keyword</td>\n<td>text</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>text</td>\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>text</td>\n<td>text</td>\n<td>keyword</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Examples</strong> This example replaces any occurrence of the word “World” with the word “Universe”:</p>\n<pre class="esql"><code>ROW str = &quot;Hello World&quot;\n| EVAL str = REPLACE(str, &quot;World&quot;, &quot;Universe&quot;)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>str:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>Hello Universe</td>\n</tr>\n</tbody>\n</table>\n<p>This example removes all spaces:</p>\n<pre class="esql"><code>ROW str = &quot;Hello World&quot;\n| EVAL str = REPLACE(str, &quot;\\\\s+&quot;, &quot;&quot;)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>str:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>HelloWorld</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("to_geohex", """
<h2 id="to_geohex"><code>TO_GEOHEX</code></h2>\n<pre><code>stack: preview\nserverless: preview</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/to_geohex.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> Input value. The input can be a single- or multi-valued column or an expression. </definition> </definitions></p>\n<p><strong>Description</strong> Converts an input value to a <code>geohex</code> value. A string will only be successfully converted if it respects the <code>geohex</code> format, as described for the <a href="https://www.elastic.co/docs/reference/aggregations/search-aggregations-bucket-geohexgrid-aggregation">geohex grid aggregation</a>. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>geohex</td>\n<td>geohex</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>geohex</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>geohex</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>geohex</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW string = &quot;841f059ffffffff&quot;\n| EVAL geohex = TO_GEOHEX(string)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>string:keyword</th>\n<th>geohex:geohex</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>841f059ffffffff</td>\n<td>841f059ffffffff</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("processing-commands", """
<h1 id="esql-processing-commands">ES|QL processing commands</h1>\n<p>ES|QL processing commands change an input table by adding, removing, or changing rows and columns. <img src="https://www.elastic.co/docs/reference/query-languages/images/processing-command.svg" alt="A processing command changing an input table" /></p>\n<p>ES|QL supports these processing commands: - <a href="https://www.elastic.co/docs/reference/query-languages/esql/commands/change-point"><code>CHANGE_POINT</code></a> <code>stack: preview</code> <code>serverless: preview</code> - <a href="https://www.elastic.co/docs/reference/query-languages/esql/commands/completion"><code>COMPLETION</code></a> <code>stack: preview</code> <code>serverless: preview</code> - <a href="https://www.elastic.co/docs/reference/query-languages/esql/commands/dissect"><code>DISSECT</code></a> - <a href="https://www.elastic.co/docs/reference/query-languages/esql/commands/drop"><code>DROP</code></a> - <a href="https://www.elastic.co/docs/reference/query-languages/esql/commands/enrich"><code>ENRICH</code></a> - <a href="https://www.elastic.co/docs/reference/query-languages/esql/commands/eval"><code>EVAL</code></a> - <a href="https://www.elastic.co/docs/reference/query-languages/esql/commands/grok"><code>GROK</code></a> - <a href="https://www.elastic.co/docs/reference/query-languages/esql/commands/fork"><code>FORK</code></a> <code>stack: preview</code> <code>serverless: preview</code> - <a href="https://www.elastic.co/docs/reference/query-languages/esql/commands/fuse"><code>FUSE</code></a> <code>stack: preview</code> <code>serverless: preview</code> - <a href="https://www.elastic.co/docs/reference/query-languages/esql/commands/keep"><code>KEEP</code></a> - <a href="https://www.elastic.co/docs/reference/query-languages/esql/commands/limit"><code>LIMIT</code></a> - <a href="https://www.elastic.co/docs/reference/query-languages/esql/commands/lookup-join"><code>LOOKUP JOIN</code></a> - <a href="https://www.elastic.co/docs/reference/query-languages/esql/commands/inlinestats-by"><code>INLINE STATS</code></a> <code>stack: preview</code> <code>serverless: preview</code> - <a href="https://www.elastic.co/docs/reference/query-languages/esql/commands/mv_expand"><code>MV_EXPAND</code></a> <code>stack: preview</code> <code>serverless: preview</code> - <a href="https://www.elastic.co/docs/reference/query-languages/esql/commands/rename"><code>RENAME</code></a> - <a href="https://www.elastic.co/docs/reference/query-languages/esql/commands/rerank"><code>RERANK</code></a> <code>stack: preview</code> <code>serverless: preview</code> - <a href="https://www.elastic.co/docs/reference/query-languages/esql/commands/sample"><code>SAMPLE</code></a> <code>stack: preview</code> <code>serverless: preview</code> - <a href="https://www.elastic.co/docs/reference/query-languages/esql/commands/sort"><code>SORT</code></a> - <a href="https://www.elastic.co/docs/reference/query-languages/esql/commands/stats-by"><code>STATS</code></a> - <a href="https://www.elastic.co/docs/reference/query-languages/esql/commands/where"><code>WHERE</code></a></p>
"""),                     Map.entry("min", """
<h2 id="min"><code>MIN</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/min.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> </definition> </definitions></p>\n<p><strong>Description</strong> The minimum value of a field. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>aggregate_metric_double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>boolean</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>date</td>\n<td>date</td>\n</tr>\n<tr class="even">\n<td>date_nanos</td>\n<td>date_nanos</td>\n</tr>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>ip</td>\n<td>ip</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>unsigned_long <code>stack: ga 9.2.0</code></td>\n<td>unsigned_long</td>\n</tr>\n<tr class="even">\n<td>version</td>\n<td>version</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Examples</strong></p>\n<pre class="esql"><code>FROM employees\n| STATS MIN(languages)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>MIN(languages):integer</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<p>The expression can use inline functions. For example, to calculate the minimum over an average of a multivalued column, use <code>MV_AVG</code> to first average the multiple values per row, and use the result with the <code>MIN</code> function</p>\n<pre class="esql"><code>FROM employees\n| STATS min_avg_salary_change = MIN(MV_AVG(salary_change))</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>min_avg_salary_change:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>-8.46</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("reverse", """
<h2 id="reverse"><code>REVERSE</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/reverse.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="str"> String expression. If <code>null</code>, the function returns <code>null</code>. </definition> </definitions></p>\n<p><strong>Description</strong> Returns a new string representing the input string in reverse order. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>str</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>keyword</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Examples</strong></p>\n<pre class="esql"><code>ROW message = &quot;Some Text&quot; | EVAL message_reversed = REVERSE(message);</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>message:keyword</th>\n<th>message_reversed:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>Some Text</td>\n<td>txeT emoS</td>\n</tr>\n</tbody>\n</table>\n<p><code>REVERSE</code> works with unicode, too! It keeps unicode grapheme clusters together during reversal.</p>\n<pre class="esql"><code>ROW bending_arts = &quot;💧🪨🔥💨&quot; | EVAL bending_arts_reversed = REVERSE(bending_arts);</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>bending_arts:keyword</th>\n<th>bending_arts_reversed:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>💧🪨🔥💨</td>\n<td>💨🔥🪨💧</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("cosh", """
<h2 id="cosh"><code>COSH</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/cosh.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="number"> Numeric expression. If <code>null</code>, the function returns <code>null</code>. </definition> </definitions></p>\n<p><strong>Description</strong> Returns the <a href="https://en.wikipedia.org/wiki/Hyperbolic_functions">hyperbolic cosine</a> of a number. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>number</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW a=1.8\n| EVAL cosh=COSH(a)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:double</th>\n<th>cosh:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>1.8</td>\n<td>3.1074731763172667</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("greatest", """
<h2 id="greatest"><code>GREATEST</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/greatest.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="first"> First of the columns to evaluate. </definition> <definition term="rest"> The rest of the columns to evaluate. </definition> </definitions></p>\n<strong>Description</strong> Returns the maximum value from multiple columns. This is similar to <a href="/docs/reference/query-languages/esql/functions-operators/mv-functions#esql-mv_max"><code>MV_MAX</code></a> except it is intended to run on multiple columns at once.\n<note>\nWhen run on <code>keyword</code> or <code>text</code> fields, this returns the last string in alphabetical order. When run on <code>boolean</code> columns this will return <code>true</code> if any values are <code>true</code>.\n</note>\n<p><strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>first</th>\n<th>rest</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>boolean</td>\n<td>boolean</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>boolean</td>\n<td></td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>date</td>\n<td>date</td>\n<td>date</td>\n</tr>\n<tr class="even">\n<td>date_nanos</td>\n<td>date_nanos</td>\n<td>date_nanos</td>\n</tr>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>integer</td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td></td>\n<td>integer</td>\n</tr>\n<tr class="even">\n<td>ip</td>\n<td>ip</td>\n<td>ip</td>\n</tr>\n<tr class="odd">\n<td>keyword</td>\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td></td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td></td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>text</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td></td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>version</td>\n<td>version</td>\n<td>version</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW a = 10, b = 20\n| EVAL g = GREATEST(a, b)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:integer</th>\n<th>b:integer</th>\n<th>g:integer</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>10</td>\n<td>20</td>\n<td>20</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("limit", """
<h1 id="limit">LIMIT</h1>\n<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="fu">serverless</span><span class="kw">:</span><span class="at"> ga</span></span>\n<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="fu">stack</span><span class="kw">:</span><span class="at"> ga</span></span></code></pre></div>\n<p>The <code>LIMIT</code> processing command enables you to limit the number of rows that are returned. <strong>Syntax</strong></p>\n<pre class="esql"><code>LIMIT max_number_of_rows</code></pre>\n<p><strong>Parameters</strong> <definitions> <definition term="max_number_of_rows"> The maximum number of rows to return. </definition> </definitions></p>\n<p><strong>Description</strong> The <code>LIMIT</code> processing command enables you to limit the number of rows that are returned. For instance,</p>\n<pre class="esql"><code>FROM index | WHERE field = &quot;value&quot;</code></pre>\n<p>is equivalent to:</p>\n<pre class="esql"><code>FROM index | WHERE field = &quot;value&quot; | LIMIT 1000</code></pre>\n<p>Queries do not return more than 10,000 rows, regardless of the <code>LIMIT</code> command’s value. This is a configurable upper limit. To overcome this limitation: - Reduce the result set size by modifying the query to only return relevant data. Use <a href="https://www.elastic.co/docs/reference/query-languages/esql/commands/where"><code>WHERE</code></a> to select a smaller subset of the data. - Shift any post-query processing to the query itself. You can use the ES|QL <a href="https://www.elastic.co/docs/reference/query-languages/esql/commands/stats-by"><code>STATS</code></a> command to aggregate data in the query.</p>\n<p>The upper limit only applies to the number of rows that are output by the query, not to the number of documents it processes: the query runs on the full data set. Consider the following two queries:</p>\n<pre class="esql"><code>FROM index | WHERE field0 == &quot;value&quot; | LIMIT 20000</code></pre>\n<p>and</p>\n<pre class="esql"><code>FROM index | STATS AVG(field1) BY field2 | LIMIT 20000</code></pre>\n<p>In both cases, the filtering by <code>field0</code> in the first query or the grouping by <code>field2</code> in the second is applied over all the documents present in the <code>index</code>, irrespective of their number or indexes size. However, both queries will return at most 10,000 rows, even if there were more rows available to return. The default and maximum limits can be changed using these dynamic cluster settings: - <code>esql.query.result_truncation_default_size</code> - <code>esql.query.result_truncation_max_size</code></p>\n<p>However, doing so involves trade-offs. A larger result-set involves a higher memory pressure and increased processing times; the internode traffic within and across clusters can also increase. These limitations are similar to those enforced by the <a href="https://www.elastic.co/docs/reference/elasticsearch/rest-apis/paginate-search-results">search API for pagination</a>.</p>\n<table>\n<colgroup>\n<col style="width: 33%" />\n<col style="width: 24%" />\n<col style="width: 42%" />\n</colgroup>\n<thead>\n<tr class="header">\n<th>Functionality</th>\n<th>Search</th>\n<th>ES</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>Results returned by default</td>\n<td>10</td>\n<td>1.000</td>\n</tr>\n<tr class="even">\n<td>Default upper limit</td>\n<td>10,000</td>\n<td>10,000</td>\n</tr>\n<tr class="odd">\n<td>Specify number of results</td>\n<td><code>size</code></td>\n<td><code>LIMIT</code></td>\n</tr>\n<tr class="even">\n<td>Change default number of results</td>\n<td>n/a</td>\n<td>esql.query.result_truncation_default_size</td>\n</tr>\n<tr class="odd">\n<td>Change default upper limit</td>\n<td>index-max-result-window</td>\n<td>esql.query.result_truncation_max_size</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>FROM employees\n| SORT emp_no ASC\n| LIMIT 5</code></pre>
"""),                     Map.entry("mv_last", """
<h2 id="mv_last"><code>MV_LAST</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/mv_last.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> Multivalue expression. </definition> </definitions></p>\n<p><strong>Description</strong> Converts a multivalue expression into a single valued column containing the last value. This is most useful when reading from a function that emits multivalued columns in a known order like <a href="/docs/reference/query-languages/esql/functions-operators/string-functions#esql-split"><code>SPLIT</code></a>. The order that <a href="https://www.elastic.co/docs/reference/query-languages/esql/esql-multivalued-fields">multivalued fields</a> are read from underlying storage is not guaranteed. It is <strong>frequently</strong> ascending, but don’t rely on that. If you need the maximum value use <a href="#esql-mv_max"><code>MV_MAX</code></a> instead of <code>MV_LAST</code>. <code>MV_MAX</code> has optimizations for sorted values so there isn’t a performance benefit to <code>MV_LAST</code>. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>boolean</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>cartesian_point</td>\n<td>cartesian_point</td>\n</tr>\n<tr class="odd">\n<td>cartesian_shape</td>\n<td>cartesian_shape</td>\n</tr>\n<tr class="even">\n<td>date</td>\n<td>date</td>\n</tr>\n<tr class="odd">\n<td>date_nanos</td>\n<td>date_nanos</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>geo_point</td>\n<td>geo_point</td>\n</tr>\n<tr class="even">\n<td>geo_shape</td>\n<td>geo_shape</td>\n</tr>\n<tr class="odd">\n<td>geohash</td>\n<td>geohash</td>\n</tr>\n<tr class="even">\n<td>geohex</td>\n<td>geohex</td>\n</tr>\n<tr class="odd">\n<td>geotile</td>\n<td>geotile</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>ip</td>\n<td>ip</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>unsigned_long</td>\n<td>unsigned_long</td>\n</tr>\n<tr class="even">\n<td>version</td>\n<td>version</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW a=&quot;foo;bar;baz&quot;\n| EVAL last_a = MV_LAST(SPLIT(a, &quot;;&quot;))</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:keyword</th>\n<th>last_a:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>foo;bar;baz</td>\n<td>“baz”</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("rtrim", """
<h2 id="rtrim"><code>RTRIM</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/rtrim.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="string"> String expression. If <code>null</code>, the function returns <code>null</code>. </definition> </definitions></p>\n<p><strong>Description</strong> Removes trailing whitespaces from a string. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>string</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>keyword</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW message = &quot;   some text  &quot;,  color = &quot; red &quot;\n| EVAL message = RTRIM(message)\n| EVAL color = RTRIM(color)\n| EVAL message = CONCAT(&quot;&#39;&quot;, message, &quot;&#39;&quot;)\n| EVAL color = CONCAT(&quot;&#39;&quot;, color, &quot;&#39;&quot;)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>message:keyword</th>\n<th>color:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>’ some text’</td>\n<td>’ red’</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("md5", """
<h2 id="md5"><code>MD5</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/md5.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="input"> Input to hash. </definition> </definitions></p>\n<p><strong>Description</strong> Computes the MD5 hash of the input (if the MD5 hash is available on the JVM). <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>input</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>keyword</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>FROM sample_data\n| WHERE message != &quot;Connection error&quot;\n| EVAL md5 = md5(message)\n| KEEP message, md5</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>message:keyword</th>\n<th>md5:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>Connected to 10.1.0.1</td>\n<td>abd7d1ce2bb636842a29246b3512dcae</td>\n</tr>\n<tr class="even">\n<td>Connected to 10.1.0.2</td>\n<td>8f8f1cb60832d153f5b9ec6dc828b93f</td>\n</tr>\n<tr class="odd">\n<td>Connected to 10.1.0.3</td>\n<td>912b6dc13503165a15de43304bb77c78</td>\n</tr>\n<tr class="even">\n<td>Disconnected</td>\n<td>ef70e46fd3bbc21e3e1f0b6815e750c0</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("st_geotile", """
<h2 id="st_geotile"><code>ST_GEOTILE</code></h2>\n<pre><code>stack: preview\nserverless: preview</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/st_geotile.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="geometry"> Expression of type <code>geo_point</code>. If <code>null</code>, the function returns <code>null</code>. </definition> <definition term="precision"> Expression of type <code>integer</code>. If <code>null</code>, the function returns <code>null</code>. Valid values are between <a href="https://wiki.openstreetmap.org/wiki/Zoom_levels">0 and 29</a>. </definition> <definition term="bounds"> Optional bounds to filter the grid tiles, a <code>geo_shape</code> of type <code>BBOX</code>. Use <a href="#esql-st_envelope"><code>ST_ENVELOPE</code></a> if the <code>geo_shape</code> is of any other type. </definition> </definitions></p>\n<p><strong>Description</strong> Calculates the <code>geotile</code> of the supplied geo_point at the specified precision. The result is long encoded. Use <a href="#esql-to_string">TO_STRING</a> to convert the result to a string, <a href="#esql-to_long">TO_LONG</a> to convert it to a <code>long</code>, or <a href="#esql-to_geoshape">TO_GEOSHAPE</a> to calculate the <code>geo_shape</code> bounding geometry. These functions are related to the <a href="https://www.elastic.co/docs/reference/query-languages/query-dsl/query-dsl-geo-grid-query"><code>geo_grid</code> query</a> and the <a href="https://www.elastic.co/docs/reference/aggregations/search-aggregations-bucket-geotilegrid-aggregation"><code>geotile_grid</code> aggregation</a>. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>geometry</th>\n<th>precision</th>\n<th>bounds</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>geo_point</td>\n<td>integer</td>\n<td>geo_shape</td>\n<td>geotile</td>\n</tr>\n<tr class="even">\n<td>geo_point</td>\n<td>integer</td>\n<td></td>\n<td>geotile</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>FROM airports\n| EVAL geotile = ST_GEOTILE(location, 2)\n| STATS\n    count = COUNT(geotile),\n    centroid = ST_CENTROID_AGG(location)\n      BY geotile\n| EVAL geotileString = TO_STRING(geotile)\n| SORT count DESC, geotileString ASC\n| KEEP count, centroid, geotileString</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>count:long</th>\n<th>centroid:geo_point</th>\n<th>geotileString:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>286</td>\n<td>POINT (39.31202001609169 35.149993664386415)</td>\n<td>2/2/1</td>\n</tr>\n<tr class="even">\n<td>197</td>\n<td>POINT (-55.387361375756825 31.952955322292855)</td>\n<td>2/1/1</td>\n</tr>\n<tr class="odd">\n<td>136</td>\n<td>POINT (-110.97162496141048 36.87185255084734)</td>\n<td>2/0/1</td>\n</tr>\n<tr class="even">\n<td>106</td>\n<td>POINT (119.35907618669827 25.46263281488791)</td>\n<td>2/3/1</td>\n</tr>\n<tr class="odd">\n<td>67</td>\n<td>POINT (-58.031108492373754 -22.624166105151065)</td>\n<td>2/1/2</td>\n</tr>\n<tr class="even">\n<td>46</td>\n<td>POINT (142.95455511274707 -20.581492295427978)</td>\n<td>2/3/2</td>\n</tr>\n<tr class="odd">\n<td>34</td>\n<td>POINT (31.38476753634784 -14.64374022804858)</td>\n<td>2/2/2</td>\n</tr>\n<tr class="even">\n<td>8</td>\n<td>POINT (-160.0723083713092 -19.124013530672528)</td>\n<td>2/0/2</td>\n</tr>\n<tr class="odd">\n<td>6</td>\n<td>POINT (23.95813101902604 70.17537698848173)</td>\n<td>2/2/0</td>\n</tr>\n<tr class="even">\n<td>3</td>\n<td>POINT (-133.4001641627401 72.06833167467266)</td>\n<td>2/0/0</td>\n</tr>\n<tr class="odd">\n<td>2</td>\n<td>POINT (-68.47209956031293 66.77569948369637)</td>\n<td>2/1/0</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("url_encode", """
<h2 id="url_encode"><code>URL_ENCODE</code></h2>\n<pre><code>stack: ga 9.2.0</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/url_encode.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="string"> The URL to encode. </definition> </definitions></p>\n<p><strong>Description</strong> URL-encodes the input. All characters are <a href="https://en.wikipedia.org/wiki/Percent-encoding">percent-encoded</a> except for alphanumerics, <code>.</code>, <code>-</code>, <code>_</code>, and <code>~</code>. Spaces are encoded as <code>+</code>. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>string</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>keyword</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW u = &quot;https://example.com/?x=foo bar&amp;y=baz&quot; | EVAL u = URL_ENCODE(u)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>u:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>https%3A%2F%2Fexample.com%2F%3Fx%3Dfoo+bar%26y%3Dbaz</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("to_boolean", """
<h2 id="to_boolean"><code>TO_BOOLEAN</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/to_boolean.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> Input value. The input can be a single- or multi-valued column or an expression. </definition> </definitions></p>\n<p><strong>Description</strong> Converts an input value to a boolean value. A string value of <code>true</code> will be case-insensitive converted to the Boolean <code>true</code>. For anything else, including the empty string, the function will return <code>false</code>. The numerical value of <code>0</code> will be converted to <code>false</code>, anything else will be converted to <code>true</code>. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>boolean</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>unsigned_long</td>\n<td>boolean</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW str = [&quot;true&quot;, &quot;TRuE&quot;, &quot;false&quot;, &quot;&quot;, &quot;yes&quot;, &quot;1&quot;]\n| EVAL bool = TO_BOOLEAN(str)</code></pre>\n<table>\n<colgroup>\n<col style="width: 50%" />\n<col style="width: 49%" />\n</colgroup>\n<thead>\n<tr class="header">\n<th>str:keyword</th>\n<th>bool:boolean</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>[“true”, “TRuE”, “false”, "“,”yes“,”1"]</td>\n<td>[true, true, false, false, false, false]</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("rate", """
<h2 id="rate"><code>RATE</code></h2>\n<pre><code>stack: preview 9.2.0\nserverless: preview</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/rate.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> </definition> </definitions></p>\n<p><strong>Description</strong> Calculates the per-second average rate of increase of a <a href="https://www.elastic.co/docs/manage-data/data-store/data-streams/time-series-data-stream-tsds#time-series-metric">counter</a>. Rate calculations account for breaks in monotonicity, such as counter resets when a service restarts, and extrapolate values within each bucketed time interval. Rate is the most appropriate aggregate function for counters. It is only allowed in a <a href="https://www.elastic.co/docs/reference/query-languages/esql/commands/stats-by">STATS</a> command under a <a href="https://www.elastic.co/docs/reference/query-languages/esql/commands/ts"><code>TS</code></a> source command, to be properly applied per time series. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>counter_double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>counter_integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>counter_long</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>TS k8s\n| STATS max_rate=MAX(RATE(network.total_bytes_in)) BY time_bucket = TBUCKET(5minute)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>max_rate: double</th>\n<th>time_bucket:date</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>6.980660660660663</td>\n<td>2024-05-10T00:20:00.000Z</td>\n</tr>\n<tr class="even">\n<td>23.702205882352942</td>\n<td>2024-05-10T00:15:00.000Z</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("kql", """
<h2 id="kql"><code>KQL</code></h2>\n<pre><code>stack: preview 9.0.0, ga 9.1.0</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/kql.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="query"> Query string in KQL query string format. </definition> <definition term="options"> (Optional) KQL additional options as <a href="/docs/reference/query-languages/esql/esql-syntax#esql-function-named-params">function named parameters</a>. Available in stack version 9.3.0 and later. </definition> </definitions></p>\n<p><strong>Description</strong> Performs a KQL query. Returns true if the provided KQL query string matches the row. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>query</th>\n<th>options</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>keyword</td>\n<td>named parameters</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td></td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>named parameters</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td></td>\n<td>boolean</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Supported function named parameters</strong> <definitions> <definition term="boost"> (float) Floating point number used to decrease or increase the relevance scores of the query. Defaults to 1.0. </definition> <definition term="time_zone"> (keyword) UTC offset or IANA time zone used to interpret date literals in the query string. </definition> <definition term="case_insensitive"> (boolean) If true, performs case-insensitive matching for keyword fields. Defaults to false. </definition> <definition term="default_field"> (keyword) Default field to search if no field is provided in the query string. Supports wildcards (*). </definition> </definitions></p>\n<p><strong>Examples</strong> Use KQL to filter by a specific field value</p>\n<pre class="esql"><code>FROM books\n| WHERE KQL(&quot;author: Faulkner&quot;)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>book_no:keyword</th>\n<th>author:text</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>2378</td>\n<td>[Carol Faulkner, Holly Byers Ochoa, Lucretia Mott]</td>\n</tr>\n<tr class="even">\n<td>2713</td>\n<td>William Faulkner</td>\n</tr>\n<tr class="odd">\n<td>2847</td>\n<td>Colleen Faulkner</td>\n</tr>\n<tr class="even">\n<td>2883</td>\n<td>William Faulkner</td>\n</tr>\n<tr class="odd">\n<td>3293</td>\n<td>Danny Faulkner</td>\n</tr>\n</tbody>\n</table>\n<pre><code>stack: ga 9.3.0</code></pre>\n<p>Use KQL with additional options for case-insensitive matching and custom settings</p>\n<pre class="esql"><code>FROM employees\n| WHERE KQL(&quot;mary&quot;, {&quot;case_insensitive&quot;: true, &quot;default_field&quot;: &quot;first_name&quot;, &quot;boost&quot;: 1.5})</code></pre>
"""),                     Map.entry("st_y", """
<h2 id="st_y"><code>ST_Y</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/st_y.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="point"> Expression of type <code>geo_point</code> or <code>cartesian_point</code>. If <code>null</code>, the function returns <code>null</code>. </definition> </definitions></p>\n<p><strong>Description</strong> Extracts the <code>y</code> coordinate from the supplied point. If the points is of type <code>geo_point</code> this is equivalent to extracting the <code>latitude</code> value. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>point</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>cartesian_point</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>geo_point</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW point = TO_GEOPOINT(&quot;POINT(42.97109629958868 14.7552534006536)&quot;)\n| EVAL x =  ST_X(point), y = ST_Y(point)</code></pre>\n<table style="width:100%;">\n<colgroup>\n<col style="width: 53%" />\n<col style="width: 23%" />\n<col style="width: 22%" />\n</colgroup>\n<thead>\n<tr class="header">\n<th>point:geo_point</th>\n<th>x:double</th>\n<th>y:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>POINT(42.97109629958868 14.7552534006536)</td>\n<td>42.97109629958868</td>\n<td>14.7552534006536</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("to_base64", """
<h2 id="to_base64"><code>TO_BASE64</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/to_base64.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="string"> A string. </definition> </definitions></p>\n<p><strong>Description</strong> Encode a string to a base64 string. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>string</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>keyword</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW a = &quot;elastic&quot;\n| EVAL e = TO_BASE64(a)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:keyword</th>\n<th>e:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>elastic</td>\n<td>ZWxhc3RpYw==</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("mv_count", """
<h2 id="mv_count"><code>MV_COUNT</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/mv_count.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> Multivalue expression. </definition> </definitions></p>\n<p><strong>Description</strong> Converts a multivalued expression into a single valued column containing a count of the number of values. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>boolean</td>\n<td>integer</td>\n</tr>\n<tr class="even">\n<td>cartesian_point</td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>cartesian_shape</td>\n<td>integer</td>\n</tr>\n<tr class="even">\n<td>date</td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>date_nanos</td>\n<td>integer</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>geo_point</td>\n<td>integer</td>\n</tr>\n<tr class="even">\n<td>geo_shape</td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>geohash</td>\n<td>integer</td>\n</tr>\n<tr class="even">\n<td>geohex</td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>geotile</td>\n<td>integer</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>ip</td>\n<td>integer</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>integer</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>unsigned_long</td>\n<td>integer</td>\n</tr>\n<tr class="even">\n<td>version</td>\n<td>integer</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW a=[&quot;foo&quot;, &quot;zoo&quot;, &quot;bar&quot;]\n| EVAL count_a = MV_COUNT(a)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:keyword</th>\n<th>count_a:integer</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>[“foo”, “zoo”, “bar”]</td>\n<td>3</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("values", """
<h2 id="values"><code>VALUES</code></h2>\n<pre><code>stack: preview\nserverless: preview</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/values.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> </definition> </definitions></p>\n<p><strong>Description</strong> Returns unique values as a multivalued field. The order of the returned values isn’t guaranteed. If you need the values returned in order use <a href="/docs/reference/query-languages/esql/functions-operators/mv-functions#esql-mv_sort"><code>MV_SORT</code></a>. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>boolean</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>cartesian_point</td>\n<td>cartesian_point</td>\n</tr>\n<tr class="odd">\n<td>cartesian_shape</td>\n<td>cartesian_shape</td>\n</tr>\n<tr class="even">\n<td>date</td>\n<td>date</td>\n</tr>\n<tr class="odd">\n<td>date_nanos</td>\n<td>date_nanos</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>geo_point</td>\n<td>geo_point</td>\n</tr>\n<tr class="even">\n<td>geo_shape</td>\n<td>geo_shape</td>\n</tr>\n<tr class="odd">\n<td>geohash</td>\n<td>geohash</td>\n</tr>\n<tr class="even">\n<td>geohex</td>\n<td>geohex</td>\n</tr>\n<tr class="odd">\n<td>geotile</td>\n<td>geotile</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>ip</td>\n<td>ip</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>unsigned_long</td>\n<td>unsigned_long</td>\n</tr>\n<tr class="even">\n<td>version</td>\n<td>version</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>FROM employees\n| EVAL first_letter = SUBSTRING(first_name, 0, 1)\n| STATS first_name = MV_SORT(VALUES(first_name)) BY first_letter\n| SORT first_letter</code></pre>\n<table>\n<colgroup>\n<col style="width: 81%" />\n<col style="width: 18%" />\n</colgroup>\n<thead>\n<tr class="header">\n<th>first_name:keyword</th>\n<th>first_letter:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>[Alejandro, Amabile, Anneke, Anoosh, Arumugam]</td>\n<td>A</td>\n</tr>\n<tr class="even">\n<td>[Basil, Berhard, Berni, Bezalel, Bojan, Breannda, Brendon]</td>\n<td>B</td>\n</tr>\n<tr class="odd">\n<td>[Charlene, Chirstian, Claudi, Cristinel]</td>\n<td>C</td>\n</tr>\n<tr class="even">\n<td>[Danel, Divier, Domenick, Duangkaew]</td>\n<td>D</td>\n</tr>\n<tr class="odd">\n<td>[Ebbe, Eberhardt, Erez]</td>\n<td>E</td>\n</tr>\n<tr class="even">\n<td>Florian</td>\n<td>F</td>\n</tr>\n<tr class="odd">\n<td>[Gao, Georgi, Georgy, Gino, Guoxiang]</td>\n<td>G</td>\n</tr>\n<tr class="even">\n<td>[Heping, Hidefumi, Hilari, Hironobu, Hironoby, Hisao]</td>\n<td>H</td>\n</tr>\n<tr class="odd">\n<td>[Jayson, Jungsoon]</td>\n<td>J</td>\n</tr>\n<tr class="even">\n<td>[Kazuhide, Kazuhito, Kendra, Kenroku, Kshitij, Kwee, Kyoichi]</td>\n<td>K</td>\n</tr>\n<tr class="odd">\n<td>[Lillian, Lucien]</td>\n<td>L</td>\n</tr>\n<tr class="even">\n<td>[Magy, Margareta, Mary, Mayuko, Mayumi, Mingsen, Mokhtar, Mona, Moss]</td>\n<td>M</td>\n</tr>\n<tr class="odd">\n<td>Otmar</td>\n<td>O</td>\n</tr>\n<tr class="even">\n<td>[Parto, Parviz, Patricio, Prasadram, Premal]</td>\n<td>P</td>\n</tr>\n<tr class="odd">\n<td>[Ramzi, Remzi, Reuven]</td>\n<td>R</td>\n</tr>\n<tr class="even">\n<td>[Sailaja, Saniya, Sanjiv, Satosi, Shahaf, Shir, Somnath, Sreekrishna, Sudharsan, Sumant, Suzette]</td>\n<td>S</td>\n</tr>\n<tr class="odd">\n<td>[Tse, Tuval, Tzvetan]</td>\n<td>T</td>\n</tr>\n<tr class="even">\n<td>[Udi, Uri]</td>\n<td>U</td>\n</tr>\n<tr class="odd">\n<td>[Valdiodio, Valter, Vishv]</td>\n<td>V</td>\n</tr>\n<tr class="even">\n<td>Weiyi</td>\n<td>W</td>\n</tr>\n<tr class="odd">\n<td>Xinglin</td>\n<td>X</td>\n</tr>\n<tr class="even">\n<td>[Yinghua, Yishay, Yongqiao]</td>\n<td>Y</td>\n</tr>\n<tr class="odd">\n<td>[Zhongwei, Zvonko]</td>\n<td>Z</td>\n</tr>\n<tr class="even">\n<td>null</td>\n<td>null</td>\n</tr>\n</tbody>\n</table>\n<tip>\nUse <a href="#esql-top"><code>TOP</code></a> if you need to keep repeated values.\n</tip>\n<warning>\nThis can use a significant amount of memory and ESQL doesn’t yet grow aggregations beyond memory. So this aggregation will work until it is used to collect more values than can fit into memory. Once it collects too many values it will fail the query with a <a href="https://www.elastic.co/docs/troubleshoot/elasticsearch/circuit-breaker-errors">Circuit Breaker Error</a>.\n</warning>
"""),                     Map.entry("mv_median", """
<h2 id="mv_median"><code>MV_MEDIAN</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/mv_median.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="number"> Multivalue expression. </definition> </definitions></p>\n<p><strong>Description</strong> Converts a multivalued field into a single valued field containing the median value. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>number</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>unsigned_long</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Examples</strong></p>\n<pre class="esql"><code>ROW a=[3, 5, 1]\n| EVAL median_a = MV_MEDIAN(a)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:integer</th>\n<th>median_a:integer</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>[3, 5, 1]</td>\n<td>3</td>\n</tr>\n</tbody>\n</table>\n<p>If the row has an even number of values for a column, the result will be the average of the middle two entries. If the column is not floating point, the average rounds <strong>down</strong>:</p>\n<pre class="esql"><code>ROW a=[3, 7, 1, 6]\n| EVAL median_a = MV_MEDIAN(a)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:integer</th>\n<th>median_a:integer</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>[3, 7, 1, 6]</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("to_double", """
<h2 id="to_double"><code>TO_DOUBLE</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/to_double.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> Input value. The input can be a single- or multi-valued column or an expression. </definition> </definitions></p>\n<p><strong>Description</strong> Converts an input value to a double value. If the input parameter is of a date type, its value will be interpreted as milliseconds since the <a href="https://en.wikipedia.org/wiki/Unix_time">Unix epoch</a>, converted to double. Boolean <code>true</code> will be converted to double <code>1.0</code>, <code>false</code> to <code>0.0</code>. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>boolean</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>counter_double</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>counter_integer</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>counter_long</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>date</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>unsigned_long</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW str1 = &quot;5.20128E11&quot;, str2 = &quot;foo&quot;\n| EVAL dbl = TO_DOUBLE(&quot;520128000000&quot;), dbl1 = TO_DOUBLE(str1), dbl2 = TO_DOUBLE(str2)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>str1:keyword</th>\n<th>str2:keyword</th>\n<th>dbl:double</th>\n<th>dbl1:double</th>\n<th>dbl2:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>5.20128E11</td>\n<td>foo</td>\n<td>5.20128E11</td>\n<td>5.20128E11</td>\n<td>null</td>\n</tr>\n</tbody>\n</table>\n<p>Note that in this example, the last conversion of the string isn’t possible. When this happens, the result is a <code>null</code> value. In this case a <em>Warning</em> header is added to the response. The header will provide information on the source of the failure: <code>"Line 1:115: evaluation of [TO_DOUBLE(str2)] failed, treating result as null. Only first 20 failures recorded."</code> A following header will contain the failure reason and the offending value: <code>"java.lang.NumberFormatException: For input string: "foo""</code></p>
"""),                     Map.entry("sha256", """
<h2 id="sha256"><code>SHA256</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/sha256.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="input"> Input to hash. </definition> </definitions></p>\n<p><strong>Description</strong> Computes the SHA256 hash of the input. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>input</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>keyword</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>FROM sample_data\n| WHERE message != &quot;Connection error&quot;\n| EVAL sha256 = sha256(message)\n| KEEP message, sha256</code></pre>\n<table>\n<colgroup>\n<col style="width: 25%" />\n<col style="width: 74%" />\n</colgroup>\n<thead>\n<tr class="header">\n<th>message:keyword</th>\n<th>sha256:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>Connected to 10.1.0.1</td>\n<td>6d8372129ad78770f7185554dd39864749a62690216460752d6c075fa38ad85c</td>\n</tr>\n<tr class="even">\n<td>Connected to 10.1.0.2</td>\n<td>b0db24720f15857091b3c99f4c4833586d0ea3229911b8777efb8d917cf27e9a</td>\n</tr>\n<tr class="odd">\n<td>Connected to 10.1.0.3</td>\n<td>75b0480188db8acc4d5cc666a51227eb2bc5b989cd8ca912609f33e0846eff57</td>\n</tr>\n<tr class="even">\n<td>Disconnected</td>\n<td>04dfac3671b494ad53fcd152f7a14511bfb35747278aad8ce254a0d6e4ba4718</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("count_distinct_over_time", """
<h2 id="count_distinct_over_time"><code>COUNT_DISTINCT_OVER_TIME</code></h2>\n<pre><code>stack: preview 9.2.0\nserverless: preview</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/count_distinct_over_time.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> </definition> <definition term="precision"> Precision threshold. Refer to <a href="/docs/reference/query-languages/esql/functions-operators/aggregation-functions#esql-agg-count-distinct-approximate"><code>AGG-COUNT-DISTINCT-APPROXIMATE</code></a>. The maximum supported value is 40000. Thresholds above this number will have the same effect as a threshold of 40000. The default value is 3000. </definition> </definitions></p>\n<p><strong>Description</strong> Calculates the count of distinct values over time for a field. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>precision</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>boolean</td>\n<td>integer</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>boolean</td>\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>boolean</td>\n<td>unsigned_long</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>boolean</td>\n<td></td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>date</td>\n<td>integer</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>date</td>\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>date</td>\n<td>unsigned_long</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>date</td>\n<td></td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>date_nanos</td>\n<td>integer</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>date_nanos</td>\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>date_nanos</td>\n<td>unsigned_long</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>date_nanos</td>\n<td></td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>double</td>\n<td>integer</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>double</td>\n<td>unsigned_long</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td></td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>integer</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>unsigned_long</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td></td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>ip</td>\n<td>integer</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>ip</td>\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>ip</td>\n<td>unsigned_long</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>ip</td>\n<td></td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>keyword</td>\n<td>integer</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>keyword</td>\n<td>unsigned_long</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td></td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>integer</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>unsigned_long</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td></td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>integer</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>unsigned_long</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td></td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>version</td>\n<td>integer</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>version</td>\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>version</td>\n<td>unsigned_long</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>version</td>\n<td></td>\n<td>long</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>TS k8s\n| STATS distincts=COUNT_DISTINCT(COUNT_DISTINCT_OVER_TIME(network.cost)),\n        distincts_imprecise=COUNT_DISTINCT(COUNT_DISTINCT_OVER_TIME(network.cost, 100))\n  BY cluster, time_bucket = TBUCKET(1minute)</code></pre>\n<table>\n<colgroup>\n<col style="width: 18%" />\n<col style="width: 30%" />\n<col style="width: 20%" />\n<col style="width: 30%" />\n</colgroup>\n<thead>\n<tr class="header">\n<th>distincts:long</th>\n<th>distincts_imprecise:long</th>\n<th>cluster:keyword</th>\n<th>time_bucket:datetime</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>3</td>\n<td>3</td>\n<td>qa</td>\n<td>2024-05-10T00:17:00.000Z</td>\n</tr>\n<tr class="even">\n<td>3</td>\n<td>3</td>\n<td>qa</td>\n<td>2024-05-10T00:15:00.000Z</td>\n</tr>\n<tr class="odd">\n<td>3</td>\n<td>3</td>\n<td>prod</td>\n<td>2024-05-10T00:09:00.000Z</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("day_name", """
<h2 id="day_name"><code>DAY_NAME</code></h2>\n<pre><code>stack: ga 9.2.0</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/day_name.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="date"> Date expression. If <code>null</code>, the function returns <code>null</code>. </definition> </definitions></p>\n<p><strong>Description</strong> Returns the name of the weekday for date based on the configured Locale. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>date</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>date</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>date_nanos</td>\n<td>keyword</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW dt = to_datetime(&quot;1953-09-02T00:00:00.000Z&quot;)\n| EVAL weekday = DAY_NAME(dt);</code></pre>
"""),                     Map.entry("absent", """
<h2 id="absent"><code>ABSENT</code></h2>\n<pre><code>stack: ga 9.2.0</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/absent.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> Expression that outputs values to be checked for absence. </definition> </definitions></p>\n<p><strong>Description</strong> Returns true if the input expression yields no non-null values within the current aggregation context. Otherwise it returns false. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>aggregate_metric_double</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>boolean</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>cartesian_point</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>cartesian_shape</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>date</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>date_nanos</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>double</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>geo_point</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>geo_shape</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>geohash</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>geohex</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>geotile</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>ip</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>keyword</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>version</td>\n<td>boolean</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Examples</strong></p>\n<pre class="esql"><code>FROM employees\n| WHERE emp_no == 10020\n| STATS is_absent = ABSENT(languages)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>is_absent:boolean</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>true</td>\n</tr>\n</tbody>\n</table>\n<p>To check for the absence inside a group use <code>ABSENT()</code> and <code>BY</code> clauses</p>\n<pre class="esql"><code>FROM employees\n| STATS is_absent = ABSENT(salary) BY languages</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>is_absent:boolean</th>\n<th>languages:integer</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>false</td>\n<td>1</td>\n</tr>\n<tr class="even">\n<td>false</td>\n<td>2</td>\n</tr>\n<tr class="odd">\n<td>false</td>\n<td>3</td>\n</tr>\n<tr class="even">\n<td>false</td>\n<td>4</td>\n</tr>\n<tr class="odd">\n<td>false</td>\n<td>5</td>\n</tr>\n<tr class="even">\n<td>false</td>\n<td>null</td>\n</tr>\n</tbody>\n</table>\n<p>To check for the absence and return 1 when it’s true and 0 when it’s false you can use to_integer()</p>\n<pre class="esql"><code>FROM employees\n| WHERE emp_no == 10020\n| STATS is_absent = TO_INTEGER(ABSENT(languages))</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>is_absent:integer</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>1</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("idelta", """
<h2 id="idelta"><code>IDELTA</code></h2>\n<pre><code>stack: preview 9.2.0\nserverless: preview</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/idelta.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> </definition> </definitions></p>\n<p><strong>Description</strong> Calculates the idelta of a gauge. idelta is the absolute change between the last two data points (it ignores all but the last two data points in each time period). This function is very similar to delta, but is more responsive to recent changes. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>TS k8s\n| STATS events = SUM(IDELTA(events_received)) by pod, time_bucket = TBUCKET(10minute)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>events:double</th>\n<th>pod:keyword</th>\n<th>time_bucket:datetime</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>9.0</td>\n<td>one</td>\n<td>2024-05-10T00:10:00.000Z</td>\n</tr>\n<tr class="even">\n<td>7.0</td>\n<td>three</td>\n<td>2024-05-10T00:10:00.000Z</td>\n</tr>\n<tr class="odd">\n<td>3.0</td>\n<td>two</td>\n<td>2024-05-10T00:00:00.000Z</td>\n</tr>\n<tr class="even">\n<td>0.0</td>\n<td>two</td>\n<td>2024-05-10T00:20:00.000Z</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("st_geohex", """
<h2 id="st_geohex"><code>ST_GEOHEX</code></h2>\n<pre><code>stack: preview\nserverless: preview</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/st_geohex.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="geometry"> Expression of type <code>geo_point</code>. If <code>null</code>, the function returns <code>null</code>. </definition> <definition term="precision"> Expression of type <code>integer</code>. If <code>null</code>, the function returns <code>null</code>. Valid values are between <a href="https://h3geo.org/docs/core-library/restable/">0 and 15</a>. </definition> <definition term="bounds"> Optional bounds to filter the grid tiles, a <code>geo_shape</code> of type <code>BBOX</code>. Use <a href="#esql-st_envelope"><code>ST_ENVELOPE</code></a> if the <code>geo_shape</code> is of any other type. </definition> </definitions></p>\n<p><strong>Description</strong> Calculates the <code>geohex</code>, the H3 cell-id, of the supplied geo_point at the specified precision. The result is long encoded. Use <a href="#esql-to_string">TO_STRING</a> to convert the result to a string, <a href="#esql-to_long">TO_LONG</a> to convert it to a <code>long</code>, or <a href="#esql-to_geoshape">TO_GEOSHAPE</a> to calculate the <code>geo_shape</code> bounding geometry. These functions are related to the <a href="https://www.elastic.co/docs/reference/query-languages/query-dsl/query-dsl-geo-grid-query"><code>geo_grid</code> query</a> and the <a href="https://www.elastic.co/docs/reference/aggregations/search-aggregations-bucket-geohexgrid-aggregation"><code>geohex_grid</code> aggregation</a>. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>geometry</th>\n<th>precision</th>\n<th>bounds</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>geo_point</td>\n<td>integer</td>\n<td>geo_shape</td>\n<td>geohex</td>\n</tr>\n<tr class="even">\n<td>geo_point</td>\n<td>integer</td>\n<td></td>\n<td>geohex</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>FROM airports\n| EVAL geohex = ST_GEOHEX(location, 1)\n| STATS\n    count = COUNT(geohex),\n    centroid = ST_CENTROID_AGG(location)\n      BY geohex\n| WHERE count &gt;= 10\n| EVAL geohexString = TO_STRING(geohex)\n| KEEP count, centroid, geohexString\n| SORT count DESC, geohexString ASC</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>count:long</th>\n<th>centroid:geo_point</th>\n<th>geohexString:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>22</td>\n<td>POINT (7.250850197689777 48.21363834643059)</td>\n<td>811fbffffffffff</td>\n</tr>\n<tr class="even">\n<td>18</td>\n<td>POINT (-80.64959161449224 40.04119813675061)</td>\n<td>812abffffffffff</td>\n</tr>\n<tr class="odd">\n<td>17</td>\n<td>POINT (-0.7606179875266903 52.86413913565304)</td>\n<td>81197ffffffffff</td>\n</tr>\n<tr class="even">\n<td>13</td>\n<td>POINT (22.53157936179867 41.98255742864254)</td>\n<td>811efffffffffff</td>\n</tr>\n<tr class="odd">\n<td>13</td>\n<td>POINT (78.30096947387435 26.073904778951636)</td>\n<td>813dbffffffffff</td>\n</tr>\n<tr class="even">\n<td>12</td>\n<td>POINT (-76.39781514415517 45.16300531569868)</td>\n<td>812bbffffffffff</td>\n</tr>\n<tr class="odd">\n<td>12</td>\n<td>POINT (-100.30120467301458 20.114154297625646)</td>\n<td>8149bffffffffff</td>\n</tr>\n<tr class="even">\n<td>11</td>\n<td>POINT (18.037187419831753 48.66540593306788)</td>\n<td>811e3ffffffffff</td>\n</tr>\n<tr class="odd">\n<td>11</td>\n<td>POINT (-83.42379064553164 33.18388901439241)</td>\n<td>8144fffffffffff</td>\n</tr>\n<tr class="even">\n<td>11</td>\n<td>POINT (-99.4237939513881 27.100012352774765)</td>\n<td>8148bffffffffff</td>\n</tr>\n<tr class="odd">\n<td>10</td>\n<td>POINT (128.01009018346667 35.8699960866943)</td>\n<td>8130fffffffffff</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("date_extract", """
<h2 id="date_extract"><code>DATE_EXTRACT</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/date_extract.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="datePart"> Part of the date to extract. Can be: <code>aligned_day_of_week_in_month</code>, <code>aligned_day_of_week_in_year</code>, <code>aligned_week_of_month</code>, <code>aligned_week_of_year</code>, <code>ampm_of_day</code>, <code>clock_hour_of_ampm</code>, <code>clock_hour_of_day</code>, <code>day_of_month</code>, <code>day_of_week</code>, <code>day_of_year</code>, <code>epoch_day</code>, <code>era</code>, <code>hour_of_ampm</code>, <code>hour_of_day</code>, <code>instant_seconds</code>, <code>micro_of_day</code>, <code>micro_of_second</code>, <code>milli_of_day</code>, <code>milli_of_second</code>, <code>minute_of_day</code>, <code>minute_of_hour</code>, <code>month_of_year</code>, <code>nano_of_day</code>, <code>nano_of_second</code>, <code>offset_seconds</code>, <code>proleptic_month</code>, <code>second_of_day</code>, <code>second_of_minute</code>, <code>year</code>, or <code>year_of_era</code>. Refer to <a href="https://docs.oracle.com/javase/8/docs/api/java/time/temporal/ChronoField.html">java.time.temporal.ChronoField</a> for a description of these values. If <code>null</code>, the function returns <code>null</code>. </definition> <definition term="date"> Date expression. If <code>null</code>, the function returns <code>null</code>. </definition> </definitions></p>\n<p><strong>Description</strong> Extracts parts of a date, like year, month, day, hour. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>datePart</th>\n<th>date</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>keyword</td>\n<td>date</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>date_nanos</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>date</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>date_nanos</td>\n<td>long</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Examples</strong></p>\n<pre class="esql"><code>ROW date = DATE_PARSE(&quot;yyyy-MM-dd&quot;, &quot;2022-05-06&quot;)\n| EVAL year = DATE_EXTRACT(&quot;year&quot;, date)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>date:date</th>\n<th>year:long</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>2022-05-06T00:00:00.000Z</td>\n<td>2022</td>\n</tr>\n</tbody>\n</table>\n<p>Find all events that occurred outside of business hours (before 9 AM or after 5PM), on any given date:</p>\n<pre class="esql"><code>FROM sample_data\n| WHERE DATE_EXTRACT(&quot;hour_of_day&quot;, @timestamp) &lt; 9\n    AND DATE_EXTRACT(&quot;hour_of_day&quot;, @timestamp) &gt;= 17</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th><span class="citation" data-cites="timestamp:date">@timestamp:date</span></th>\n<th>client_ip:ip</th>\n<th>event_duration:long</th>\n<th>message:keyword</th>\n</tr>\n</thead>\n<tbody>\n</tbody>\n</table>
"""),                     Map.entry("st_centroid_agg", """
<h2 id="st_centroid_agg"><code>ST_CENTROID_AGG</code></h2>\n<pre><code>stack: preview\nserverless: preview</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/st_centroid_agg.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> </definition> </definitions></p>\n<p><strong>Description</strong> Calculate the spatial centroid over a field with spatial point geometry type. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>cartesian_point</td>\n<td>cartesian_point</td>\n</tr>\n<tr class="even">\n<td>geo_point</td>\n<td>geo_point</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>FROM airports\n| STATS centroid=ST_CENTROID_AGG(location)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>centroid:geo_point</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>POINT(-0.030548143003023033 24.37553649504829)</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("to_geoshape", """
<h2 id="to_geoshape"><code>TO_GEOSHAPE</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/to_geoshape.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> Input value. The input can be a single- or multi-valued column or an expression. </definition> </definitions></p>\n<p><strong>Description</strong> Converts an input value to a <code>geo_shape</code> value. A string will only be successfully converted if it respects the <a href="https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry">WKT</a> format. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>geo_point</td>\n<td>geo_shape</td>\n</tr>\n<tr class="even">\n<td>geo_shape</td>\n<td>geo_shape</td>\n</tr>\n<tr class="odd">\n<td>geohash</td>\n<td>geo_shape</td>\n</tr>\n<tr class="even">\n<td>geohex</td>\n<td>geo_shape</td>\n</tr>\n<tr class="odd">\n<td>geotile</td>\n<td>geo_shape</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>geo_shape</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>geo_shape</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW wkt = &quot;POLYGON ((30 10, 40 40, 20 40, 10 20, 30 10))&quot;\n| EVAL geom = TO_GEOSHAPE(wkt)</code></pre>\n<table>\n<colgroup>\n<col style="width: 51%" />\n<col style="width: 48%" />\n</colgroup>\n<thead>\n<tr class="header">\n<th>wkt:keyword</th>\n<th>geom:geo_shape</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>“POLYGON ((30 10, 40 40, 20 40, 10 20, 30 10))”</td>\n<td>POLYGON ((30 10, 40 40, 20 40, 10 20, 30 10))</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("st_geohash", """
<h2 id="st_geohash"><code>ST_GEOHASH</code></h2>\n<pre><code>stack: preview\nserverless: preview</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/st_geohash.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="geometry"> Expression of type <code>geo_point</code>. If <code>null</code>, the function returns <code>null</code>. </definition> <definition term="precision"> Expression of type <code>integer</code>. If <code>null</code>, the function returns <code>null</code>. Valid values are between <a href="https://en.wikipedia.org/wiki/Geohash">1 and 12</a>. </definition> <definition term="bounds"> Optional bounds to filter the grid tiles, a <code>geo_shape</code> of type <code>BBOX</code>. Use <a href="#esql-st_envelope"><code>ST_ENVELOPE</code></a> if the <code>geo_shape</code> is of any other type. </definition> </definitions></p>\n<p><strong>Description</strong> Calculates the <code>geohash</code> of the supplied geo_point at the specified precision. The result is long encoded. Use <a href="#esql-to_string">TO_STRING</a> to convert the result to a string, <a href="#esql-to_long">TO_LONG</a> to convert it to a <code>long</code>, or <a href="#esql-to_geoshape">TO_GEOSHAPE</a> to calculate the <code>geo_shape</code> bounding geometry. These functions are related to the <a href="https://www.elastic.co/docs/reference/query-languages/query-dsl/query-dsl-geo-grid-query"><code>geo_grid</code> query</a> and the <a href="https://www.elastic.co/docs/reference/aggregations/search-aggregations-bucket-geohashgrid-aggregation"><code>geohash_grid</code> aggregation</a>. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>geometry</th>\n<th>precision</th>\n<th>bounds</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>geo_point</td>\n<td>integer</td>\n<td>geo_shape</td>\n<td>geohash</td>\n</tr>\n<tr class="even">\n<td>geo_point</td>\n<td>integer</td>\n<td></td>\n<td>geohash</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>FROM airports\n| EVAL geohash = ST_GEOHASH(location, 1)\n| STATS\n    count = COUNT(geohash),\n    centroid = ST_CENTROID_AGG(location)\n      BY geohash\n| WHERE count &gt;= 10\n| EVAL geohashString = TO_STRING(geohash)\n| KEEP count, centroid, geohashString\n| SORT count DESC, geohashString ASC</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>count:long</th>\n<th>centroid:geo_point</th>\n<th>geohashString:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>118</td>\n<td>POINT (-77.41857436454018 26.96522968734409)</td>\n<td>d</td>\n</tr>\n<tr class="even">\n<td>96</td>\n<td>POINT (23.181679135886952 27.295384635654045)</td>\n<td>s</td>\n</tr>\n<tr class="odd">\n<td>94</td>\n<td>POINT (70.94076107503807 25.691916451026547)</td>\n<td>t</td>\n</tr>\n<tr class="even">\n<td>90</td>\n<td>POINT (-104.3941700803116 30.811849871650338)</td>\n<td>9</td>\n</tr>\n<tr class="odd">\n<td>89</td>\n<td>POINT (18.71573683606942 53.165169130707305)</td>\n<td>u</td>\n</tr>\n<tr class="even">\n<td>85</td>\n<td>POINT (114.3722876966657 24.908398092505248)</td>\n<td>w</td>\n</tr>\n<tr class="odd">\n<td>51</td>\n<td>POINT (-61.44522591713159 -22.87209844956284)</td>\n<td>6</td>\n</tr>\n<tr class="even">\n<td>38</td>\n<td>POINT (-9.429514887252529 25.497624435045413)</td>\n<td>e</td>\n</tr>\n<tr class="odd">\n<td>34</td>\n<td>POINT (-111.8071846965262 52.464381378993174)</td>\n<td>c</td>\n</tr>\n<tr class="even">\n<td>30</td>\n<td>POINT (28.7045472683385 -14.706001980230212)</td>\n<td>k</td>\n</tr>\n<tr class="odd">\n<td>28</td>\n<td>POINT (159.52750137208827 -25.555616633001982)</td>\n<td>r</td>\n</tr>\n<tr class="even">\n<td>22</td>\n<td>POINT (-4.410395708612421 54.90304926367985)</td>\n<td>g</td>\n</tr>\n<tr class="odd">\n<td>21</td>\n<td>POINT (-69.40534970590046 50.93379438189523)</td>\n<td>f</td>\n</tr>\n<tr class="even">\n<td>17</td>\n<td>POINT (114.05526293222519 -10.898114638950895)</td>\n<td>q</td>\n</tr>\n<tr class="odd">\n<td>16</td>\n<td>POINT (147.40052131412085 21.054660080408212)</td>\n<td>x</td>\n</tr>\n<tr class="even">\n<td>13</td>\n<td>POINT (63.64716878519035 54.37333276101317)</td>\n<td>v</td>\n</tr>\n<tr class="odd">\n<td>12</td>\n<td>POINT (-39.53510569408536 -11.72166372067295)</td>\n<td>7</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("copy_sign", """
<h2 id="copy_sign"><code>COPY_SIGN</code></h2>\n<pre><code>stack: ga 9.1.0</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/copy_sign.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="magnitude"> The expression providing the magnitude of the result. Must be a numeric type. </definition> <definition term="sign"> The expression providing the sign of the result. Must be a numeric type. </definition> </definitions></p>\n<p><strong>Description</strong> Returns a value with the magnitude of the first argument and the sign of the second argument. This function is similar to Java’s Math.copySign(double magnitude, double sign) which is similar to <code>copysign</code> from <a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE 754</a>. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>magnitude</th>\n<th>sign</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>double</td>\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>double</td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>integer</td>\n<td>integer</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>long</td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>double</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>integer</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>long</td>\n<td>long</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>FROM employees\n| EVAL cs1 = COPY_SIGN(salary, LEAST(salary_change))</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>emp_no:integer</th>\n<th>salary:integer</th>\n<th>salary_change:double</th>\n<th>cs1:integer</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>10001</td>\n<td>57305</td>\n<td>1.19</td>\n<td>57305</td>\n</tr>\n<tr class="even">\n<td>10002</td>\n<td>56371</td>\n<td>[-7.23, 11.17]</td>\n<td>-56371</td>\n</tr>\n<tr class="odd">\n<td>10003</td>\n<td>61805</td>\n<td>[12.82, 14.68]</td>\n<td>61805</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("irate", """
<h2 id="irate"><code>IRATE</code></h2>\n<pre><code>stack: preview 9.2.0\nserverless: preview</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/irate.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> </definition> </definitions></p>\n<p><strong>Description</strong> Calculates the irate of a counter field. irate is the per-second rate of increase between the last two data points (it ignores all but the last two data points in each time period). This function is very similar to rate, but is more responsive to recent changes in the rate of increase. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>counter_double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>counter_integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>counter_long</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>TS k8s | WHERE pod == &quot;one&quot;\n| STATS irate_bytes_in = SUM(IRATE(network.total_bytes_in)) BY cluster, time_bucket = TBUCKET(10minute)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>irate_bytes_in:double</th>\n<th>cluster:keyword</th>\n<th>time_bucket:datetime</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>0.07692307692307693</td>\n<td>prod</td>\n<td>2024-05-10T00:00:00.000Z</td>\n</tr>\n<tr class="even">\n<td>830.0</td>\n<td>qa</td>\n<td>2024-05-10T00:00:00.000Z</td>\n</tr>\n<tr class="odd">\n<td>31.375</td>\n<td>staging</td>\n<td>2024-05-10T00:00:00.000Z</td>\n</tr>\n<tr class="even">\n<td>9.854545454545454</td>\n<td>prod</td>\n<td>2024-05-10T00:10:00.000Z</td>\n</tr>\n<tr class="odd">\n<td>18.700000000000003</td>\n<td>qa</td>\n<td>2024-05-10T00:10:00.000Z</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("from_base64", """
<h2 id="from_base64"><code>FROM_BASE64</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/from_base64.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="string"> A base64 string. </definition> </definitions></p>\n<p><strong>Description</strong> Decode a base64 string. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>string</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>keyword</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW a = &quot;ZWxhc3RpYw==&quot;\n| EVAL d = FROM_BASE64(a)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:keyword</th>\n<th>d:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>ZWxhc3RpYw==</td>\n<td>elastic</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("fuse", """
<h1 id="fuse">FUSE</h1>\n<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="fu">serverless</span><span class="kw">:</span><span class="at"> preview</span></span>\n<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="fu">stack</span><span class="kw">:</span><span class="at"> preview 9.2.0</span></span></code></pre></div>\n<p>The <code>FUSE</code> <a href="https://www.elastic.co/docs/reference/query-languages/esql/commands/processing-commands">processing command</a> merges rows from multiple result sets and assigns new relevance scores. <code>FUSE</code> enables <a href="/docs/reference/query-languages/esql/esql-search-tutorial#perform-hybrid-search">hybrid search</a> to combine and score results from multiple queries, together with the <a href="https://www.elastic.co/docs/reference/query-languages/esql/commands/fork"><code>FORK</code></a> command. <code>FUSE</code> works by: 1. Merging rows with matching <code>&lt;key_columns&gt;</code> values 2. Assigning new relevance scores using the specified <code>&lt;fuse_method&gt;</code> algorithm and the values from the <code>&lt;group_column&gt;</code> and <code>&lt;score_column&gt;</code></p>\n<tip>\n<code>FUSE</code> is for search use cases: it merges ranked result sets and computes relevance. Learn more about <a href="https://www.elastic.co/docs/solutions/search/esql-for-search#how-search-works-in-esql">how search works in ES|QL</a>.\n</tip>\n<h2 id="syntax">Syntax</h2>\n<p>Use default parameters:</p>\n<pre class="esql"><code>FUSE</code></pre>\n<p>Specify custom parameters:</p>\n<pre class="esql"><code>FUSE &lt;fuse_method&gt; SCORE BY &lt;score_column&gt; GROUP BY &lt;group_column&gt; KEY BY &lt;key_columns&gt; WITH &lt;options&gt;</code></pre>\n<h2 id="parameters">Parameters</h2>\n<p><definitions> <definition term="fuse_method"> Defaults to <code>RRF</code>. Can be one of <code>RRF</code> (for <a href="https://cormack.uwaterloo.ca/cormacksigir09-rrf.pdf">Reciprocal Rank Fusion</a>) or <code>LINEAR</code> (for linear combination of scores). Designates which method to use to assign new relevance scores. </definition> <definition term="options"> Options for the <code>fuse_method</code>. </definition> </definitions></p>\n<p><tab-set></p>\n<p><tab-item title="RRF"> When <code>fuse_method</code> is <code>RRF</code>, <code>options</code> supports the following parameters: <definitions> <definition term="rank_constant"> Defaults to <code>60</code>. Represents the <code>rank_constant</code> used in the RRF formula. </definition> <definition term="weights"> Defaults to <code>{}</code>. Allows you to set different weights for RRF scores based on <code>group_column</code> values. Refer to the <a href="#set-custom-weights">Set custom weights</a> example. </definition> </definitions> </tab-item></p>\n<p><tab-item title="LINEAR"> When <code>fuse_method</code> is <code>LINEAR</code>, <code>options</code> supports the following parameters: <definitions> <definition term="normalizer"> Defaults to <code>none</code>. Can be one of <code>none</code> or <code>minmax</code>. Specifies which score normalization method to apply. </definition> <definition term="weights"> Defaults to <code>{}</code>. Allows you to different weights for scores based on <code>group_column</code> values. Refer to the <a href="#set-custom-weights">Set custom weights</a> example. </definition> </definitions> </tab-item> </tab-set></p>\n<p><definitions> <definition term="score_column"> Defaults to <code>_score</code>. Designates which column to use to retrieve the relevance scores of the input row and where to output the new relevance scores of the merged rows. </definition> <definition term="group_column"> Defaults to <code>_fork</code>. Designates which column represents the result set. </definition> <definition term="key_columns"> Defaults to <code>_id, _index</code>. Rows with matching <code>key_columns</code> values are merged. </definition> </definitions></p>\n<h2 id="examples">Examples</h2>\n<h3 id="use-rrf">Use RRF</h3>\n<p>In the following example, we use the <a href="https://www.elastic.co/docs/reference/query-languages/esql/commands/fork"><code>FORK</code></a> command to run two different queries: a lexical and a semantic query. We then use <code>FUSE</code> to merge the results (applies <code>RRF</code> by default):</p>\n<pre class="esql"><code>FROM books METADATA _id, _index, _score \n| FORK (WHERE title:&quot;Shakespeare&quot; | SORT _score DESC) \n       (WHERE semantic_title:&quot;Shakespeare&quot; | SORT _score DESC) \n| FUSE </code></pre>\n<h3 id="use-linear-combination">Use linear combination</h3>\n<p><code>FUSE</code> can also use linear score combination:</p>\n<pre class="esql"><code>FROM books METADATA _id, _index, _score \n| FORK (WHERE title:&quot;Shakespeare&quot; | SORT _score DESC) \n       (WHERE semantic_title:&quot;Shakespeare&quot; | SORT _score DESC) \n| FUSE LINEAR </code></pre>\n<h3 id="normalize-scores">Normalize scores</h3>\n<p>When combining results from semantic and lexical queries through linear combination, we recommend first normalizing the scores from each result set. The following example uses <code>minmax</code> score normalization. This means the scores normalize and assign values between 0 and 1, before combining the rows:</p>\n<pre class="esql"><code>FROM books METADATA _id, _index, _score\n| FORK (WHERE title:&quot;Shakespeare&quot; | SORT _score DESC) \n       (WHERE semantic_title:&quot;Shakespeare&quot; | SORT _score DESC) \n| FUSE LINEAR WITH { &quot;normalizer&quot;: &quot;minmax&quot; } </code></pre>\n<h3 id="set-custom-weights">Set custom weights</h3>\n<p><code>FUSE</code> allows you to specify different weights to scores, based on the <code>_fork</code> column values, enabling you to control the relative importance of each query branch in the final results.</p>\n<pre class="esql"><code>FROM books METADATA _id, _index, _score\n| FORK (WHERE title:&quot;Shakespeare&quot; | SORT _score DESC) \n       (WHERE semantic_title:&quot;Shakespeare&quot; | SORT _score DESC) \n| FUSE LINEAR WITH { &quot;weights&quot;: { &quot;fork1&quot;: 0.7, &quot;fork2&quot;: 0.3 }, &quot;normalizer&quot;: &quot;minmax&quot; } </code></pre>\n<h2 id="limitations">Limitations</h2>\n<p>These limitations can be present either when: - <code>FUSE</code> is not combined with <a href="https://www.elastic.co/docs/reference/query-languages/esql/commands/fork"><code>FORK</code></a> - <code>FUSE</code> doesn’t use the default <a href="https://www.elastic.co/docs/reference/query-languages/esql/esql-metadata-fields">metadata</a> columns <code>_id</code>, <code>_index</code>, <code>_score</code> and <code>_fork</code><br />\n1. <code>FUSE</code> assumes that <code>key_columns</code> are single valued. When <code>key_columns</code> are multivalued, <code>FUSE</code> can produce unreliable relevance scores. 2. <code>FUSE</code> automatically assigns a score value of <code>NULL</code> if the <code>&lt;score_column&gt;</code> or <code>&lt;group_column&gt;</code> are multivalued. 3. <code>FUSE</code> assumes that the combination of <code>key_columns</code> and <code>group_column</code> is unique. If not, <code>FUSE</code> can produce unreliable relevance scores.</p>
"""),                     Map.entry("sample", """
<h2 id="sample"><code>SAMPLE</code></h2>\n<pre><code>stack: ga 9.1.0</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/sample.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> The field to collect sample values for. </definition> <definition term="limit"> The maximum number of values to collect. </definition> </definitions></p>\n<p><strong>Description</strong> Collects sample values for a field. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>limit</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>boolean</td>\n<td>integer</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>cartesian_point</td>\n<td>integer</td>\n<td>cartesian_point</td>\n</tr>\n<tr class="odd">\n<td>cartesian_shape</td>\n<td>integer</td>\n<td>cartesian_shape</td>\n</tr>\n<tr class="even">\n<td>date</td>\n<td>integer</td>\n<td>date</td>\n</tr>\n<tr class="odd">\n<td>date_nanos</td>\n<td>integer</td>\n<td>date_nanos</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>geo_point</td>\n<td>integer</td>\n<td>geo_point</td>\n</tr>\n<tr class="even">\n<td>geo_shape</td>\n<td>integer</td>\n<td>geo_shape</td>\n</tr>\n<tr class="odd">\n<td>geohash</td>\n<td>integer</td>\n<td>geohash</td>\n</tr>\n<tr class="even">\n<td>geohex</td>\n<td>integer</td>\n<td>geohex</td>\n</tr>\n<tr class="odd">\n<td>geotile</td>\n<td>integer</td>\n<td>geotile</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>integer</td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>ip</td>\n<td>integer</td>\n<td>ip</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>integer</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>integer</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>integer</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>unsigned_long</td>\n<td>integer</td>\n<td>unsigned_long</td>\n</tr>\n<tr class="even">\n<td>version</td>\n<td>integer</td>\n<td>version</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>FROM employees\n| STATS sample = SAMPLE(gender, 5)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>sample:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>[F, M, M, F, M]</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("mv_min", """
<h2 id="mv_min"><code>MV_MIN</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/mv_min.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> Multivalue expression. </definition> </definitions></p>\n<p><strong>Description</strong> Converts a multivalued expression into a single valued column containing the minimum value. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>boolean</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>date</td>\n<td>date</td>\n</tr>\n<tr class="odd">\n<td>date_nanos</td>\n<td>date_nanos</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>integer</td>\n</tr>\n<tr class="even">\n<td>ip</td>\n<td>ip</td>\n</tr>\n<tr class="odd">\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>unsigned_long</td>\n</tr>\n<tr class="odd">\n<td>version</td>\n<td>version</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Examples</strong></p>\n<pre class="esql"><code>ROW a=[2, 1]\n| EVAL min_a = MV_MIN(a)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:integer</th>\n<th>min_a:integer</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>[2, 1]</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<p>It can be used by any column type, including <code>keyword</code> columns. In that case, it picks the first string, comparing their utf-8 representation byte by byte:</p>\n<pre class="esql"><code>ROW a=[&quot;foo&quot;, &quot;bar&quot;]\n| EVAL min_a = MV_MIN(a)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:keyword</th>\n<th>min_a:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>[“foo”, “bar”]</td>\n<td>“bar”</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("sum", """
<h2 id="sum"><code>SUM</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/sum.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="number"> </definition> </definitions></p>\n<p><strong>Description</strong> The sum of a numeric expression. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>number</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>aggregate_metric_double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>long</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Examples</strong></p>\n<pre class="esql"><code>FROM employees\n| STATS SUM(languages)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>SUM(languages):long</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>281</td>\n</tr>\n</tbody>\n</table>\n<p>The expression can use inline functions. For example, to calculate the sum of each employee’s maximum salary changes, apply the <code>MV_MAX</code> function to each row and then sum the results</p>\n<pre class="esql"><code>FROM employees\n| STATS total_salary_changes = SUM(MV_MAX(salary_change))</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>total_salary_changes:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>446.75</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("least", """
<h2 id="least"><code>LEAST</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/least.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="first"> First of the columns to evaluate. </definition> <definition term="rest"> The rest of the columns to evaluate. </definition> </definitions></p>\n<p><strong>Description</strong> Returns the minimum value from multiple columns. This is similar to <a href="/docs/reference/query-languages/esql/functions-operators/mv-functions#esql-mv_min"><code>MV_MIN</code></a> except it is intended to run on multiple columns at once. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>first</th>\n<th>rest</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>boolean</td>\n<td>boolean</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>boolean</td>\n<td></td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>date</td>\n<td>date</td>\n<td>date</td>\n</tr>\n<tr class="even">\n<td>date_nanos</td>\n<td>date_nanos</td>\n<td>date_nanos</td>\n</tr>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>integer</td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td></td>\n<td>integer</td>\n</tr>\n<tr class="even">\n<td>ip</td>\n<td>ip</td>\n<td>ip</td>\n</tr>\n<tr class="odd">\n<td>keyword</td>\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td></td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td></td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>text</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td></td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>version</td>\n<td>version</td>\n<td>version</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW a = 10, b = 20\n| EVAL l = LEAST(a, b)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:integer</th>\n<th>b:integer</th>\n<th>l:integer</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>10</td>\n<td>20</td>\n<td>10</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("last_over_time", """
<h2 id="last_over_time"><code>LAST_OVER_TIME</code></h2>\n<pre><code>stack: preview 9.2.0\nserverless: preview</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/last_over_time.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> </definition> </definitions></p>\n<p><strong>Description</strong> Calculates the latest value of a field, where recency determined by the <code>@timestamp</code> field. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>counter_double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>counter_integer</td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>counter_long</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>integer</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>long</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>TS k8s\n| STATS max_cost=MAX(LAST_OVER_TIME(network.cost)) BY cluster, time_bucket = TBUCKET(1minute)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>max_cost:double</th>\n<th>cluster:keyword</th>\n<th>time_bucket:datetime</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>12.5</td>\n<td>staging</td>\n<td>2024-05-10T00:09:00.000Z</td>\n</tr>\n<tr class="even">\n<td>12.375</td>\n<td>prod</td>\n<td>2024-05-10T00:17:00.000Z</td>\n</tr>\n<tr class="odd">\n<td>12.375</td>\n<td>qa</td>\n<td>2024-05-10T00:06:00.000Z</td>\n</tr>\n<tr class="even">\n<td>12.375</td>\n<td>qa</td>\n<td>2024-05-10T00:01:00.000Z</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("match_phrase", """
<h2 id="match_phrase"><code>MATCH_PHRASE</code></h2>\n<pre><code>stack: ga 9.1.0</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/match_phrase.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> Field that the query will target. </definition> <definition term="query"> Value to find in the provided field. </definition> <definition term="options"> (Optional) MatchPhrase additional options as <a href="/docs/reference/query-languages/esql/esql-syntax#esql-function-named-params">function named parameters</a>. See <a href="https://www.elastic.co/docs/reference/query-languages/query-dsl/query-dsl-match-query-phrase"><code>match_phrase</code></a> for more information. </definition> </definitions></p>\n<p><strong>Description</strong> Use <code>MATCH_PHRASE</code> to perform a <a href="https://www.elastic.co/docs/reference/query-languages/query-dsl/query-dsl-match-query-phrase"><code>match_phrase</code></a> on the specified field. Using <code>MATCH_PHRASE</code> is equivalent to using the <code>match_phrase</code> query in the Elasticsearch Query DSL. MatchPhrase can be used on <a href="https://www.elastic.co/docs/reference/elasticsearch/mapping-reference/text">text</a> fields, as well as other field types like keyword, boolean, or date types. MatchPhrase is not supported for <a href="https://www.elastic.co/docs/reference/elasticsearch/mapping-reference/semantic-text">semantic_text</a> or numeric types. MatchPhrase can use <a href="/docs/reference/query-languages/esql/esql-syntax#esql-function-named-params">function named parameters</a> to specify additional options for the match_phrase query. All <a href="https://www.elastic.co/docs/reference/query-languages/query-dsl/query-dsl-match-query-phrase"><code>match_phrase</code></a> query parameters are supported. <code>MATCH_PHRASE</code> returns true if the provided query matches the row. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>query</th>\n<th>options</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>keyword</td>\n<td>keyword</td>\n<td>named parameters</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>keyword</td>\n<td>named parameters</td>\n<td>boolean</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Supported function named parameters</strong> <definitions> <definition term="zero_terms_query"> (keyword) Indicates whether all documents or none are returned if the analyzer removes all tokens, such as when using a stop filter. Defaults to none. </definition> <definition term="boost"> (float) Floating point number used to decrease or increase the relevance scores of the query. Defaults to 1.0. </definition> <definition term="analyzer"> (keyword) Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the index’s default analyzer is used. </definition> <definition term="slop"> (integer) Maximum number of positions allowed between matching tokens. Defaults to 0. Transposed terms have a slop of 2. </definition> </definitions></p>\n<p><strong>Example</strong></p>\n<pre><code>stack: ga 9.1.0</code></pre>\n<pre class="esql"><code>FROM books\n| WHERE MATCH_PHRASE(author, &quot;William Faulkner&quot;)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>book_no:keyword</th>\n<th>author:text</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>2713</td>\n<td>William Faulkner</td>\n</tr>\n<tr class="even">\n<td>2883</td>\n<td>William Faulkner</td>\n</tr>\n<tr class="odd">\n<td>4724</td>\n<td>William Faulkner</td>\n</tr>\n<tr class="even">\n<td>4977</td>\n<td>William Faulkner</td>\n</tr>\n<tr class="odd">\n<td>5119</td>\n<td>William Faulkner</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("knn", """
<h2 id="knn"><code>KNN</code></h2>\n<pre><code>stack: preview 9.2.0\nserverless: preview</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/knn.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> Field that the query will target. knn function can be used with dense_vector or semantic_text fields. Other text fields are not allowed </definition> <definition term="query"> Vector value to find top nearest neighbours for. </definition> <definition term="options"> (Optional) kNN additional options as <a href="/docs/reference/query-languages/esql/esql-syntax#esql-function-named-params">function named parameters</a>. See <a href="https://www.elastic.co/docs/reference/query-languages/query-dsl/query-dsl-knn-query">knn query</a> for more information. </definition> </definitions></p>\n<p><strong>Description</strong> Finds the k nearest vectors to a query vector, as measured by a similarity metric. knn function finds nearest vectors through approximate search on indexed dense_vectors or semantic_text fields. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>query</th>\n<th>options</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>dense_vector</td>\n<td>dense_vector</td>\n<td>named parameters</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>dense_vector</td>\n<td>named parameters</td>\n<td>boolean</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Supported function named parameters</strong> <definitions> <definition term="boost"> (float) Floating point number used to decrease or increase the relevance scores of the query.Defaults to 1.0. </definition> <definition term="min_candidates"> (integer) The minimum number of nearest neighbor candidates to consider per shard while doing knn search. KNN may use a higher number of candidates in case the query can’t use a approximate results. Cannot exceed 10,000. Increasing min_candidates tends to improve the accuracy of the final results. Defaults to 1.5 * LIMIT used for the query. </definition> <definition term="rescore_oversample"> (double) Applies the specified oversampling for rescoring quantized vectors. See <a href="https://www.elastic.co/docs/solutions/search/vector/knn#dense-vector-knn-search-rescoring">oversampling and rescoring quantized vectors</a> for details. </definition> <definition term="similarity"> (double) The minimum similarity required for a document to be considered a match. The similarity value calculated relates to the raw similarity used, not the document score. </definition> </definitions></p>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>from colors metadata _score\n| where knn(rgb_vector, [0, 120, 0])\n| sort _score desc, color asc</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>color:text</th>\n<th>rgb_vector:dense_vector</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>green</td>\n<td>[0.0, 128.0, 0.0]</td>\n</tr>\n<tr class="even">\n<td>black</td>\n<td>[0.0, 0.0, 0.0]</td>\n</tr>\n<tr class="odd">\n<td>olive</td>\n<td>[128.0, 128.0, 0.0]</td>\n</tr>\n<tr class="even">\n<td>teal</td>\n<td>[0.0, 128.0, 128.0]</td>\n</tr>\n<tr class="odd">\n<td>lime</td>\n<td>[0.0, 255.0, 0.0]</td>\n</tr>\n<tr class="even">\n<td>sienna</td>\n<td>[160.0, 82.0, 45.0]</td>\n</tr>\n<tr class="odd">\n<td>maroon</td>\n<td>[128.0, 0.0, 0.0]</td>\n</tr>\n<tr class="even">\n<td>navy</td>\n<td>[0.0, 0.0, 128.0]</td>\n</tr>\n<tr class="odd">\n<td>gray</td>\n<td>[128.0, 128.0, 128.0]</td>\n</tr>\n<tr class="even">\n<td>chartreuse</td>\n<td>[127.0, 255.0, 0.0]</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("starts_with", """
<h2 id="starts_with"><code>STARTS_WITH</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/starts_with.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="str"> String expression. If <code>null</code>, the function returns <code>null</code>. </definition> <definition term="prefix"> String expression. If <code>null</code>, the function returns <code>null</code>. </definition> </definitions></p>\n<p><strong>Description</strong> Returns a boolean that indicates whether a keyword string starts with another string. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>str</th>\n<th>prefix</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>keyword</td>\n<td>keyword</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>text</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>keyword</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>text</td>\n<td>boolean</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>FROM employees\n| KEEP last_name\n| EVAL ln_S = STARTS_WITH(last_name, &quot;B&quot;)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>last_name:keyword</th>\n<th>ln_S:boolean</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>Awdeh</td>\n<td>false</td>\n</tr>\n<tr class="even">\n<td>Azuma</td>\n<td>false</td>\n</tr>\n<tr class="odd">\n<td>Baek</td>\n<td>true</td>\n</tr>\n<tr class="even">\n<td>Bamford</td>\n<td>true</td>\n</tr>\n<tr class="odd">\n<td>Bernatsky</td>\n<td>true</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("to_integer", """
<h2 id="to_integer"><code>TO_INTEGER</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/to_integer.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> Input value. The input can be a single- or multi-valued column or an expression. </definition> </definitions></p>\n<p><strong>Description</strong> Converts an input value to an integer value. If the input parameter is of a date type, its value will be interpreted as milliseconds since the <a href="https://en.wikipedia.org/wiki/Unix_time">Unix epoch</a>, converted to integer. Boolean <code>true</code> will be converted to integer <code>1</code>, <code>false</code> to <code>0</code>. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>boolean</td>\n<td>integer</td>\n</tr>\n<tr class="even">\n<td>counter_integer</td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>date</td>\n<td>integer</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>integer</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>integer</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>unsigned_long</td>\n<td>integer</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW long = [5013792, 2147483647, 501379200000]\n| EVAL int = TO_INTEGER(long)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>long:long</th>\n<th>int:integer</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>[5013792, 2147483647, 501379200000]</td>\n<td>[5013792, 2147483647]</td>\n</tr>\n</tbody>\n</table>\n<p>Note that in this example, the last value of the multi-valued field cannot be converted as an integer. When this happens, the result is a <code>null</code> value. In this case a <em>Warning</em> header is added to the response. The header will provide information on the source of the failure: <code>"Line 1:61: evaluation of [TO_INTEGER(long)] failed, treating result as null. Only first 20 failures recorded."</code> A following header will contain the failure reason and the offending value: <code>"org.elasticsearch.xpack.esql.core.InvalidArgumentException: [501379200000] out of [integer] range"</code></p>
"""),                     Map.entry("delta", """
<h2 id="delta"><code>DELTA</code></h2>\n<pre><code>stack: preview 9.2.0\nserverless: preview</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/delta.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> </definition> </definitions></p>\n<p><strong>Description</strong> Calculates the absolute change of a gauge field in a time window. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>TS k8s\n| WHERE pod == &quot;one&quot;\n| STATS tx = SUM(DELTA(network.bytes_in)) BY cluster, time_bucket = TBUCKET(10minute)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>tx:double</th>\n<th>cluster:keyword</th>\n<th>time_bucket:datetime</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>-351.0</td>\n<td>prod</td>\n<td>2024-05-10T00:00:00.000Z</td>\n</tr>\n<tr class="even">\n<td>552.0</td>\n<td>qa</td>\n<td>2024-05-10T00:00:00.000Z</td>\n</tr>\n<tr class="odd">\n<td>127.0</td>\n<td>staging</td>\n<td>2024-05-10T00:00:00.000Z</td>\n</tr>\n<tr class="even">\n<td>280.0</td>\n<td>prod</td>\n<td>2024-05-10T00:10:00.000Z</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("atan", """
<h2 id="atan"><code>ATAN</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/atan.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="number"> Numeric expression. If <code>null</code>, the function returns <code>null</code>. </definition> </definitions></p>\n<p><strong>Description</strong> Returns the <a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions">arctangent</a> of the input numeric expression as an angle, expressed in radians. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>number</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW a=12.9\n| EVAL atan=ATAN(a)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:double</th>\n<th>atan:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>12.9</td>\n<td>1.4934316673669235</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("scalb", """
<h2 id="scalb"><code>SCALB</code></h2>\n<pre><code>stack: ga 9.1.0</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/scalb.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="d"> Numeric expression for the multiplier. If <code>null</code>, the function returns <code>null</code>. </definition> <definition term="scaleFactor"> Numeric expression for the scale factor. If <code>null</code>, the function returns <code>null</code>. </definition> </definitions></p>\n<p><strong>Description</strong> Returns the result of <code>d * 2 ^ scaleFactor</code>, Similar to Java’s <code>scalb</code> function. Result is rounded as if performed by a single correctly rounded floating-point multiply to a member of the double value set. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>d</th>\n<th>scaleFactor</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>unsigned_long</td>\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>long</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>row x = 3.0, y = 10 | eval z = scalb(x, y)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>x:double</th>\n<th>y:integer</th>\n<th>z:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>3.0</td>\n<td>10</td>\n<td>3072.0</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("asin", """
<h2 id="asin"><code>ASIN</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/asin.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="number"> Number between -1 and 1. If <code>null</code>, the function returns <code>null</code>. </definition> </definitions></p>\n<p><strong>Description</strong> Returns the <a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions">arcsine</a> of the input numeric expression as an angle, expressed in radians. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>number</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW a=.9\n| EVAL asin=ASIN(a)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:double</th>\n<th>asin:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>.9</td>\n<td>1.1197695149986342</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("to_datetime", """
<h2 id="to_datetime"><code>TO_DATETIME</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/to_datetime.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> Input value. The input can be a single- or multi-valued column or an expression. </definition> </definitions></p>\n<strong>Description</strong> Converts an input value to a date value. A string will only be successfully converted if it’s respecting the format <code>yyyy-MM-dd'T'HH:mm:ss.SSS'Z'</code>. To convert dates in other formats, use <a href="/docs/reference/query-languages/esql/functions-operators/date-time-functions#esql-date_parse"><code>DATE_PARSE</code></a>.\n<note>\nNote that when converting from nanosecond resolution to millisecond resolution with this function, the nanosecond date is truncated, not rounded.\n</note>\n<p><strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>date</td>\n<td>date</td>\n</tr>\n<tr class="even">\n<td>date_nanos</td>\n<td>date</td>\n</tr>\n<tr class="odd">\n<td>double</td>\n<td>date</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>date</td>\n</tr>\n<tr class="odd">\n<td>keyword</td>\n<td>date</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>date</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>date</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>date</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Examples</strong></p>\n<pre class="esql"><code>ROW string = [&quot;1953-09-02T00:00:00.000Z&quot;, &quot;1964-06-02T00:00:00.000Z&quot;, &quot;1964-06-02 00:00:00&quot;]\n| EVAL datetime = TO_DATETIME(string)</code></pre>\n<table>\n<colgroup>\n<col style="width: 60%" />\n<col style="width: 40%" />\n</colgroup>\n<thead>\n<tr class="header">\n<th>string:keyword</th>\n<th>datetime:date</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>[“1953-09-02T00:00:00.000Z”, “1964-06-02T00:00:00.000Z”, “1964-06-02 00:00:00”]</td>\n<td>[1953-09-02T00:00:00.000Z, 1964-06-02T00:00:00.000Z]</td>\n</tr>\n</tbody>\n</table>\n<p>Note that in this example, the last value in the source multi-valued field has not been converted. The reason being that if the date format is not respected, the conversion will result in a <code>null</code> value. When this happens a <em>Warning</em> header is added to the response. The header will provide information on the source of the failure: <code>"Line 1:112: evaluation of [TO_DATETIME(string)] failed, treating result as null. "Only first 20 failures recorded."</code> A following header will contain the failure reason and the offending value: <code>"java.lang.IllegalArgumentException: failed to parse date field [1964-06-02 00:00:00] with format [yyyy-MM-dd'T'HH:mm:ss.SSS'Z']"</code> If the input parameter is of a numeric type, its value will be interpreted as milliseconds since the <a href="https://en.wikipedia.org/wiki/Unix_time">Unix epoch</a>. For example:</p>\n<pre class="esql"><code>ROW int = [0, 1]\n| EVAL dt = TO_DATETIME(int)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>int:integer</th>\n<th>dt:date</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>[0, 1]</td>\n<td>[1970-01-01T00:00:00.000Z, 1970-01-01T00:00:00.001Z]</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("st_contains", """
<h2 id="st_contains"><code>ST_CONTAINS</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/st_contains.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="geomA"> Expression of type <code>geo_point</code>, <code>cartesian_point</code>, <code>geo_shape</code> or <code>cartesian_shape</code>. If <code>null</code>, the function returns <code>null</code>. </definition> <definition term="geomB"> Expression of type <code>geo_point</code>, <code>cartesian_point</code>, <code>geo_shape</code> or <code>cartesian_shape</code>. If <code>null</code>, the function returns <code>null</code>. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine <code>geo_*</code> and <code>cartesian_*</code> parameters. </definition> </definitions></p>\n<p><strong>Description</strong> Returns whether the first geometry contains the second geometry. This is the inverse of the <a href="#esql-st_within">ST_WITHIN</a> function. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>geomA</th>\n<th>geomB</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>cartesian_point</td>\n<td>cartesian_point</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>cartesian_point</td>\n<td>cartesian_shape</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>cartesian_shape</td>\n<td>cartesian_point</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>cartesian_shape</td>\n<td>cartesian_shape</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>geo_point</td>\n<td>geo_point</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>geo_point</td>\n<td>geo_shape</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>geo_shape</td>\n<td>geo_point</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>geo_shape</td>\n<td>geo_shape</td>\n<td>boolean</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>FROM airport_city_boundaries\n| WHERE ST_CONTAINS(city_boundary, TO_GEOSHAPE(&quot;POLYGON((109.35 18.3, 109.45 18.3, 109.45 18.4, 109.35 18.4, 109.35 18.3))&quot;))\n| KEEP abbrev, airport, region, city, city_location</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>abbrev:keyword</th>\n<th>airport:text</th>\n<th>region:text</th>\n<th>city:keyword</th>\n<th>city_location:geo_point</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>SYX</td>\n<td>Sanya Phoenix Int’l</td>\n<td>天涯区</td>\n<td>Sanya</td>\n<td>POINT(109.5036 18.2533)</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("sqrt", """
<h2 id="sqrt"><code>SQRT</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/sqrt.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="number"> Numeric expression. If <code>null</code>, the function returns <code>null</code>. </definition> </definitions></p>\n<p><strong>Description</strong> Returns the square root of a number. The input can be any numeric value, the return value is always a double. Square roots of negative numbers and infinities are null. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>number</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW d = 100.0\n| EVAL s = SQRT(d)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>d: double</th>\n<th>s:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>100.0</td>\n<td>10.0</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("bit_length", """
<h2 id="bit_length"><code>BIT_LENGTH</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/bit_length.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="string"> String expression. If <code>null</code>, the function returns <code>null</code>. </definition> </definitions></p>\n<strong>Description</strong> Returns the bit length of a string.\n<note>\nAll strings are in UTF-8, so a single character can use multiple bytes.\n</note>\n<p><strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>string</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>keyword</td>\n<td>integer</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>integer</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>FROM airports\n| WHERE country == &quot;India&quot;\n| KEEP city\n| EVAL fn_length = LENGTH(city), fn_bit_length = BIT_LENGTH(city)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>city:keyword</th>\n<th>fn_length:integer</th>\n<th>fn_bit_length:integer</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>Agwār</td>\n<td>5</td>\n<td>48</td>\n</tr>\n<tr class="even">\n<td>Ahmedabad</td>\n<td>9</td>\n<td>72</td>\n</tr>\n<tr class="odd">\n<td>Bangalore</td>\n<td>9</td>\n<td>72</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("abs", """
<h2 id="abs"><code>ABS</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/abs.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="number"> Numeric expression. If <code>null</code>, the function returns <code>null</code>. </definition> </definitions></p>\n<p><strong>Description</strong> Returns the absolute value. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>number</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>unsigned_long</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Examples</strong></p>\n<pre class="esql"><code>ROW number = -1.0\n| EVAL abs_number = ABS(number)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>number:double</th>\n<th>abs_number:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>-1.0</td>\n<td>1.0</td>\n</tr>\n</tbody>\n</table>\n<pre class="esql"><code>FROM employees\n| KEEP first_name, last_name, height\n| EVAL abs_height = ABS(0.0 - height)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>first_name:keyword</th>\n<th>last_name:keyword</th>\n<th>height:double</th>\n<th>abs_height:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>Alejandro</td>\n<td>McAlpine</td>\n<td>1.48</td>\n<td>1.48</td>\n</tr>\n<tr class="even">\n<td>Amabile</td>\n<td>Gomatam</td>\n<td>2.09</td>\n<td>2.09</td>\n</tr>\n<tr class="odd">\n<td>Anneke</td>\n<td>Preusig</td>\n<td>1.56</td>\n<td>1.56</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("hash", """
<h2 id="hash"><code>HASH</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/hash.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="algorithm"> Hash algorithm to use. </definition> <definition term="input"> Input to hash. </definition> </definitions></p>\n<p><strong>Description</strong> Computes the hash of the input using various algorithms such as MD5, SHA, SHA-224, SHA-256, SHA-384, SHA-512. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>algorithm</th>\n<th>input</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>keyword</td>\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>text</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>text</td>\n<td>keyword</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>FROM sample_data\n| WHERE message != &quot;Connection error&quot;\n| EVAL md5 = hash(&quot;md5&quot;, message), sha256 = hash(&quot;sha256&quot;, message)\n| KEEP message, md5, sha256</code></pre>\n<table>\n<colgroup>\n<col style="width: 18%" />\n<col style="width: 27%" />\n<col style="width: 53%" />\n</colgroup>\n<thead>\n<tr class="header">\n<th>message:keyword</th>\n<th>md5:keyword</th>\n<th>sha256:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>Connected to 10.1.0.1</td>\n<td>abd7d1ce2bb636842a29246b3512dcae</td>\n<td>6d8372129ad78770f7185554dd39864749a62690216460752d6c075fa38ad85c</td>\n</tr>\n<tr class="even">\n<td>Connected to 10.1.0.2</td>\n<td>8f8f1cb60832d153f5b9ec6dc828b93f</td>\n<td>b0db24720f15857091b3c99f4c4833586d0ea3229911b8777efb8d917cf27e9a</td>\n</tr>\n<tr class="odd">\n<td>Connected to 10.1.0.3</td>\n<td>912b6dc13503165a15de43304bb77c78</td>\n<td>75b0480188db8acc4d5cc666a51227eb2bc5b989cd8ca912609f33e0846eff57</td>\n</tr>\n<tr class="even">\n<td>Disconnected</td>\n<td>ef70e46fd3bbc21e3e1f0b6815e750c0</td>\n<td>04dfac3671b494ad53fcd152f7a14511bfb35747278aad8ce254a0d6e4ba4718</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("month_name", """
<h2 id="month_name"><code>MONTH_NAME</code></h2>\n<pre><code>stack: ga 9.2.0</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/month_name.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="date"> Date expression. If <code>null</code>, the function returns <code>null</code>. </definition> </definitions></p>\n<p><strong>Description</strong> Returns the month name for the provided date based on the configured Locale. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>date</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>date</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>date_nanos</td>\n<td>keyword</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW dt = to_datetime(&quot;1996-03-21T00:00:00.000Z&quot;)\n| EVAL monthName = MONTH_NAME(dt);</code></pre>
"""),                     Map.entry("exp", """
<h2 id="exp"><code>EXP</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/exp.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="number"> Numeric expression. If <code>null</code>, the function returns <code>null</code>. </definition> </definitions></p>\n<p><strong>Description</strong> Returns the value of e raised to the power of the given number. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>number</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW d = 5.0\n| EVAL s = EXP(d)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>d: double</th>\n<th>s:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>5.0</td>\n<td>148.413159102576603</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("case", """
<h2 id="case"><code>CASE</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/case.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="condition"> A condition. </definition> <definition term="trueValue"> The value that’s returned when the corresponding condition is the first to evaluate to <code>true</code>. The default value is returned when no condition matches. </definition> <definition term="elseValue"> The value that’s returned when no condition evaluates to <code>true</code>. </definition> </definitions></p>\n<p><strong>Description</strong> Accepts pairs of conditions and values. The function returns the value that belongs to the first condition that evaluates to <code>true</code>. If the number of arguments is odd, the last argument is the default value which is returned when no condition matches. If the number of arguments is even, and no condition matches, the function returns <code>null</code>. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>condition</th>\n<th>trueValue</th>\n<th>elseValue</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>boolean</td>\n<td>boolean</td>\n<td>boolean</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>boolean</td>\n<td>boolean</td>\n<td></td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>boolean</td>\n<td>cartesian_point</td>\n<td>cartesian_point</td>\n<td>cartesian_point</td>\n</tr>\n<tr class="even">\n<td>boolean</td>\n<td>cartesian_point</td>\n<td></td>\n<td>cartesian_point</td>\n</tr>\n<tr class="odd">\n<td>boolean</td>\n<td>cartesian_shape</td>\n<td>cartesian_shape</td>\n<td>cartesian_shape</td>\n</tr>\n<tr class="even">\n<td>boolean</td>\n<td>cartesian_shape</td>\n<td></td>\n<td>cartesian_shape</td>\n</tr>\n<tr class="odd">\n<td>boolean</td>\n<td>date</td>\n<td>date</td>\n<td>date</td>\n</tr>\n<tr class="even">\n<td>boolean</td>\n<td>date</td>\n<td></td>\n<td>date</td>\n</tr>\n<tr class="odd">\n<td>boolean</td>\n<td>date_nanos</td>\n<td>date_nanos</td>\n<td>date_nanos</td>\n</tr>\n<tr class="even">\n<td>boolean</td>\n<td>date_nanos</td>\n<td></td>\n<td>date_nanos</td>\n</tr>\n<tr class="odd">\n<td>boolean</td>\n<td>dense_vector</td>\n<td>dense_vector</td>\n<td>dense_vector</td>\n</tr>\n<tr class="even">\n<td>boolean</td>\n<td>dense_vector</td>\n<td></td>\n<td>dense_vector</td>\n</tr>\n<tr class="odd">\n<td>boolean</td>\n<td>double</td>\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>boolean</td>\n<td>double</td>\n<td></td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>boolean</td>\n<td>geo_point</td>\n<td>geo_point</td>\n<td>geo_point</td>\n</tr>\n<tr class="even">\n<td>boolean</td>\n<td>geo_point</td>\n<td></td>\n<td>geo_point</td>\n</tr>\n<tr class="odd">\n<td>boolean</td>\n<td>geo_shape</td>\n<td>geo_shape</td>\n<td>geo_shape</td>\n</tr>\n<tr class="even">\n<td>boolean</td>\n<td>geo_shape</td>\n<td></td>\n<td>geo_shape</td>\n</tr>\n<tr class="odd">\n<td>boolean</td>\n<td>geohash</td>\n<td>geohash</td>\n<td>geohash</td>\n</tr>\n<tr class="even">\n<td>boolean</td>\n<td>geohash</td>\n<td></td>\n<td>geohash</td>\n</tr>\n<tr class="odd">\n<td>boolean</td>\n<td>geohex</td>\n<td>geohex</td>\n<td>geohex</td>\n</tr>\n<tr class="even">\n<td>boolean</td>\n<td>geohex</td>\n<td></td>\n<td>geohex</td>\n</tr>\n<tr class="odd">\n<td>boolean</td>\n<td>geotile</td>\n<td>geotile</td>\n<td>geotile</td>\n</tr>\n<tr class="even">\n<td>boolean</td>\n<td>geotile</td>\n<td></td>\n<td>geotile</td>\n</tr>\n<tr class="odd">\n<td>boolean</td>\n<td>integer</td>\n<td>integer</td>\n<td>integer</td>\n</tr>\n<tr class="even">\n<td>boolean</td>\n<td>integer</td>\n<td></td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>boolean</td>\n<td>ip</td>\n<td>ip</td>\n<td>ip</td>\n</tr>\n<tr class="even">\n<td>boolean</td>\n<td>ip</td>\n<td></td>\n<td>ip</td>\n</tr>\n<tr class="odd">\n<td>boolean</td>\n<td>keyword</td>\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>boolean</td>\n<td>keyword</td>\n<td>text</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>boolean</td>\n<td>keyword</td>\n<td></td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>boolean</td>\n<td>long</td>\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>boolean</td>\n<td>long</td>\n<td></td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>boolean</td>\n<td>text</td>\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>boolean</td>\n<td>text</td>\n<td>text</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>boolean</td>\n<td>text</td>\n<td></td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>boolean</td>\n<td>unsigned_long</td>\n<td>unsigned_long</td>\n<td>unsigned_long</td>\n</tr>\n<tr class="even">\n<td>boolean</td>\n<td>unsigned_long</td>\n<td></td>\n<td>unsigned_long</td>\n</tr>\n<tr class="odd">\n<td>boolean</td>\n<td>version</td>\n<td>version</td>\n<td>version</td>\n</tr>\n<tr class="even">\n<td>boolean</td>\n<td>version</td>\n<td></td>\n<td>version</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Examples</strong> Determine whether employees are monolingual, bilingual, or polyglot:</p>\n<pre class="esql"><code>FROM employees\n| EVAL type = CASE(\n    languages &lt;= 1, &quot;monolingual&quot;,\n    languages &lt;= 2, &quot;bilingual&quot;,\n     &quot;polyglot&quot;)\n| KEEP emp_no, languages, type</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>emp_no:integer</th>\n<th>languages:integer</th>\n<th>type:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>10001</td>\n<td>2</td>\n<td>bilingual</td>\n</tr>\n<tr class="even">\n<td>10002</td>\n<td>5</td>\n<td>polyglot</td>\n</tr>\n<tr class="odd">\n<td>10003</td>\n<td>4</td>\n<td>polyglot</td>\n</tr>\n<tr class="even">\n<td>10004</td>\n<td>5</td>\n<td>polyglot</td>\n</tr>\n<tr class="odd">\n<td>10005</td>\n<td>1</td>\n<td>monolingual</td>\n</tr>\n</tbody>\n</table>\n<p>Calculate the total connection success rate based on log messages:</p>\n<pre class="esql"><code>FROM sample_data\n| EVAL successful = CASE(\n    STARTS_WITH(message, &quot;Connected to&quot;), 1,\n    message == &quot;Connection error&quot;, 0\n  )\n| STATS success_rate = AVG(successful)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>success_rate:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>0.5</td>\n</tr>\n</tbody>\n</table>\n<p>Calculate an hourly error rate as a percentage of the total number of log messages:</p>\n<pre class="esql"><code>FROM sample_data\n| EVAL error = CASE(message LIKE &quot;*error*&quot;, 1, 0)\n| EVAL hour = DATE_TRUNC(1 hour, @timestamp)\n| STATS error_rate = AVG(error) by hour\n| SORT hour</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>error_rate:double</th>\n<th>hour:date</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>0.0</td>\n<td>2023-10-23T12:00:00.000Z</td>\n</tr>\n<tr class="even">\n<td>0.6</td>\n<td>2023-10-23T13:00:00.000Z</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("last", """
<h2 id="last"><code>LAST</code></h2>\n<pre><code>stack: ga 9.2.0</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/last.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="value"> Values to return </definition> <definition term="sort"> Sort key </definition> </definitions></p>\n<p><strong>Description</strong> Calculates the latest value of a field. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>value</th>\n<th>sort</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n<td>date</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>date_nanos</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>date</td>\n<td>integer</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>date_nanos</td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>keyword</td>\n<td>date</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>date_nanos</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>date</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>date_nanos</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>date</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>date_nanos</td>\n<td>keyword</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>FROM k8s\n| STATS last_bytes_in = LAST(network.bytes_in, @timestamp) BY pod\n| SORT pod ASC</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>last_bytes_in:long</th>\n<th>pod:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>206</td>\n<td>one</td>\n</tr>\n<tr class="even">\n<td>972</td>\n<td>three</td>\n</tr>\n<tr class="odd">\n<td>812</td>\n<td>two</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("present", """
<h2 id="present"><code>PRESENT</code></h2>\n<pre><code>stack: ga 9.2.0</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/present.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> Expression that outputs values to be checked for presence. </definition> </definitions></p>\n<p><strong>Description</strong> Returns true if the input expression yields any non-null values within the current aggregation context. Otherwise it returns false. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>aggregate_metric_double</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>boolean</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>cartesian_point</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>cartesian_shape</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>date</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>date_nanos</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>double</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>geo_point</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>geo_shape</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>geohash</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>geohex</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>geotile</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>ip</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>keyword</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>version</td>\n<td>boolean</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Examples</strong></p>\n<pre class="esql"><code>FROM employees\n| STATS is_present = PRESENT(languages)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>is_present:boolean</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>true</td>\n</tr>\n</tbody>\n</table>\n<p>To check for the presence inside a group use <code>PRESENT()</code> and <code>BY</code> clauses</p>\n<pre class="esql"><code>FROM employees\n| STATS is_present = PRESENT(salary) BY languages</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>is_present:boolean</th>\n<th>languages:integer</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>true</td>\n<td>1</td>\n</tr>\n<tr class="even">\n<td>true</td>\n<td>2</td>\n</tr>\n<tr class="odd">\n<td>true</td>\n<td>3</td>\n</tr>\n<tr class="even">\n<td>true</td>\n<td>4</td>\n</tr>\n<tr class="odd">\n<td>true</td>\n<td>5</td>\n</tr>\n<tr class="even">\n<td>true</td>\n<td>null</td>\n</tr>\n</tbody>\n</table>\n<p>To check for the presence and return 1 when it’s true and 0 when it’s false</p>\n<pre class="esql"><code>FROM employees\n| WHERE emp_no == 10020\n| STATS is_present = TO_INTEGER(PRESENT(languages))</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>is_present:integer</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>0</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("weighted_avg", """
<h2 id="weighted_avg"><code>WEIGHTED_AVG</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/weighted_avg.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="number"> A numeric value. </definition> <definition term="weight"> A numeric weight. </definition> </definitions></p>\n<p><strong>Description</strong> The weighted average of a numeric expression. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>number</th>\n<th>weight</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>double</td>\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>long</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>FROM employees\n| STATS w_avg = WEIGHTED_AVG(salary, height) BY languages\n| EVAL w_avg = ROUND(w_avg)\n| KEEP w_avg, languages\n| SORT languages</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>w_avg:double</th>\n<th>languages:integer</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>51464.0</td>\n<td>1</td>\n</tr>\n<tr class="even">\n<td>48477.0</td>\n<td>2</td>\n</tr>\n<tr class="odd">\n<td>52379.0</td>\n<td>3</td>\n</tr>\n<tr class="even">\n<td>47990.0</td>\n<td>4</td>\n</tr>\n<tr class="odd">\n<td>42119.0</td>\n<td>5</td>\n</tr>\n<tr class="even">\n<td>52142.0</td>\n<td>null</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("now", """
<h2 id="now"><code>NOW</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/now.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <strong>Description</strong> Returns current date and time. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>date</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Examples</strong></p>\n<pre class="esql"><code>ROW current_date = NOW()</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>y:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>20</td>\n</tr>\n</tbody>\n</table>\n<p>To retrieve logs from the last hour:</p>\n<pre class="esql"><code>FROM sample_data\n| WHERE @timestamp &gt; NOW() - 1 hour</code></pre>
"""),                     Map.entry("grok", """
<h1 id="grok">GROK</h1>\n<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="fu">serverless</span><span class="kw">:</span><span class="at"> ga</span></span>\n<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="fu">stack</span><span class="kw">:</span><span class="at"> ga</span></span></code></pre></div>\n<p><code>GROK</code> enables you to <a href="https://www.elastic.co/docs/reference/query-languages/esql/esql-process-data-with-dissect-grok">extract structured data out of a string</a>. <strong>Syntax</strong></p>\n<pre class="esql"><code>GROK input &quot;pattern&quot;</code></pre>\n<p><strong>Parameters</strong> <definitions> <definition term="input"> The column that contains the string you want to structure. If the column has multiple values, <code>GROK</code> will process each value. </definition> <definition term="pattern"> A grok pattern. If a field name conflicts with an existing column, the existing column is discarded. If a field name is used more than once, a multi-valued column will be created with one value per each occurrence of the field name. </definition> </definitions></p>\n<p><strong>Description</strong> <code>GROK</code> enables you to <a href="https://www.elastic.co/docs/reference/query-languages/esql/esql-process-data-with-dissect-grok">extract structured data out of a string</a>. <code>GROK</code> matches the string against patterns, based on regular expressions, and extracts the specified patterns as columns. Refer to <a href="/docs/reference/query-languages/esql/esql-process-data-with-dissect-grok#esql-process-data-with-grok">Process data with <code>GROK</code></a> for the syntax of grok patterns. <strong>Examples</strong> The following example parses a string that contains a timestamp, an IP address, an email address, and a number:</p>\n<pre class="esql"><code>ROW a = &quot;2023-01-23T12:15:00.000Z 127.0.0.1 some.email@foo.com 42&quot;\n| GROK a &quot;&quot;&quot;%{TIMESTAMP_ISO8601:date} %{IP:ip} %{EMAILADDRESS:email} %{NUMBER:num}&quot;&quot;&quot;\n| KEEP date, ip, email, num</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>date:keyword</th>\n<th>ip:keyword</th>\n<th>email:keyword</th>\n<th>num:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>2023-01-23T12:15:00.000Z</td>\n<td>127.0.0.1</td>\n<td>some.email@foo.com</td>\n<td>42</td>\n</tr>\n</tbody>\n</table>\n<p>By default, <code>GROK</code> outputs keyword string columns. <code>int</code> and <code>float</code> types can be converted by appending <code>:type</code> to the semantics in the pattern. For example <code>{NUMBER:num:int}</code>:</p>\n<pre class="esql"><code>ROW a = &quot;2023-01-23T12:15:00.000Z 127.0.0.1 some.email@foo.com 42&quot;\n| GROK a &quot;&quot;&quot;%{TIMESTAMP_ISO8601:date} %{IP:ip} %{EMAILADDRESS:email} %{NUMBER:num:int}&quot;&quot;&quot;\n| KEEP date, ip, email, num</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>date:keyword</th>\n<th>ip:keyword</th>\n<th>email:keyword</th>\n<th>num:integer</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>2023-01-23T12:15:00.000Z</td>\n<td>127.0.0.1</td>\n<td>some.email@foo.com</td>\n<td>42</td>\n</tr>\n</tbody>\n</table>\n<p>For other type conversions, use <a href="https://www.elastic.co/docs/reference/query-languages/esql/functions-operators/type-conversion-functions">Type conversion functions</a>:</p>\n<pre class="esql"><code>ROW a = &quot;2023-01-23T12:15:00.000Z 127.0.0.1 some.email@foo.com 42&quot;\n| GROK a &quot;&quot;&quot;%{TIMESTAMP_ISO8601:date} %{IP:ip} %{EMAILADDRESS:email} %{NUMBER:num:int}&quot;&quot;&quot;\n| KEEP date, ip, email, num\n| EVAL date = TO_DATETIME(date)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>ip:keyword</th>\n<th>email:keyword</th>\n<th>num:integer</th>\n<th>date:date</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>127.0.0.1</td>\n<td>some.email@foo.com</td>\n<td>42</td>\n<td>2023-01-23T12:15:00.000Z</td>\n</tr>\n</tbody>\n</table>\n<p>If a field name is used more than once, <code>GROK</code> creates a multi-valued column:</p>\n<pre class="esql"><code>FROM addresses\n| KEEP city.name, zip_code\n| GROK zip_code &quot;&quot;&quot;%{WORD:zip_parts} %{WORD:zip_parts}&quot;&quot;&quot;</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>city.name:keyword</th>\n<th>zip_code:keyword</th>\n<th>zip_parts:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>Amsterdam</td>\n<td>1016 ED</td>\n<td>[“1016”, “ED”]</td>\n</tr>\n<tr class="even">\n<td>San Francisco</td>\n<td>CA 94108</td>\n<td>[“CA”, “94108”]</td>\n</tr>\n<tr class="odd">\n<td>Tokyo</td>\n<td>100-7014</td>\n<td>null</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("trange", """
<h2 id="trange"><code>TRANGE</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/trange.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="start_time_or_offset"> Offset from NOW for the single parameter mode. Start time for two parameter mode. In two parameter mode, the start time value can be a date string, date, date_nanos or epoch milliseconds. </definition> <definition term="end_time"> Explicit end time that can be a date string, date, date_nanos or epoch milliseconds. </definition> </definitions></p>\n<p><strong>Description</strong> Filters data for the given time range using the <span class="citation" data-cites="timestamp">@timestamp</span> attribute. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>start_time_or_offset</th>\n<th>end_time</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>date</td>\n<td>date</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>date_nanos</td>\n<td>date_nanos</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>date_period</td>\n<td></td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>keyword</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>long</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>time_duration</td>\n<td></td>\n<td>boolean</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Examples</strong></p>\n<pre class="esql"><code>FROM k8s\n| WHERE TRANGE(1h)\n| KEEP @timestamp</code></pre>\n<pre class="esql"><code>FROM k8s\n| WHERE TRANGE(&quot;2024-05-10T00:17:14.000Z&quot;, &quot;2024-05-10T00:18:33.000Z&quot;)\n| SORT @timestamp\n| KEEP @timestamp\n| LIMIT 10</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th><span class="citation" data-cites="timestamp:datetime">@timestamp:datetime</span></th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>2024-05-10T00:17:16.000Z</td>\n</tr>\n<tr class="even">\n<td>2024-05-10T00:17:20.000Z</td>\n</tr>\n<tr class="odd">\n<td>2024-05-10T00:17:30.000Z</td>\n</tr>\n<tr class="even">\n<td>2024-05-10T00:17:30.000Z</td>\n</tr>\n<tr class="odd">\n<td>2024-05-10T00:17:39.000Z</td>\n</tr>\n<tr class="even">\n<td>2024-05-10T00:17:39.000Z</td>\n</tr>\n<tr class="odd">\n<td>2024-05-10T00:17:55.000Z</td>\n</tr>\n<tr class="even">\n<td>2024-05-10T00:18:02.000Z</td>\n</tr>\n<tr class="odd">\n<td>2024-05-10T00:18:02.000Z</td>\n</tr>\n<tr class="even">\n<td>2024-05-10T00:18:02.000Z</td>\n</tr>\n</tbody>\n</table>\n<pre class="esql"><code>FROM k8s\n| WHERE TRANGE(to_datetime(&quot;2024-05-10T00:17:14Z&quot;), to_datetime(&quot;2024-05-10T00:18:33Z&quot;))\n| SORT @timestamp\n| KEEP @timestamp\n| LIMIT 10</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th><span class="citation" data-cites="timestamp:datetime">@timestamp:datetime</span></th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>2024-05-10T00:17:16.000Z</td>\n</tr>\n<tr class="even">\n<td>2024-05-10T00:17:20.000Z</td>\n</tr>\n<tr class="odd">\n<td>2024-05-10T00:17:30.000Z</td>\n</tr>\n<tr class="even">\n<td>2024-05-10T00:17:30.000Z</td>\n</tr>\n<tr class="odd">\n<td>2024-05-10T00:17:39.000Z</td>\n</tr>\n<tr class="even">\n<td>2024-05-10T00:17:39.000Z</td>\n</tr>\n<tr class="odd">\n<td>2024-05-10T00:17:55.000Z</td>\n</tr>\n<tr class="even">\n<td>2024-05-10T00:18:02.000Z</td>\n</tr>\n<tr class="odd">\n<td>2024-05-10T00:18:02.000Z</td>\n</tr>\n<tr class="even">\n<td>2024-05-10T00:18:02.000Z</td>\n</tr>\n</tbody>\n</table>\n<pre class="esql"><code>FROM k8s\n| WHERE TRANGE(to_datetime(&quot;2024-05-10T00:17:14.000Z&quot;), to_datetime(&quot;2024-05-10T00:18:33.000Z&quot;))\n| SORT @timestamp\n| KEEP @timestamp\n| LIMIT 10</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th><span class="citation" data-cites="timestamp:datetime">@timestamp:datetime</span></th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>2024-05-10T00:17:16.000Z</td>\n</tr>\n<tr class="even">\n<td>2024-05-10T00:17:20.000Z</td>\n</tr>\n<tr class="odd">\n<td>2024-05-10T00:17:30.000Z</td>\n</tr>\n<tr class="even">\n<td>2024-05-10T00:17:30.000Z</td>\n</tr>\n<tr class="odd">\n<td>2024-05-10T00:17:39.000Z</td>\n</tr>\n<tr class="even">\n<td>2024-05-10T00:17:39.000Z</td>\n</tr>\n<tr class="odd">\n<td>2024-05-10T00:17:55.000Z</td>\n</tr>\n<tr class="even">\n<td>2024-05-10T00:18:02.000Z</td>\n</tr>\n<tr class="odd">\n<td>2024-05-10T00:18:02.000Z</td>\n</tr>\n<tr class="even">\n<td>2024-05-10T00:18:02.000Z</td>\n</tr>\n</tbody>\n</table>\n<pre class="esql"><code>FROM k8s\n| WHERE TRANGE(1715300236000, 1715300282000)\n| SORT @timestamp\n| KEEP @timestamp\n| LIMIT 10</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th><span class="citation" data-cites="timestamp:datetime">@timestamp:datetime</span></th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>2024-05-10T00:17:20.000Z</td>\n</tr>\n<tr class="even">\n<td>2024-05-10T00:17:30.000Z</td>\n</tr>\n<tr class="odd">\n<td>2024-05-10T00:17:30.000Z</td>\n</tr>\n<tr class="even">\n<td>2024-05-10T00:17:39.000Z</td>\n</tr>\n<tr class="odd">\n<td>2024-05-10T00:17:39.000Z</td>\n</tr>\n<tr class="even">\n<td>2024-05-10T00:17:55.000Z</td>\n</tr>\n<tr class="odd">\n<td>2024-05-10T00:18:02.000Z</td>\n</tr>\n<tr class="even">\n<td>2024-05-10T00:18:02.000Z</td>\n</tr>\n<tr class="odd">\n<td>2024-05-10T00:18:02.000Z</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("st_distance", """
<h2 id="st_distance"><code>ST_DISTANCE</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/st_distance.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="geomA"> Expression of type <code>geo_point</code> or <code>cartesian_point</code>. If <code>null</code>, the function returns <code>null</code>. </definition> <definition term="geomB"> Expression of type <code>geo_point</code> or <code>cartesian_point</code>. If <code>null</code>, the function returns <code>null</code>. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine <code>geo_point</code> and <code>cartesian_point</code> parameters. </definition> </definitions></p>\n<p><strong>Description</strong> Computes the distance between two points. For cartesian geometries, this is the pythagorean distance in the same units as the original coordinates. For geographic geometries, this is the circular distance along the great circle in meters. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>geomA</th>\n<th>geomB</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>cartesian_point</td>\n<td>cartesian_point</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>geo_point</td>\n<td>geo_point</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>FROM airports\n| WHERE abbrev == &quot;CPH&quot;\n| EVAL distance = ST_DISTANCE(location, city_location)\n| KEEP abbrev, name, location, city_location, distance</code></pre>\n<table>\n<colgroup>\n<col style="width: 9%" />\n<col style="width: 11%" />\n<col style="width: 38%" />\n<col style="width: 23%" />\n<col style="width: 17%" />\n</colgroup>\n<thead>\n<tr class="header">\n<th>abbrev:k</th>\n<th>name:text</th>\n<th>location:geo_point</th>\n<th>city_location:geo_point</th>\n<th>distance:d</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>CPH</td>\n<td>Copenhagen</td>\n<td>POINT(12.6493508684508 55.6285017221528)</td>\n<td>POINT(12.5683 55.6761)</td>\n<td>7339.573896618216</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("st_intersects", """
<h2 id="st_intersects"><code>ST_INTERSECTS</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/st_intersects.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="geomA"> Expression that is either a geometry (<code>geo_point</code>, <code>cartesian_point</code>, <code>geo_shape</code> or <code>cartesian_shape</code>) or a geo-grid value (<code>geohash</code>, <code>geotile</code>, <code>geohex</code>). If <code>null</code>, the function returns <code>null</code>. </definition> <definition term="geomB"> Expression that is either a geometry (<code>geo_point</code>, <code>cartesian_point</code>, <code>geo_shape</code> or <code>cartesian_shape</code>) or a geo-grid value (<code>geohash</code>, <code>geotile</code>, <code>geohex</code>). If <code>null</code>, the function returns <code>null</code>. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine <code>geo_*</code> and <code>cartesian_*</code> parameters. </definition> </definitions></p>\n<p><strong>Description</strong> Returns true if two geometries intersect. They intersect if they have any point in common, including their interior points (points along lines or within polygons). This is the inverse of the <a href="#esql-st_disjoint">ST_DISJOINT</a> function. In mathematical terms: ST_Intersects(A, B) ⇔ A ⋂ B ≠ ∅ <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>geomA</th>\n<th>geomB</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>cartesian_point</td>\n<td>cartesian_point</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>cartesian_point</td>\n<td>cartesian_shape</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>cartesian_shape</td>\n<td>cartesian_point</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>cartesian_shape</td>\n<td>cartesian_shape</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>geo_point</td>\n<td>geo_point</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>geo_point</td>\n<td>geo_shape</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>geo_point</td>\n<td>geohash</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>geo_point</td>\n<td>geohex</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>geo_point</td>\n<td>geotile</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>geo_shape</td>\n<td>geo_point</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>geo_shape</td>\n<td>geo_shape</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>geohash</td>\n<td>geo_point</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>geohex</td>\n<td>geo_point</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>geotile</td>\n<td>geo_point</td>\n<td>boolean</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>FROM airports\n| WHERE ST_INTERSECTS(location, TO_GEOSHAPE(&quot;POLYGON((42 14, 43 14, 43 15, 42 15, 42 14))&quot;))</code></pre>\n<table>\n<colgroup>\n<col style="width: 10%" />\n<col style="width: 9%" />\n<col style="width: 16%" />\n<col style="width: 11%" />\n<col style="width: 26%" />\n<col style="width: 10%" />\n<col style="width: 8%" />\n<col style="width: 5%" />\n</colgroup>\n<thead>\n<tr class="header">\n<th>abbrev:keyword</th>\n<th>city:keyword</th>\n<th>city_location:geo_point</th>\n<th>country:keyword</th>\n<th>location:geo_point</th>\n<th>name:text</th>\n<th>scalerank:i</th>\n<th>type:k</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>HOD</td>\n<td>Al Ḩudaydah</td>\n<td>POINT(42.9511 14.8022)</td>\n<td>Yemen</td>\n<td>POINT(42.97109630194 14.7552534413725)</td>\n<td>Hodeidah Int’l</td>\n<td>9</td>\n<td>mid</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("repeat", """
<h2 id="repeat"><code>REPEAT</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/repeat.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="string"> String expression. </definition> <definition term="number"> Number times to repeat. </definition> </definitions></p>\n<p><strong>Description</strong> Returns a string constructed by concatenating <code>string</code> with itself the specified <code>number</code> of times. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>string</th>\n<th>number</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>keyword</td>\n<td>integer</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>integer</td>\n<td>keyword</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW a = &quot;Hello!&quot;\n| EVAL triple_a = REPEAT(a, 3)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:keyword</th>\n<th>triple_a:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>Hello!</td>\n<td>Hello!Hello!Hello!</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("atan2", """
<h2 id="atan2"><code>ATAN2</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/atan2.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="y_coordinate"> y coordinate. If <code>null</code>, the function returns <code>null</code>. </definition> <definition term="x_coordinate"> x coordinate. If <code>null</code>, the function returns <code>null</code>. </definition> </definitions></p>\n<p><strong>Description</strong> The <a href="https://en.wikipedia.org/wiki/Atan2">angle</a> between the positive x-axis and the ray from the origin to the point (x , y) in the Cartesian plane, expressed in radians. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>y_coordinate</th>\n<th>x_coordinate</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>double</td>\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>unsigned_long</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>unsigned_long</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>unsigned_long</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>unsigned_long</td>\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>unsigned_long</td>\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>unsigned_long</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW y=12.9, x=.6\n| EVAL atan2=ATAN2(y, x)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>y:double</th>\n<th>x:double</th>\n<th>atan2:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>12.9</td>\n<td>0.6</td>\n<td>1.5243181954438936</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("st_disjoint", """
<h2 id="st_disjoint"><code>ST_DISJOINT</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/st_disjoint.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="geomA"> Expression that is either a geometry (<code>geo_point</code>, <code>cartesian_point</code>, <code>geo_shape</code> or <code>cartesian_shape</code>) or a geo-grid value (<code>geohash</code>, <code>geotile</code>, <code>geohex</code>). If <code>null</code>, the function returns <code>null</code>. </definition> <definition term="geomB"> Expression that is either a geometry (<code>geo_point</code>, <code>cartesian_point</code>, <code>geo_shape</code> or <code>cartesian_shape</code>) or a geo-grid value (<code>geohash</code>, <code>geotile</code>, <code>geohex</code>). If <code>null</code>, the function returns <code>null</code>. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine <code>geo_*</code> and <code>cartesian_*</code> parameters. </definition> </definitions></p>\n<p><strong>Description</strong> Returns whether the two geometries or geometry columns are disjoint. This is the inverse of the <a href="#esql-st_intersects">ST_INTERSECTS</a> function. In mathematical terms: ST_Disjoint(A, B) ⇔ A ⋂ B = ∅ <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>geomA</th>\n<th>geomB</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>cartesian_point</td>\n<td>cartesian_point</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>cartesian_point</td>\n<td>cartesian_shape</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>cartesian_shape</td>\n<td>cartesian_point</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>cartesian_shape</td>\n<td>cartesian_shape</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>geo_point</td>\n<td>geo_point</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>geo_point</td>\n<td>geo_shape</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>geo_point</td>\n<td>geohash</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>geo_point</td>\n<td>geohex</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>geo_point</td>\n<td>geotile</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>geo_shape</td>\n<td>geo_point</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>geo_shape</td>\n<td>geo_shape</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>geohash</td>\n<td>geo_point</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>geohex</td>\n<td>geo_point</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>geotile</td>\n<td>geo_point</td>\n<td>boolean</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>FROM airport_city_boundaries\n| WHERE ST_DISJOINT(city_boundary, TO_GEOSHAPE(&quot;POLYGON((-10 -60, 120 -60, 120 60, -10 60, -10 -60))&quot;))\n| KEEP abbrev, airport, region, city, city_location</code></pre>\n<table>\n<colgroup>\n<col style="width: 14%" />\n<col style="width: 26%" />\n<col style="width: 17%" />\n<col style="width: 17%" />\n<col style="width: 23%" />\n</colgroup>\n<thead>\n<tr class="header">\n<th>abbrev:keyword</th>\n<th>airport:text</th>\n<th>region:text</th>\n<th>city:keyword</th>\n<th>city_location:geo_point</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>ACA</td>\n<td>General Juan N Alvarez Int’l</td>\n<td>Acapulco de Juárez</td>\n<td>Acapulco de Juárez</td>\n<td>POINT (-99.8825 16.8636)</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("mv_concat", """
<h2 id="mv_concat"><code>MV_CONCAT</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/mv_concat.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="string"> Multivalue expression. </definition> <definition term="delim"> Delimiter. </definition> </definitions></p>\n<p><strong>Description</strong> Converts a multivalued string expression into a single valued column containing the concatenation of all values separated by a delimiter. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>string</th>\n<th>delim</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>keyword</td>\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>text</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>text</td>\n<td>keyword</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Examples</strong></p>\n<pre class="esql"><code>ROW a=[&quot;foo&quot;, &quot;zoo&quot;, &quot;bar&quot;]\n| EVAL j = MV_CONCAT(a, &quot;, &quot;)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:keyword</th>\n<th>j:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>[“foo”, “zoo”, “bar”]</td>\n<td>“foo, zoo, bar”</td>\n</tr>\n</tbody>\n</table>\n<p>To concat non-string columns, call <a href="/docs/reference/query-languages/esql/functions-operators/type-conversion-functions#esql-to_string"><code>TO_STRING</code></a> first:</p>\n<pre class="esql"><code>ROW a=[10, 9, 8]\n| EVAL j = MV_CONCAT(TO_STRING(a), &quot;, &quot;)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:integer</th>\n<th>j:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>[10, 9, 8]</td>\n<td>“10, 9, 8”</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("date_format", """
<h2 id="date_format"><code>DATE_FORMAT</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/date_format.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="dateFormat"> Date format (optional). If no format is specified, the <code>yyyy-MM-dd'T'HH:mm:ss.SSSZ</code> format is used. If <code>null</code>, the function returns <code>null</code>. </definition> <definition term="date"> Date expression. If <code>null</code>, the function returns <code>null</code>. </definition> </definitions></p>\n<p><strong>Description</strong> Returns a string representation of a date, in the provided format. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>dateFormat</th>\n<th>date</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>date</td>\n<td></td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>date_nanos</td>\n<td></td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>keyword</td>\n<td>date</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>date_nanos</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>date</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>date_nanos</td>\n<td>keyword</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>FROM employees\n| KEEP first_name, last_name, hire_date\n| EVAL hired = DATE_FORMAT(&quot;yyyy-MM-dd&quot;, hire_date)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>first_name:keyword</th>\n<th>last_name:keyword</th>\n<th>hire_date:date</th>\n<th>hired:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>Alejandro</td>\n<td>McAlpine</td>\n<td>1991-06-26T00:00:00.000Z</td>\n<td>1991-06-26</td>\n</tr>\n<tr class="even">\n<td>Amabile</td>\n<td>Gomatam</td>\n<td>1992-11-18T00:00:00.000Z</td>\n<td>1992-11-18</td>\n</tr>\n<tr class="odd">\n<td>Anneke</td>\n<td>Preusig</td>\n<td>1989-06-02T00:00:00.000Z</td>\n<td>1989-06-02</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("mv_expand", """
<h1 id="mv_expand">MV_EXPAND</h1>\n<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="fu">serverless</span><span class="kw">:</span><span class="at"> preview</span></span>\n<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="fu">stack</span><span class="kw">:</span><span class="at"> preview</span></span></code></pre></div>\n<p>The <code>MV_EXPAND</code> processing command expands multivalued columns into one row per value, duplicating other columns. <strong>Syntax</strong></p>\n<pre class="esql"><code>MV_EXPAND column</code></pre>\n<p><strong>Parameters</strong> <definitions> <definition term="column"> The multivalued column to expand. </definition> </definitions></p>\n<warning>\nThe output rows produced by <code>MV_EXPAND</code> can be in any order and may not respect preceding <code>SORT</code>s. To guarantee a certain ordering, place a <code>SORT</code> after any <code>MV_EXPAND</code>s.\n</warning>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW a=[1,2,3], b=&quot;b&quot;, j=[&quot;a&quot;,&quot;b&quot;]\n| MV_EXPAND a</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:integer</th>\n<th>b:keyword</th>\n<th>j:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>1</td>\n<td>b</td>\n<td>[“a”, “b”]</td>\n</tr>\n<tr class="even">\n<td>2</td>\n<td>b</td>\n<td>[“a”, “b”]</td>\n</tr>\n<tr class="odd">\n<td>3</td>\n<td>b</td>\n<td>[“a”, “b”]</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("count_over_time", """
<h2 id="count_over_time"><code>COUNT_OVER_TIME</code></h2>\n<pre><code>stack: preview 9.2.0\nserverless: preview</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/count_over_time.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> </definition> </definitions></p>\n<p><strong>Description</strong> Calculates the count over time value of a field. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>aggregate_metric_double</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>boolean</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>cartesian_point</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>cartesian_shape</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>date</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>date_nanos</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>double</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>geo_point</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>geo_shape</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>geohash</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>geohex</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>geotile</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>ip</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>keyword</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>version</td>\n<td>long</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>TS k8s\n| STATS count=COUNT(COUNT_OVER_TIME(network.cost))\n  BY cluster, time_bucket = BUCKET(@timestamp,1minute)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>count:long</th>\n<th>cluster:keyword</th>\n<th>time_bucket:datetime</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>3</td>\n<td>staging</td>\n<td>2024-05-10T00:22:00.000Z</td>\n</tr>\n<tr class="even">\n<td>3</td>\n<td>prod</td>\n<td>2024-05-10T00:20:00.000Z</td>\n</tr>\n<tr class="odd">\n<td>3</td>\n<td>prod</td>\n<td>2024-05-10T00:19:00.000Z</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("drop", """
<h1 id="drop">DROP</h1>\n<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="fu">serverless</span><span class="kw">:</span><span class="at"> ga</span></span>\n<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="fu">stack</span><span class="kw">:</span><span class="at"> ga</span></span></code></pre></div>\n<p>The <code>DROP</code> processing command removes one or more columns. <strong>Syntax</strong></p>\n<pre class="esql"><code>DROP columns</code></pre>\n<p><strong>Parameters</strong> <definitions> <definition term="columns"> A comma-separated list of columns to remove. Supports wildcards. </definition> </definitions></p>\n<p><strong>Examples</strong></p>\n<pre class="esql"><code>FROM employees\n| DROP height</code></pre>\n<p>Rather than specify each column by name, you can use wildcards to drop all columns with a name that matches a pattern:</p>\n<pre class="esql"><code>FROM employees\n| DROP height*</code></pre>
"""),                     Map.entry("max_over_time", """
<h2 id="max_over_time"><code>MAX_OVER_TIME</code></h2>\n<pre><code>stack: preview 9.2.0\nserverless: preview</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/max_over_time.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> </definition> </definitions></p>\n<p><strong>Description</strong> Calculates the maximum over time value of a field. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>aggregate_metric_double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>boolean</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>date</td>\n<td>date</td>\n</tr>\n<tr class="even">\n<td>date_nanos</td>\n<td>date_nanos</td>\n</tr>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>ip</td>\n<td>ip</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>unsigned_long <code>stack: ga 9.2.0</code></td>\n<td>unsigned_long</td>\n</tr>\n<tr class="even">\n<td>version</td>\n<td>version</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>TS k8s\n| STATS cost=SUM(MAX_OVER_TIME(network.cost)) BY cluster, time_bucket = TBUCKET(1minute)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>cost:double</th>\n<th>cluster:keyword</th>\n<th>time_bucket:datetime</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>32.75</td>\n<td>qa</td>\n<td>2024-05-10T00:17:00.000Z</td>\n</tr>\n<tr class="even">\n<td>32.25</td>\n<td>staging</td>\n<td>2024-05-10T00:09:00.000Z</td>\n</tr>\n<tr class="odd">\n<td>31.75</td>\n<td>qa</td>\n<td>2024-05-10T00:06:00.000Z</td>\n</tr>\n<tr class="even">\n<td>29.0</td>\n<td>prod</td>\n<td>2024-05-10T00:19:00.000Z</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("contains", """
<h2 id="contains"><code>CONTAINS</code></h2>\n<pre><code>stack: ga 9.2.0</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/contains.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="string"> String expression: input string to check against. If <code>null</code>, the function returns <code>null</code>. </definition> <definition term="substring"> String expression: A substring to find in the input string. If <code>null</code>, the function returns <code>null</code>. </definition> </definitions></p>\n<p><strong>Description</strong> Returns a boolean that indicates whether a keyword substring is within another string. Returns <code>null</code> if either parameter is null. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>string</th>\n<th>substring</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>keyword</td>\n<td>keyword</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>text</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>keyword</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>text</td>\n<td>boolean</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW a = &quot;hello&quot;\n| EVAL has_ll = CONTAINS(a, &quot;ll&quot;)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:keyword</th>\n<th>has_ll:boolean</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>hello</td>\n<td>true</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("text_embedding", """
<h2 id="text_embedding"><code>TEXT_EMBEDDING</code></h2>\n<pre><code>stack: preview 9.3\nserverless: preview</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/text_embedding.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="text"> Text string to generate embeddings from. Must be a non-null literal string value. </definition> <definition term="inference_id"> Identifier of an existing inference endpoint the that will generate the embeddings. The inference endpoint must have the <code>text_embedding</code> task type and should use the same model that was used to embed your indexed data. </definition> </definitions></p>\n<p><strong>Description</strong> Generates dense vector embeddings from text input using a specified <a href="https://www.elastic.co/docs/explore-analyze/elastic-inference/inference-api">inference endpoint</a>. Use this function to generate query vectors for KNN searches against your vectorized data or others dense vector based operations. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>text</th>\n<th>inference_id</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>keyword</td>\n<td>keyword</td>\n<td>dense_vector</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Examples</strong> Basic text embedding generation from a text string using an inference endpoint.</p>\n<pre class="esql"><code>ROW input=&quot;Who is Victor Hugo?&quot;\n| EVAL embedding = TEXT_EMBEDDING(&quot;Who is Victor Hugo?&quot;, &quot;test_dense_inference&quot;)</code></pre>\n<p>Generate text embeddings and store them in a variable for reuse in KNN vector search queries.</p>\n<pre class="esql"><code>FROM semantic_text METADATA _score\n| EVAL query_embedding = TEXT_EMBEDDING(&quot;be excellent to each other&quot;, &quot;test_dense_inference&quot;)\n| WHERE KNN(semantic_text_dense_field, query_embedding)</code></pre>\n<p>Directly embed text within a KNN query for streamlined vector search without intermediate variables.</p>\n<pre class="esql"><code>FROM semantic_text METADATA _score\n| WHERE KNN(semantic_text_dense_field, TEXT_EMBEDDING(&quot;be excellent to each other&quot;, &quot;test_dense_inference&quot;))</code></pre>
"""),                     Map.entry("sha1", """
<h2 id="sha1"><code>SHA1</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/sha1.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="input"> Input to hash. </definition> </definitions></p>\n<p><strong>Description</strong> Computes the SHA1 hash of the input. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>input</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>keyword</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>FROM sample_data\n| WHERE message != &quot;Connection error&quot;\n| EVAL sha1 = sha1(message)\n| KEEP message, sha1</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>message:keyword</th>\n<th>sha1:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>Connected to 10.1.0.1</td>\n<td>42b85531a79088036a17759db7d2de292b92f57f</td>\n</tr>\n<tr class="even">\n<td>Connected to 10.1.0.2</td>\n<td>d30db445da2e9237c9718d0c7e4fb7cbbe9c2cb4</td>\n</tr>\n<tr class="odd">\n<td>Connected to 10.1.0.3</td>\n<td>2733848d943809f0b10cad3e980763e88afb9853</td>\n</tr>\n<tr class="even">\n<td>Disconnected</td>\n<td>771e05f27b99fd59f638f41a7a4e977b1d4691fe</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("sum_over_time", """
<h2 id="sum_over_time"><code>SUM_OVER_TIME</code></h2>\n<pre><code>stack: preview 9.2.0\nserverless: preview</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/sum_over_time.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> </definition> </definitions></p>\n<p><strong>Description</strong> Calculates the sum over time value of a field. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>aggregate_metric_double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>long</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>TS k8s\n| STATS sum_cost=SUM(SUM_OVER_TIME(network.cost)) BY cluster, time_bucket = TBUCKET(1minute)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>sum_cost:double</th>\n<th>cluster:keyword</th>\n<th>time_bucket:datetime</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>67.625</td>\n<td>qa</td>\n<td>2024-05-10T00:17:00.000Z</td>\n</tr>\n<tr class="even">\n<td>65.75</td>\n<td>staging</td>\n<td>2024-05-10T00:09:00.000Z</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("mv_max", """
<h2 id="mv_max"><code>MV_MAX</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/mv_max.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> Multivalue expression. </definition> </definitions></p>\n<p><strong>Description</strong> Converts a multivalued expression into a single valued column containing the maximum value. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>boolean</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>date</td>\n<td>date</td>\n</tr>\n<tr class="odd">\n<td>date_nanos</td>\n<td>date_nanos</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>integer</td>\n</tr>\n<tr class="even">\n<td>ip</td>\n<td>ip</td>\n</tr>\n<tr class="odd">\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>unsigned_long</td>\n</tr>\n<tr class="odd">\n<td>version</td>\n<td>version</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Examples</strong></p>\n<pre class="esql"><code>ROW a=[3, 5, 1]\n| EVAL max_a = MV_MAX(a)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:integer</th>\n<th>max_a:integer</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>[3, 5, 1]</td>\n<td>5</td>\n</tr>\n</tbody>\n</table>\n<p>It can be used by any column type, including <code>keyword</code> columns. In that case it picks the last string, comparing their utf-8 representation byte by byte:</p>\n<pre class="esql"><code>ROW a=[&quot;foo&quot;, &quot;zoo&quot;, &quot;bar&quot;]\n| EVAL max_a = MV_MAX(a)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:keyword</th>\n<th>max_a:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>[“foo”, “zoo”, “bar”]</td>\n<td>“zoo”</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("count", """
<h2 id="count"><code>COUNT</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/count.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> Expression that outputs values to be counted. If omitted, equivalent to <code>COUNT(*)</code> (the number of rows). </definition> </definitions></p>\n<p><strong>Description</strong> Returns the total number (count) of input values. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>aggregate_metric_double</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>boolean</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>cartesian_point</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>cartesian_shape</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>date</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>date_nanos</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>double</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>geo_point</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>geo_shape</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>geohash</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>geohex</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>geotile</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>ip</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>keyword</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>version</td>\n<td>long</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Examples</strong></p>\n<pre class="esql"><code>FROM employees\n| STATS COUNT(height)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>COUNT(height):long</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>100</td>\n</tr>\n</tbody>\n</table>\n<p>To count the number of rows, use <code>COUNT()</code> or <code>COUNT(*)</code></p>\n<pre class="esql"><code>FROM employees\n| STATS count = COUNT(*) BY languages\n| SORT languages DESC</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>count:long</th>\n<th>languages:integer</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>10</td>\n<td>null</td>\n</tr>\n<tr class="even">\n<td>21</td>\n<td>5</td>\n</tr>\n<tr class="odd">\n<td>18</td>\n<td>4</td>\n</tr>\n<tr class="even">\n<td>17</td>\n<td>3</td>\n</tr>\n<tr class="odd">\n<td>19</td>\n<td>2</td>\n</tr>\n<tr class="even">\n<td>15</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<p>The expression can use inline functions. This example splits a string into multiple values using the <code>SPLIT</code> function and counts the values</p>\n<pre class="esql"><code>ROW words=&quot;foo;bar;baz;qux;quux;foo&quot;\n| STATS word_count = COUNT(SPLIT(words, &quot;;&quot;))</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>word_count:long</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>6</td>\n</tr>\n</tbody>\n</table>\n<p>To count the number of times an expression returns <code>TRUE</code> use a <a href="https://www.elastic.co/docs/reference/query-languages/esql/commands/where"><code>WHERE</code></a> command to remove rows that shouldn’t be included</p>\n<pre class="esql"><code>ROW n=1\n| WHERE n &lt; 0\n| STATS COUNT(n)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>COUNT(n):long</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>0</td>\n</tr>\n</tbody>\n</table>\n<p>To count the same stream of data based on two different expressions use the pattern <code>COUNT(&lt;expression&gt; OR NULL)</code>. This builds on the three-valued logic (<a href="https://en.wikipedia.org/wiki/Three-valued_logic">3VL</a>) of the language: <code>TRUE OR NULL</code> is <code>TRUE</code>, but <code>FALSE OR NULL</code> is <code>NULL</code>, plus the way COUNT handles <code>NULL</code>s: <code>COUNT(TRUE)</code> and <code>COUNT(FALSE)</code> are both 1, but <code>COUNT(NULL)</code> is 0.</p>\n<pre class="esql"><code>ROW n=1\n| STATS COUNT(n &gt; 0 OR NULL), COUNT(n &lt; 0 OR NULL)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>COUNT(n &gt; 0 OR NULL):long</th>\n<th>COUNT(n &lt; 0 OR NULL):long</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>1</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("st_envelope", """
<h2 id="st_envelope"><code>ST_ENVELOPE</code></h2>\n<pre><code>stack: preview\nserverless: preview</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/st_envelope.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="geometry"> Expression of type <code>geo_point</code>, <code>geo_shape</code>, <code>cartesian_point</code> or <code>cartesian_shape</code>. If <code>null</code>, the function returns <code>null</code>. </definition> </definitions></p>\n<p><strong>Description</strong> Determines the minimum bounding box of the supplied geometry. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>geometry</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>cartesian_point</td>\n<td>cartesian_shape</td>\n</tr>\n<tr class="even">\n<td>cartesian_shape</td>\n<td>cartesian_shape</td>\n</tr>\n<tr class="odd">\n<td>geo_point</td>\n<td>geo_shape</td>\n</tr>\n<tr class="even">\n<td>geo_shape</td>\n<td>geo_shape</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>FROM airport_city_boundaries\n| WHERE abbrev == &quot;CPH&quot;\n| EVAL envelope = ST_ENVELOPE(city_boundary)\n| KEEP abbrev, airport, envelope</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>abbrev:keyword</th>\n<th>airport:text</th>\n<th>envelope:geo_shape</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>CPH</td>\n<td>Copenhagen</td>\n<td>BBOX(12.453, 12.6398, 55.7327, 55.6318)</td>\n</tr>\n</tbody>\n</table>\n<h3 id="st_xmax"><code>ST_XMAX</code></h3>\n<pre><code>stack: preview\nserverless: preview</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/st_xmax.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="point"> Expression of type <code>geo_point</code>, <code>geo_shape</code>, <code>cartesian_point</code> or <code>cartesian_shape</code>. If <code>null</code>, the function returns <code>null</code>. </definition> </definitions></p>\n<p><strong>Description</strong> Extracts the maximum value of the <code>x</code> coordinates from the supplied geometry. If the geometry is of type <code>geo_point</code> or <code>geo_shape</code> this is equivalent to extracting the maximum <code>longitude</code> value. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>point</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>cartesian_point</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>cartesian_shape</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>geo_point</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>geo_shape</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>FROM airport_city_boundaries\n| WHERE abbrev == &quot;CPH&quot;\n| EVAL envelope = ST_ENVELOPE(city_boundary)\n| EVAL xmin = ST_XMIN(envelope), xmax = ST_XMAX(envelope), ymin = ST_YMIN(envelope), ymax = ST_YMAX(envelope)\n| KEEP abbrev, airport, xmin, xmax, ymin, ymax</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>abbrev:keyword</th>\n<th>airport:text</th>\n<th>xmin:double</th>\n<th>xmax:double</th>\n<th>ymin:double</th>\n<th>ymax:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>CPH</td>\n<td>Copenhagen</td>\n<td>12.453</td>\n<td>12.6398</td>\n<td>55.6318</td>\n<td>55.7327</td>\n</tr>\n</tbody>\n</table>\n<h3 id="st_xmin"><code>ST_XMIN</code></h3>\n<pre><code>stack: preview\nserverless: preview</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/st_xmin.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="point"> Expression of type <code>geo_point</code>, <code>geo_shape</code>, <code>cartesian_point</code> or <code>cartesian_shape</code>. If <code>null</code>, the function returns <code>null</code>. </definition> </definitions></p>\n<p><strong>Description</strong> Extracts the minimum value of the <code>x</code> coordinates from the supplied geometry. If the geometry is of type <code>geo_point</code> or <code>geo_shape</code> this is equivalent to extracting the minimum <code>longitude</code> value. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>point</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>cartesian_point</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>cartesian_shape</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>geo_point</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>geo_shape</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>FROM airport_city_boundaries\n| WHERE abbrev == &quot;CPH&quot;\n| EVAL envelope = ST_ENVELOPE(city_boundary)\n| EVAL xmin = ST_XMIN(envelope), xmax = ST_XMAX(envelope), ymin = ST_YMIN(envelope), ymax = ST_YMAX(envelope)\n| KEEP abbrev, airport, xmin, xmax, ymin, ymax</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>abbrev:keyword</th>\n<th>airport:text</th>\n<th>xmin:double</th>\n<th>xmax:double</th>\n<th>ymin:double</th>\n<th>ymax:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>CPH</td>\n<td>Copenhagen</td>\n<td>12.453</td>\n<td>12.6398</td>\n<td>55.6318</td>\n<td>55.7327</td>\n</tr>\n</tbody>\n</table>\n<h3 id="st_ymax"><code>ST_YMAX</code></h3>\n<pre><code>stack: preview\nserverless: preview</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/st_ymax.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="point"> Expression of type <code>geo_point</code>, <code>geo_shape</code>, <code>cartesian_point</code> or <code>cartesian_shape</code>. If <code>null</code>, the function returns <code>null</code>. </definition> </definitions></p>\n<p><strong>Description</strong> Extracts the maximum value of the <code>y</code> coordinates from the supplied geometry. If the geometry is of type <code>geo_point</code> or <code>geo_shape</code> this is equivalent to extracting the maximum <code>latitude</code> value. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>point</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>cartesian_point</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>cartesian_shape</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>geo_point</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>geo_shape</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>FROM airport_city_boundaries\n| WHERE abbrev == &quot;CPH&quot;\n| EVAL envelope = ST_ENVELOPE(city_boundary)\n| EVAL xmin = ST_XMIN(envelope), xmax = ST_XMAX(envelope), ymin = ST_YMIN(envelope), ymax = ST_YMAX(envelope)\n| KEEP abbrev, airport, xmin, xmax, ymin, ymax</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>abbrev:keyword</th>\n<th>airport:text</th>\n<th>xmin:double</th>\n<th>xmax:double</th>\n<th>ymin:double</th>\n<th>ymax:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>CPH</td>\n<td>Copenhagen</td>\n<td>12.453</td>\n<td>12.6398</td>\n<td>55.6318</td>\n<td>55.7327</td>\n</tr>\n</tbody>\n</table>\n<h3 id="st_ymin"><code>ST_YMIN</code></h3>\n<pre><code>stack: preview\nserverless: preview</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/st_ymin.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="point"> Expression of type <code>geo_point</code>, <code>geo_shape</code>, <code>cartesian_point</code> or <code>cartesian_shape</code>. If <code>null</code>, the function returns <code>null</code>. </definition> </definitions></p>\n<p><strong>Description</strong> Extracts the minimum value of the <code>y</code> coordinates from the supplied geometry. If the geometry is of type <code>geo_point</code> or <code>geo_shape</code> this is equivalent to extracting the minimum <code>latitude</code> value. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>point</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>cartesian_point</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>cartesian_shape</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>geo_point</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>geo_shape</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>FROM airport_city_boundaries\n| WHERE abbrev == &quot;CPH&quot;\n| EVAL envelope = ST_ENVELOPE(city_boundary)\n| EVAL xmin = ST_XMIN(envelope), xmax = ST_XMAX(envelope), ymin = ST_YMIN(envelope), ymax = ST_YMAX(envelope)\n| KEEP abbrev, airport, xmin, xmax, ymin, ymax</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>abbrev:keyword</th>\n<th>airport:text</th>\n<th>xmin:double</th>\n<th>xmax:double</th>\n<th>ymin:double</th>\n<th>ymax:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>CPH</td>\n<td>Copenhagen</td>\n<td>12.453</td>\n<td>12.6398</td>\n<td>55.6318</td>\n<td>55.7327</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("to_long", """
<h2 id="to_long"><code>TO_LONG</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/to_long.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> Input value. The input can be a single- or multi-valued column or an expression. </definition> </definitions></p>\n<p><strong>Description</strong> Converts an input value to a long value. If the input parameter is of a date type, its value will be interpreted as milliseconds since the <a href="https://en.wikipedia.org/wiki/Unix_time">Unix epoch</a>, converted to long. Boolean <code>true</code> will be converted to long <code>1</code>, <code>false</code> to <code>0</code>. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>boolean</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>counter_integer</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>counter_long</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>date</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>date_nanos</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>geohash</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>geohex</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>geotile</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>keyword</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>long</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW str1 = &quot;2147483648&quot;, str2 = &quot;2147483648.2&quot;, str3 = &quot;foo&quot;\n| EVAL long1 = TO_LONG(str1), long2 = TO_LONG(str2), long3 = TO_LONG(str3)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>str1:keyword</th>\n<th>str2:keyword</th>\n<th>str3:keyword</th>\n<th>long1:long</th>\n<th>long2:long</th>\n<th>long3:long</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>2147483648</td>\n<td>2147483648.2</td>\n<td>foo</td>\n<td>2147483648</td>\n<td>2147483648</td>\n<td>null</td>\n</tr>\n</tbody>\n</table>\n<p>Note that in this example, the last conversion of the string isn’t possible. When this happens, the result is a <code>null</code> value. In this case a <em>Warning</em> header is added to the response. The header will provide information on the source of the failure: <code>"Line 1:113: evaluation of [TO_LONG(str3)] failed, treating result as null. Only first 20 failures recorded."</code> A following header will contain the failure reason and the offending value: <code>"java.lang.NumberFormatException: For input string: "foo""</code></p>
"""),                     Map.entry("absent_over_time", """
<h2 id="absent_over_time"><code>ABSENT_OVER_TIME</code></h2>\n<pre><code>stack: preview 9.2.0\nserverless: preview</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/absent_over_time.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> </definition> </definitions></p>\n<p><strong>Description</strong> Calculates the absence of a field in the output result over time range. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>aggregate_metric_double</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>boolean</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>cartesian_point</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>cartesian_shape</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>date</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>date_nanos</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>double</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>geo_point</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>geo_shape</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>geohash</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>geohex</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>geotile</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>ip</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>keyword</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>version</td>\n<td>boolean</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>TS k8s\n| WHERE cluster == &quot;prod&quot; AND pod == &quot;two&quot;\n| STATS events_received = MAX(ABSENT_OVER_TIME(events_received)) BY pod, time_bucket = TBUCKET(2 minute)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>events_received:boolean</th>\n<th>pod:keyword</th>\n<th>time_bucket:datetime</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>false</td>\n<td>two</td>\n<td>2024-05-10T00:02:00.000Z</td>\n</tr>\n<tr class="even">\n<td>false</td>\n<td>two</td>\n<td>2024-05-10T00:08:00.000Z</td>\n</tr>\n<tr class="odd">\n<td>true</td>\n<td>two</td>\n<td>2024-05-10T00:10:00.000Z</td>\n</tr>\n<tr class="even">\n<td>true</td>\n<td>two</td>\n<td>2024-05-10T00:12:00.000Z</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("sort", """
<h1 id="sort">SORT</h1>\n<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="fu">serverless</span><span class="kw">:</span><span class="at"> ga</span></span>\n<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="fu">stack</span><span class="kw">:</span><span class="at"> ga</span></span></code></pre></div>\n<p>The <code>SORT</code> processing command sorts a table on one or more columns. <strong>Syntax</strong></p>\n<pre class="esql"><code>SORT column1 [ASC/DESC][NULLS FIRST/NULLS LAST][, ..., columnN [ASC/DESC][NULLS FIRST/NULLS LAST]]</code></pre>\n<p><strong>Parameters</strong> <definitions> <definition term="columnX"> The column to sort on. </definition> </definitions></p>\n<p><strong>Description</strong> The <code>SORT</code> processing command sorts a table on one or more columns. The default sort order is ascending. Use <code>ASC</code> or <code>DESC</code> to specify an explicit sort order. Two rows with the same sort key are considered equal. You can provide additional sort expressions to act as tie breakers. Sorting on multivalued columns uses the lowest value when sorting ascending and the highest value when sorting descending. By default, <code>null</code> values are treated as being larger than any other value. With an ascending sort order, <code>null</code> values are sorted last, and with a descending sort order, <code>null</code> values are sorted first. You can change that by providing <code>NULLS FIRST</code> or <code>NULLS LAST</code>. <strong>Examples</strong></p>\n<pre class="esql"><code>FROM employees\n| KEEP first_name, last_name, height\n| SORT height</code></pre>\n<p>Explicitly sorting in ascending order with <code>ASC</code>:</p>\n<pre class="esql"><code>FROM employees\n| KEEP first_name, last_name, height\n| SORT height DESC</code></pre>\n<p>Providing additional sort expressions to act as tie breakers:</p>\n<pre class="esql"><code>FROM employees\n| KEEP first_name, last_name, height\n| SORT height DESC, first_name ASC</code></pre>\n<p>Sorting <code>null</code> values first using <code>NULLS FIRST</code>:</p>\n<pre class="esql"><code>FROM employees\n| KEEP first_name, last_name, height\n| SORT first_name ASC NULLS FIRST</code></pre>
"""),                     Map.entry("round_to", """
<h2 id="round_to"><code>ROUND_TO</code></h2>\n<pre><code>stack: preview 9.1.0</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/round_to.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> The numeric value to round. If <code>null</code>, the function returns <code>null</code>. </definition> <definition term="points"> Remaining rounding points. Must be constants. </definition> </definitions></p>\n<p><strong>Description</strong> Rounds down to one of a list of fixed points. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>points</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>date</td>\n<td>date</td>\n<td>date</td>\n</tr>\n<tr class="even">\n<td>date_nanos</td>\n<td>date_nanos</td>\n<td>date_nanos</td>\n</tr>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>double</td>\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>integer</td>\n<td>integer</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>integer</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>long</td>\n<td>long</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>FROM employees\n| STATS COUNT(*) BY birth_window=ROUND_TO(\n    birth_date,\n    &quot;1900-01-01T00:00:00Z&quot;::DATETIME,\n    &quot;1950-01-01T00:00:00Z&quot;::DATETIME,\n    &quot;1955-01-01T00:00:00Z&quot;::DATETIME,\n    &quot;1960-01-01T00:00:00Z&quot;::DATETIME,\n    &quot;1965-01-01T00:00:00Z&quot;::DATETIME,\n    &quot;1970-01-01T00:00:00Z&quot;::DATETIME,\n    &quot;1975-01-01T00:00:00Z&quot;::DATETIME\n)\n| SORT birth_window ASC</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>COUNT(*):long</th>\n<th>birth_window:datetime</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>27</td>\n<td>1950-01-01T00:00:00Z</td>\n</tr>\n<tr class="even">\n<td>29</td>\n<td>1955-01-01T00:00:00Z</td>\n</tr>\n<tr class="odd">\n<td>33</td>\n<td>1960-01-01T00:00:00Z</td>\n</tr>\n<tr class="even">\n<td>1</td>\n<td>1965-01-01T00:00:00Z</td>\n</tr>\n<tr class="odd">\n<td>10</td>\n<td>null</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("sinh", """
<h2 id="sinh"><code>SINH</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/sinh.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="number"> Numeric expression. If <code>null</code>, the function returns <code>null</code>. </definition> </definitions></p>\n<p><strong>Description</strong> Returns the <a href="https://en.wikipedia.org/wiki/Hyperbolic_functions">hyperbolic sine</a> of a number. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>number</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW a=1.8\n| EVAL sinh=SINH(a)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:double</th>\n<th>sinh:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>1.8</td>\n<td>2.94217428809568</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("show", """
<h1 id="show">SHOW</h1>\n<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="fu">serverless</span><span class="kw">:</span><span class="at"> ga</span></span>\n<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="fu">stack</span><span class="kw">:</span><span class="at"> ga</span></span></code></pre></div>\n<p>The <code>SHOW</code> source command returns information about the deployment and its capabilities. <strong>Syntax</strong></p>\n<pre class="esql"><code>SHOW item</code></pre>\n<p><strong>Parameters</strong> <definitions> <definition term="item"> Can only be <code>INFO</code>. </definition> </definitions></p>\n<p><strong>Examples</strong> Use <code>SHOW INFO</code> to return the deployment’s version, build date and hash.</p>\n<pre class="esql"><code>SHOW INFO</code></pre>\n<table>\n<colgroup>\n<col style="width: 10%" />\n<col style="width: 38%" />\n<col style="width: 50%" />\n</colgroup>\n<thead>\n<tr class="header">\n<th>version</th>\n<th>date</th>\n<th>hash</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>8.13.0</td>\n<td>2024-02-23T10:04:18.123117961Z</td>\n<td>04ba8c8db2507501c88f215e475de7b0798cb3b3</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("row", """
<h1 id="row">ROW</h1>\n<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="fu">serverless</span><span class="kw">:</span><span class="at"> ga</span></span>\n<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="fu">stack</span><span class="kw">:</span><span class="at"> ga</span></span></code></pre></div>\n<p>The <code>ROW</code> source command produces a row with one or more columns with values that you specify. This can be useful for testing. <strong>Syntax</strong></p>\n<pre class="esql"><code>ROW column1 = value1[, ..., columnN = valueN]</code></pre>\n<p><strong>Parameters</strong> <definitions> <definition term="columnX"> The column name. In case of duplicate column names, only the rightmost duplicate creates a column. </definition> <definition term="valueX"> The value for the column. Can be a literal, an expression, or a <a href="/docs/reference/query-languages/esql/esql-functions-operators#esql-functions">function</a>. </definition> </definitions></p>\n<p><strong>Examples</strong></p>\n<pre class="esql"><code>ROW a = 1, b = &quot;two&quot;, c = null</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:integer</th>\n<th>b:keyword</th>\n<th>c:null</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>1</td>\n<td>“two”</td>\n<td>null</td>\n</tr>\n</tbody>\n</table>\n<p>Use square brackets to create multi-value columns:</p>\n<pre class="esql"><code>ROW a = [2, 1]</code></pre>\n<p><code>ROW</code> supports the use of <a href="/docs/reference/query-languages/esql/esql-functions-operators#esql-functions">functions</a>:</p>\n<pre class="esql"><code>ROW a = ROUND(1.23, 0)</code></pre>
"""),                     Map.entry("st_x", """
<h2 id="st_x"><code>ST_X</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/st_x.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="point"> Expression of type <code>geo_point</code> or <code>cartesian_point</code>. If <code>null</code>, the function returns <code>null</code>. </definition> </definitions></p>\n<p><strong>Description</strong> Extracts the <code>x</code> coordinate from the supplied point. If the points is of type <code>geo_point</code> this is equivalent to extracting the <code>longitude</code> value. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>point</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>cartesian_point</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>geo_point</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW point = TO_GEOPOINT(&quot;POINT(42.97109629958868 14.7552534006536)&quot;)\n| EVAL x =  ST_X(point), y = ST_Y(point)</code></pre>\n<table style="width:100%;">\n<colgroup>\n<col style="width: 53%" />\n<col style="width: 23%" />\n<col style="width: 22%" />\n</colgroup>\n<thead>\n<tr class="header">\n<th>point:geo_point</th>\n<th>x:double</th>\n<th>y:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>POINT(42.97109629958868 14.7552534006536)</td>\n<td>42.97109629958868</td>\n<td>14.7552534006536</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("mv_dedupe", """
<h2 id="mv_dedupe"><code>MV_DEDUPE</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/mv_dedupe.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> Multivalue expression. </definition> </definitions></p>\n<strong>Description</strong> Remove duplicate values from a multivalued field.\n<note>\n<code>MV_DEDUPE</code> may, but won’t always, sort the values in the column.\n</note>\n<p><strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>boolean</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>cartesian_point</td>\n<td>cartesian_point</td>\n</tr>\n<tr class="odd">\n<td>cartesian_shape</td>\n<td>cartesian_shape</td>\n</tr>\n<tr class="even">\n<td>date</td>\n<td>date</td>\n</tr>\n<tr class="odd">\n<td>date_nanos</td>\n<td>date_nanos</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>geo_point</td>\n<td>geo_point</td>\n</tr>\n<tr class="even">\n<td>geo_shape</td>\n<td>geo_shape</td>\n</tr>\n<tr class="odd">\n<td>geohash</td>\n<td>geohash</td>\n</tr>\n<tr class="even">\n<td>geohex</td>\n<td>geohex</td>\n</tr>\n<tr class="odd">\n<td>geotile</td>\n<td>geotile</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>ip</td>\n<td>ip</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>unsigned_long</td>\n<td>unsigned_long</td>\n</tr>\n<tr class="even">\n<td>version</td>\n<td>version</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW a=[&quot;foo&quot;, &quot;foo&quot;, &quot;bar&quot;, &quot;foo&quot;]\n| EVAL dedupe_a = MV_DEDUPE(a)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:keyword</th>\n<th>dedupe_a:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>[“foo”, “foo”, “bar”, “foo”]</td>\n<td>[“foo”, “bar”]</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("qstr", """
<h2 id="qstr"><code>QSTR</code></h2>\n<pre><code>stack: preview 9.0.0, ga 9.1.0</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/qstr.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="query"> Query string in Lucene query string format. </definition> <definition term="options"> (Optional) Additional options for Query String as <a href="/docs/reference/query-languages/esql/esql-syntax#esql-function-named-params">function named parameters</a>. See <a href="https://www.elastic.co/docs/reference/query-languages/query-dsl/query-dsl-query-string-query">query string query</a> for more information. </definition> </definitions></p>\n<p><strong>Description</strong> Performs a <a href="https://www.elastic.co/docs/reference/query-languages/query-dsl/query-dsl-query-string-query">query string query</a>. Returns true if the provided query string matches the row. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>query</th>\n<th>options</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>keyword</td>\n<td>named parameters</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>named parameters</td>\n<td>boolean</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Supported function named parameters</strong> <definitions> <definition term="max_determinized_states"> (integer) Maximum number of automaton states required for the query. Default is 10000. </definition> <definition term="fuzziness"> (keyword) Maximum edit distance allowed for matching. </definition> <definition term="auto_generate_synonyms_phrase_query"> (boolean) If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true. </definition> <definition term="phrase_slop"> (integer) Maximum number of positions allowed between matching tokens for phrases. Defaults to 0 (which means exact matches are required). </definition> <definition term="default_field"> (keyword) Default field to search if no field is provided in the query string. Supports wildcards (<em>). </definition> <definition term="allow_leading_wildcard"> (boolean) If true, the wildcard characters </em> and ? are allowed as the first character of the query string. Defaults to true. </definition> <definition term="minimum_should_match"> (string) Minimum number of clauses that must match for a document to be returned. </definition> <definition term="fuzzy_transpositions"> (boolean) If true, edits for fuzzy matching include transpositions of two adjacent characters (ab → ba). Defaults to true. </definition> <definition term="fuzzy_prefix_length"> (integer) Number of beginning characters left unchanged for fuzzy matching. Defaults to 0. </definition> <definition term="time_zone"> (keyword) Coordinated Universal Time (UTC) offset or IANA time zone used to convert date values in the query string to UTC. </definition> <definition term="lenient"> (boolean) If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to false. </definition> <definition term="rewrite"> (keyword) Method used to rewrite the query. </definition> <definition term="default_operator"> (keyword) Default boolean logic used to interpret text in the query string if no operators are specified. </definition> <definition term="analyzer"> (keyword) Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the default_field. </definition> <definition term="fuzzy_max_expansions"> (integer) Maximum number of terms to which the query expands for fuzzy matching. Defaults to 50. </definition> <definition term="quote_analyzer"> (keyword) Analyzer used to convert quoted text in the query string into tokens. Defaults to the search_quote_analyzer mapped for the default_field. </definition> <definition term="allow_wildcard"> (boolean) If true, the query attempts to analyze wildcard terms in the query string. Defaults to false. </definition> <definition term="boost"> (float) Floating point number used to decrease or increase the relevance scores of the query. </definition> <definition term="quote_field_suffix"> (keyword) Suffix appended to quoted text in the query string. </definition> <definition term="enable_position_increments"> (boolean) If true, enable position increments in queries constructed from a query_string search. Defaults to true. </definition> <definition term="fields"> (keyword) Array of fields to search. Supports wildcards (*). </definition> </definitions></p>\n<p><strong>Examples</strong></p>\n<pre class="esql"><code>FROM books\n| WHERE QSTR(&quot;author: Faulkner&quot;)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>book_no:keyword</th>\n<th>author:text</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>2378</td>\n<td>[Carol Faulkner, Holly Byers Ochoa, Lucretia Mott]</td>\n</tr>\n<tr class="even">\n<td>2713</td>\n<td>William Faulkner</td>\n</tr>\n<tr class="odd">\n<td>2847</td>\n<td>Colleen Faulkner</td>\n</tr>\n<tr class="even">\n<td>2883</td>\n<td>William Faulkner</td>\n</tr>\n<tr class="odd">\n<td>3293</td>\n<td>Danny Faulkner</td>\n</tr>\n</tbody>\n</table>\n<pre><code>stack: ga 9.1.0</code></pre>\n<pre class="esql"><code>FROM books\n| WHERE QSTR(&quot;title: Hobbjt~&quot;, {&quot;fuzziness&quot;: 2})</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>book_no:keyword</th>\n<th>title:text</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>4289</td>\n<td>Poems from the Hobbit</td>\n</tr>\n<tr class="even">\n<td>6405</td>\n<td>The Hobbit or There and Back Again</td>\n</tr>\n<tr class="odd">\n<td>7480</td>\n<td>The Hobbit</td>\n</tr>\n</tbody>\n</table>\n<p>lists/search-functions.md lists/search-functions.md</p>
"""),                     Map.entry("to_unsigned_long", """
<h2 id="to_unsigned_long"><code>TO_UNSIGNED_LONG</code></h2>\n<pre><code>stack: preview\nserverless: preview</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/to_unsigned_long.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> Input value. The input can be a single- or multi-valued column or an expression. </definition> </definitions></p>\n<p><strong>Description</strong> Converts an input value to an unsigned long value. If the input parameter is of a date type, its value will be interpreted as milliseconds since the <a href="https://en.wikipedia.org/wiki/Unix_time">Unix epoch</a>, converted to unsigned long. Boolean <code>true</code> will be converted to unsigned long <code>1</code>, <code>false</code> to <code>0</code>. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>boolean</td>\n<td>unsigned_long</td>\n</tr>\n<tr class="even">\n<td>date</td>\n<td>unsigned_long</td>\n</tr>\n<tr class="odd">\n<td>double</td>\n<td>unsigned_long</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>unsigned_long</td>\n</tr>\n<tr class="odd">\n<td>keyword</td>\n<td>unsigned_long</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>unsigned_long</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>unsigned_long</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>unsigned_long</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW str1 = &quot;2147483648&quot;, str2 = &quot;2147483648.2&quot;, str3 = &quot;foo&quot;\n| EVAL long1 = TO_UNSIGNED_LONG(str1), long2 = TO_ULONG(str2), long3 = TO_UL(str3)</code></pre>\n<table>\n<colgroup>\n<col style="width: 13%" />\n<col style="width: 13%" />\n<col style="width: 13%" />\n<col style="width: 20%" />\n<col style="width: 20%" />\n<col style="width: 20%" />\n</colgroup>\n<thead>\n<tr class="header">\n<th>str1:keyword</th>\n<th>str2:keyword</th>\n<th>str3:keyword</th>\n<th>long1:unsigned_long</th>\n<th>long2:unsigned_long</th>\n<th>long3:unsigned_long</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>2147483648</td>\n<td>2147483648.2</td>\n<td>foo</td>\n<td>2147483648</td>\n<td>2147483648</td>\n<td>null</td>\n</tr>\n</tbody>\n</table>\n<p>Note that in this example, the last conversion of the string isn’t possible. When this happens, the result is a <code>null</code> value. In this case a <em>Warning</em> header is added to the response. The header will provide information on the source of the failure: <code>"Line 1:133: evaluation of [TO_UL(str3)] failed, treating result as null. Only first 20 failures recorded."</code> A following header will contain the failure reason and the offending value: <code>"java.lang.NumberFormatException: Character f is neither a decimal digit number, decimal point, - "nor "e" notation exponential mark."</code></p>
"""),                     Map.entry("split", """
<h2 id="split"><code>SPLIT</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/split.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="string"> String expression. If <code>null</code>, the function returns <code>null</code>. </definition> <definition term="delim"> Delimiter. Only single byte delimiters are currently supported. </definition> </definitions></p>\n<p><strong>Description</strong> Split a single valued string into multiple strings. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>string</th>\n<th>delim</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>keyword</td>\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>text</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>text</td>\n<td>keyword</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW words=&quot;foo;bar;baz;qux;quux;corge&quot;\n| EVAL word = SPLIT(words, &quot;;&quot;)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>words:keyword</th>\n<th>word:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>foo;bar;baz;qux;quux;corge</td>\n<td>[foo,bar,baz,qux,quux,corge]</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("match", """
<h2 id="match"><code>MATCH</code></h2>\n<pre><code>stack: preview 9.0.0, ga 9.1.0</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/match.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> Field that the query will target. </definition> <definition term="query"> Value to find in the provided field. </definition> <definition term="options"> (Optional) Match additional options as <a href="/docs/reference/query-languages/esql/esql-syntax#esql-function-named-params">function named parameters</a>. </definition> </definitions></p>\n<p><strong>Description</strong> Use <code>MATCH</code> to perform a <a href="https://www.elastic.co/docs/reference/query-languages/query-dsl/query-dsl-match-query">match query</a> on the specified field. Using <code>MATCH</code> is equivalent to using the <code>match</code> query in the Elasticsearch Query DSL. Match can be used on fields from the text family like <a href="https://www.elastic.co/docs/reference/elasticsearch/mapping-reference/text">text</a> and <a href="https://www.elastic.co/docs/reference/elasticsearch/mapping-reference/semantic-text">semantic_text</a>, as well as other field types like keyword, boolean, dates, and numeric types. When Match is used on a <a href="https://www.elastic.co/docs/reference/elasticsearch/mapping-reference/semantic-text">semantic_text</a> field, it will perform a semantic query on the field. Match can use <a href="/docs/reference/query-languages/esql/esql-syntax#esql-function-named-params">function named parameters</a> to specify additional options for the match query. All <a href="/docs/reference/query-languages/query-dsl/query-dsl-match-query#match-field-params">match query parameters</a> are supported. For a simplified syntax, you can use the <a href="/docs/reference/query-languages/esql/functions-operators/operators#esql-match-operator">match operator</a> <code>:</code> operator instead of <code>MATCH</code>. <code>MATCH</code> returns true if the provided query matches the row. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>query</th>\n<th>options</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>boolean</td>\n<td>boolean</td>\n<td>named parameters</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>boolean</td>\n<td>keyword</td>\n<td>named parameters</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>date</td>\n<td>date</td>\n<td>named parameters</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>date</td>\n<td>keyword</td>\n<td>named parameters</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>date_nanos</td>\n<td>date_nanos</td>\n<td>named parameters</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>date_nanos</td>\n<td>keyword</td>\n<td>named parameters</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n<td>named parameters</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>integer</td>\n<td>named parameters</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>double</td>\n<td>keyword</td>\n<td>named parameters</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>long</td>\n<td>named parameters</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>double</td>\n<td>named parameters</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>integer</td>\n<td>named parameters</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>keyword</td>\n<td>named parameters</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>long</td>\n<td>named parameters</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>ip</td>\n<td>ip</td>\n<td>named parameters</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>ip</td>\n<td>keyword</td>\n<td>named parameters</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>keyword</td>\n<td>keyword</td>\n<td>named parameters</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>double</td>\n<td>named parameters</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>integer</td>\n<td>named parameters</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>keyword</td>\n<td>named parameters</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>long</td>\n<td>named parameters</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>keyword</td>\n<td>named parameters</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>unsigned_long</td>\n<td>double</td>\n<td>named parameters</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>integer</td>\n<td>named parameters</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>unsigned_long</td>\n<td>keyword</td>\n<td>named parameters</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>long</td>\n<td>named parameters</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>unsigned_long</td>\n<td>unsigned_long</td>\n<td>named parameters</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>version</td>\n<td>keyword</td>\n<td>named parameters</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>version</td>\n<td>version</td>\n<td>named parameters</td>\n<td>boolean</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Supported function named parameters</strong> <definitions> <definition term="fuzziness"> (keyword) Maximum edit distance allowed for matching. </definition> <definition term="auto_generate_synonyms_phrase_query"> (boolean) If true, match phrase queries are automatically created for multi-term synonyms. Defaults to true. </definition> <definition term="analyzer"> (keyword) Analyzer used to convert the text in the query value into token. Defaults to the index-time analyzer mapped for the field. If no analyzer is mapped, the index’s default analyzer is used. </definition> <definition term="minimum_should_match"> (integer) Minimum number of clauses that must match for a document to be returned. </definition> <definition term="zero_terms_query"> (keyword) Indicates whether all documents or none are returned if the analyzer removes all tokens, such as when using a stop filter. Defaults to none. </definition> <definition term="boost"> (float) Floating point number used to decrease or increase the relevance scores of the query. Defaults to 1.0. </definition> <definition term="fuzzy_transpositions"> (boolean) If true, edits for fuzzy matching include transpositions of two adjacent characters (ab → ba). Defaults to true. </definition> <definition term="fuzzy_rewrite"> (keyword) Method used to rewrite the query. See the rewrite parameter for valid values and more information. If the fuzziness parameter is not 0, the match query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default. </definition> <definition term="prefix_length"> (integer) Number of beginning characters left unchanged for fuzzy matching. Defaults to 0. </definition> <definition term="lenient"> (boolean) If false, format-based errors, such as providing a text query value for a numeric field, are returned. Defaults to false. </definition> <definition term="operator"> (keyword) Boolean logic used to interpret text in the query value. Defaults to OR. </definition> <definition term="max_expansions"> (integer) Maximum number of terms to which the query will expand. Defaults to 50. </definition> </definitions></p>\n<p><strong>Examples</strong></p>\n<pre class="esql"><code>FROM books\n| WHERE MATCH(author, &quot;Faulkner&quot;)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>book_no:keyword</th>\n<th>author:text</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>2378</td>\n<td>[Carol Faulkner, Holly Byers Ochoa, Lucretia Mott]</td>\n</tr>\n<tr class="even">\n<td>2713</td>\n<td>William Faulkner</td>\n</tr>\n<tr class="odd">\n<td>2847</td>\n<td>Colleen Faulkner</td>\n</tr>\n<tr class="even">\n<td>2883</td>\n<td>William Faulkner</td>\n</tr>\n<tr class="odd">\n<td>3293</td>\n<td>Danny Faulkner</td>\n</tr>\n</tbody>\n</table>\n<pre class="esql"><code>FROM books\n| WHERE MATCH(title, &quot;Hobbit Back Again&quot;, {&quot;operator&quot;: &quot;AND&quot;})\n| KEEP title;</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>title:text</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>The Hobbit or There and Back Again</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("to_string", """
<h2 id="to_string"><code>TO_STRING</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/to_string.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> Input value. The input can be a single- or multi-valued column or an expression. </definition> </definitions></p>\n<p><strong>Description</strong> Converts an input value into a string. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>aggregate_metric_double</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>boolean</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>cartesian_point</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>cartesian_shape</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>date</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>date_nanos</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>dense_vector</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>geo_point</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>geo_shape</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>geohash</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>geohex</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>geotile</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>ip</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>unsigned_long</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>version</td>\n<td>keyword</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Examples</strong></p>\n<pre class="esql"><code>ROW a=10\n| EVAL j = TO_STRING(a)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:integer</th>\n<th>j:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>10</td>\n<td>“10”</td>\n</tr>\n</tbody>\n</table>\n<p>It also works fine on multivalued fields:</p>\n<pre class="esql"><code>ROW a=[10, 9, 8]\n| EVAL j = TO_STRING(a)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:integer</th>\n<th>j:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>[10, 9, 8]</td>\n<td>[“10”, “9”, “8”]</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("sin", """
<h2 id="sin"><code>SIN</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/sin.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="angle"> An angle, in radians. If <code>null</code>, the function returns <code>null</code>. </definition> </definitions></p>\n<p><strong>Description</strong> Returns the <a href="https://en.wikipedia.org/wiki/Sine_and_cosine">sine</a> of an angle. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>angle</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW a=1.8\n| EVAL sin=SIN(a)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:double</th>\n<th>sin:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>1.8</td>\n<td>0.9738476308781951</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("to_date_nanos", """
<h2 id="to_date_nanos"><code>TO_DATE_NANOS</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/to_date_nanos.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> Input value. The input can be a single- or multi-valued column or an expression. </definition> </definitions></p>\n<strong>Description</strong> Converts an input to a nanosecond-resolution date value (aka date_nanos).\n<note>\nThe range for date nanos is 1970-01-01T00:00:00.000000000Z to 2262-04-11T23:47:16.854775807Z, attempting to convert values outside of that range will result in null with a warning. Additionally, integers cannot be converted into date nanos, as the range of integer nanoseconds only covers about 2 seconds after epoch.\n</note>\n<p><strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>date</td>\n<td>date_nanos</td>\n</tr>\n<tr class="even">\n<td>date_nanos</td>\n<td>date_nanos</td>\n</tr>\n<tr class="odd">\n<td>double</td>\n<td>date_nanos</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>date_nanos</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>date_nanos</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>date_nanos</td>\n</tr>\n<tr class="odd">\n<td>unsigned_long</td>\n<td>date_nanos</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>FROM date_nanos\n| WHERE MV_MIN(nanos) &lt; TO_DATE_NANOS(&quot;2023-10-23T12:27:28.948Z&quot;)\n    AND millis &gt; &quot;2000-01-01&quot;\n| SORT nanos DESC</code></pre>\n<table style="width:100%;">\n<colgroup>\n<col style="width: 32%" />\n<col style="width: 40%" />\n<col style="width: 26%" />\n</colgroup>\n<thead>\n<tr class="header">\n<th>millis:date</th>\n<th>nanos:date_nanos</th>\n<th>num:long</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>2023-10-23T12:15:03.360Z</td>\n<td>2023-10-23T12:15:03.360103847Z</td>\n<td>1698063303360103847</td>\n</tr>\n<tr class="even">\n<td>2023-10-23T12:15:03.360Z</td>\n<td>2023-10-23T12:15:03.360103847Z</td>\n<td>1698063303360103847</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("to_geotile", """
<h2 id="to_geotile"><code>TO_GEOTILE</code></h2>\n<pre><code>stack: preview\nserverless: preview</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/to_geotile.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> Input value. The input can be a single- or multi-valued column or an expression. </definition> </definitions></p>\n<p><strong>Description</strong> Converts an input value to a <code>geotile</code> value. A string will only be successfully converted if it respects the <code>geotile</code> format, as described for the <a href="https://www.elastic.co/docs/reference/aggregations/search-aggregations-bucket-geotilegrid-aggregation">geotile grid aggregation</a>. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>geotile</td>\n<td>geotile</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>geotile</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>geotile</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>geotile</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW string = &quot;4/8/5&quot;\n| EVAL geotile = TO_GEOTILE(string)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>string:keyword</th>\n<th>geotile:geotile</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>4/8/5</td>\n<td>4/8/5</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("variance_over_time", """
<h2 id="variance_over_time"><code>VARIANCE_OVER_TIME</code></h2>\n<pre><code>stack: preview 9.3.0\nserverless: preview</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/variance_over_time.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="number"> Expression for which to calculate the variance over time. </definition> </definitions></p>\n<p><strong>Description</strong> Calculates the population variance over time of a numeric field. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>number</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>TS k8s\n| STATS avg_var_cost=AVG(VARIANCE_OVER_TIME(network.cost)) BY cluster, time_bucket = TBUCKET(1minute)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>cluster:keyword</th>\n<th>time_bucket:datetime</th>\n<th>avg_var_cost:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>staging</td>\n<td>2024-05-10T00:03:00.000Z</td>\n<td>20.478516</td>\n</tr>\n<tr class="even">\n<td>qa</td>\n<td>2024-05-10T00:21:00.000Z</td>\n<td>16.0</td>\n</tr>\n<tr class="odd">\n<td>qa</td>\n<td>2024-05-10T00:18:00.000Z</td>\n<td>11.192274</td>\n</tr>\n<tr class="even">\n<td>staging</td>\n<td>2024-05-10T00:09:00.000Z</td>\n<td>10.446904</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("mv_contains", """
<h2 id="mv_contains"><code>MV_CONTAINS</code></h2>\n<pre><code>stack: preview 9.2.0</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/mv_contains.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="superset"> Multivalue expression. </definition> <definition term="subset"> Multivalue expression. </definition> </definitions></p>\n<p><strong>Description</strong> Checks if all values yielded by the second multivalue expression are present in the values yielded by the first multivalue expression. Returns a boolean. Null values are treated as an empty set. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>superset</th>\n<th>subset</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>boolean</td>\n<td>boolean</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>cartesian_point</td>\n<td>cartesian_point</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>cartesian_shape</td>\n<td>cartesian_shape</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>date</td>\n<td>date</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>date_nanos</td>\n<td>date_nanos</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>double</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>geo_point</td>\n<td>geo_point</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>geo_shape</td>\n<td>geo_shape</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>geohash</td>\n<td>geohash</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>geohex</td>\n<td>geohex</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>geotile</td>\n<td>geotile</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>integer</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>ip</td>\n<td>ip</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>keyword</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>keyword</td>\n<td>text</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>long</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>keyword</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>text</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>unsigned_long</td>\n<td>unsigned_long</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>version</td>\n<td>version</td>\n<td>boolean</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Examples</strong></p>\n<pre class="esql"><code>ROW set = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;], element = &quot;a&quot;\n| EVAL set_contains_element = mv_contains(set, element)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>set:keyword</th>\n<th>element:keyword</th>\n<th>set_contains_element:boolean</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>[a, b, c]</td>\n<td>a</td>\n<td>true</td>\n</tr>\n</tbody>\n</table>\n<pre class="esql"><code>ROW setA = [&quot;a&quot;,&quot;c&quot;], setB = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]\n| EVAL a_subset_of_b = mv_contains(setB, setA)\n| EVAL b_subset_of_a = mv_contains(setA, setB)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>setA:keyword</th>\n<th>setB:keyword</th>\n<th>a_subset_of_b:boolean</th>\n<th>b_subset_of_a:boolean</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>[a, c]</td>\n<td>[a, b, c]</td>\n<td>true</td>\n<td>false</td>\n</tr>\n</tbody>\n</table>\n<pre class="esql"><code>FROM airports\n| WHERE mv_contains(type, [&quot;major&quot;,&quot;military&quot;]) AND scalerank == 9\n| KEEP scalerank, name, country</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>scalerank:integer</th>\n<th>name:text</th>\n<th>country:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>9</td>\n<td>Chandigarh Int’l</td>\n<td>India</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("trim", """
<h2 id="trim"><code>TRIM</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/trim.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="string"> String expression. If <code>null</code>, the function returns <code>null</code>. </definition> </definitions></p>\n<p><strong>Description</strong> Removes leading and trailing whitespaces from a string. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>string</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>keyword</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW message = &quot;   some text  &quot;,  color = &quot; red &quot;\n| EVAL message = TRIM(message)\n| EVAL color = TRIM(color)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>message:s</th>\n<th>color:s</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>some text</td>\n<td>red</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("ip_prefix", """
<h2 id="ip_prefix"><code>IP_PREFIX</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/ip_prefix.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="ip"> IP address of type <code>ip</code> (both IPv4 and IPv6 are supported). </definition> <definition term="prefixLengthV4"> Prefix length for IPv4 addresses. </definition> <definition term="prefixLengthV6"> Prefix length for IPv6 addresses. </definition> </definitions></p>\n<p><strong>Description</strong> Truncates an IP to a given prefix length. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>ip</th>\n<th>prefixLengthV4</th>\n<th>prefixLengthV6</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>ip</td>\n<td>integer</td>\n<td>integer</td>\n<td>ip</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW ip4 = to_ip(&quot;1.2.3.4&quot;), ip6 = TO_IP(&quot;fe80::cae2:65ff:fece:feb9&quot;)\n| EVAL ip4_prefix = IP_PREFIX(ip4, 24, 0), ip6_prefix = IP_PREFIX(ip6, 0, 112);</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>ip4:ip</th>\n<th>ip6:ip</th>\n<th>ip4_prefix:ip</th>\n<th>ip6_prefix:ip</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>1.2.3.4</td>\n<td>fe80::cae2:65ff:fece:feb9</td>\n<td>1.2.3.0</td>\n<td>fe80::cae2:65ff:fece:0000</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("tau", """
<h2 id="tau"><code>TAU</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/tau.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <strong>Description</strong> Returns the <a href="https://tauday.com/tau-manifesto">ratio</a> of a circle’s circumference to its radius. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW TAU()</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>TAU():double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>6.283185307179586</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("inlinestats-by", """
<h1 id="inline-stats">INLINE STATS</h1>\n<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="fu">serverless</span><span class="kw">:</span><span class="at"> preview</span></span>\n<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="fu">stack</span><span class="kw">:</span><span class="at"> preview 9.2.0</span></span></code></pre></div>\n<p>The <code>INLINE STATS</code> processing command groups rows according to a common value and calculates one or more aggregated values over the grouped rows. The results are appended as new columns to the input rows. The command is identical to <a href="https://www.elastic.co/docs/reference/query-languages/esql/commands/stats-by"><code>STATS</code></a> except that it preserves all the columns from the input table. <strong>Syntax</strong></p>\n<pre class="esql"><code>INLINE STATS [column1 =] expression1 [WHERE boolean_expression1][,\n      ...,\n      [columnN =] expressionN [WHERE boolean_expressionN]]\n      [BY [grouping_name1 =] grouping_expression1[,\n          ...,\n          [grouping_nameN = ] grouping_expressionN]]</code></pre>\n<p><strong>Parameters</strong> <definitions> <definition term="columnX"> The name by which the aggregated value is returned. If omitted, the name is equal to the corresponding expression (<code>expressionX</code>). If multiple columns have the same name, all but the rightmost column with this name will be ignored. </definition> <definition term="expressionX"> An expression that computes an aggregated value. </definition> <definition term="grouping_expressionX"> An expression that outputs the values to group by. If its name coincides with one of the existing or computed columns, that column will be overridden by this one. </definition> <definition term="boolean_expressionX"> The condition that determines which rows are included when evaluating <code>expressionX</code>. </definition> </definitions></p>\n<note>\nIndividual <code>null</code> values are skipped when computing aggregations.\n</note>\n<p><strong>Description</strong> The <code>INLINE STATS</code> processing command groups rows according to a common value (also known as the grouping key), specified after <code>BY</code>, and calculates one or more aggregated values over the grouped rows. The output table contains the same number of rows as the input table. The command only adds new columns or overrides existing columns with the same name as the result. If column names overlap, existing column values may be overridden and column order may change. The new columns are added/moved so that they appear in the order they are defined in the <code>INLINE STATS</code> command. For the calculation of each aggregated value, the rows in a group can be filtered with <code>WHERE</code>. If <code>BY</code> is omitted the aggregations are applied over the entire dataset. The following <a href="https://www.elastic.co/docs/reference/query-languages/esql/functions-operators/aggregation-functions">aggregation functions</a> are supported: - <a href="/docs/reference/query-languages/esql/functions-operators/aggregation-functions#esql-absent"><code>ABSENT</code></a> <code>stack: ga 9.2</code> - <a href="/docs/reference/query-languages/esql/functions-operators/aggregation-functions#esql-avg"><code>AVG</code></a> - <a href="/docs/reference/query-languages/esql/functions-operators/aggregation-functions#esql-count"><code>COUNT</code></a> - <a href="/docs/reference/query-languages/esql/functions-operators/aggregation-functions#esql-count_distinct"><code>COUNT_DISTINCT</code></a> - <a href="/docs/reference/query-languages/esql/functions-operators/aggregation-functions#esql-first"><code>FIRST</code></a> <code>stack: ga 9.2</code> - <a href="/docs/reference/query-languages/esql/functions-operators/aggregation-functions#esql-last"><code>LAST</code></a> <code>stack: ga 9.2</code> - <a href="/docs/reference/query-languages/esql/functions-operators/aggregation-functions#esql-max"><code>MAX</code></a> - <a href="/docs/reference/query-languages/esql/functions-operators/aggregation-functions#esql-median"><code>MEDIAN</code></a> - <a href="/docs/reference/query-languages/esql/functions-operators/aggregation-functions#esql-median_absolute_deviation"><code>MEDIAN_ABSOLUTE_DEVIATION</code></a> - <a href="/docs/reference/query-languages/esql/functions-operators/aggregation-functions#esql-min"><code>MIN</code></a> - <a href="/docs/reference/query-languages/esql/functions-operators/aggregation-functions#esql-percentile"><code>PERCENTILE</code></a> - <a href="/docs/reference/query-languages/esql/functions-operators/aggregation-functions#esql-present"><code>PRESENT</code></a> <code>stack: ga 9.2</code> - <a href="/docs/reference/query-languages/esql/functions-operators/aggregation-functions#esql-sample"><code>SAMPLE</code></a> - <a href="/docs/reference/query-languages/esql/functions-operators/aggregation-functions#esql-st_centroid_agg"><code>ST_CENTROID_AGG</code></a> <code>stack: preview</code> <code>serverless: preview</code> - <a href="/docs/reference/query-languages/esql/functions-operators/aggregation-functions#esql-st_extent_agg"><code>ST_EXTENT_AGG</code></a> <code>stack: preview</code> <code>serverless: preview</code> - <a href="/docs/reference/query-languages/esql/functions-operators/aggregation-functions#esql-std_dev"><code>STD_DEV</code></a> - <a href="/docs/reference/query-languages/esql/functions-operators/aggregation-functions#esql-sum"><code>SUM</code></a> - <a href="/docs/reference/query-languages/esql/functions-operators/aggregation-functions#esql-top"><code>TOP</code></a> - <a href="/docs/reference/query-languages/esql/functions-operators/aggregation-functions#esql-values"><code>VALUES</code></a> <code>stack: preview</code> <code>serverless: preview</code> - <a href="/docs/reference/query-languages/esql/functions-operators/aggregation-functions#esql-variance"><code>VARIANCE</code></a> - <a href="/docs/reference/query-languages/esql/functions-operators/aggregation-functions#esql-weighted_avg"><code>WEIGHTED_AVG</code></a></p>\n<p>The following <a href="https://www.elastic.co/docs/reference/query-languages/esql/functions-operators/grouping-functions">grouping functions</a> are supported: - <a href="/docs/reference/query-languages/esql/functions-operators/grouping-functions#esql-bucket"><code>BUCKET</code></a> - <a href="/docs/reference/query-languages/esql/functions-operators/grouping-functions#esql-tbucket"><code>TBUCKET</code></a></p>\n<strong>Examples</strong> The following example shows how to calculate a statistic on one column and group by the values of another column.\n<note>\nThe <code>languages</code> column moves to the last position in the output table because it is a column overridden by the <code>INLINE STATS</code> command (it’s the grouping key) and it is the last column defined by it.\n</note>\n<pre class="esql"><code>FROM employees\n| KEEP emp_no, languages, salary\n| INLINE STATS max_salary = MAX(salary) BY languages</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>emp_no:integer</th>\n<th>salary:integer</th>\n<th>max_salary:integer</th>\n<th>languages:integer</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>10001</td>\n<td>57305</td>\n<td>73578</td>\n<td>2</td>\n</tr>\n<tr class="even">\n<td>10002</td>\n<td>56371</td>\n<td>66817</td>\n<td>5</td>\n</tr>\n<tr class="odd">\n<td>10003</td>\n<td>61805</td>\n<td>74572</td>\n<td>4</td>\n</tr>\n<tr class="even">\n<td>10004</td>\n<td>36174</td>\n<td>66817</td>\n<td>5</td>\n</tr>\n<tr class="odd">\n<td>10005</td>\n<td>63528</td>\n<td>73717</td>\n<td>1</td>\n</tr>\n</tbody>\n</table>\n<p>The following example shows how to calculate an aggregation over the entire dataset by omitting <code>BY</code>. The order of the existing columns is preserved and a new column with the calculated maximum salary value is added as the last column:</p>\n<pre class="esql"><code>FROM employees\n| KEEP emp_no, languages, salary\n| INLINE STATS max_salary = MAX(salary)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>emp_no:integer</th>\n<th>languages:integer</th>\n<th>salary:integer</th>\n<th>max_salary:integer</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>10001</td>\n<td>2</td>\n<td>57305</td>\n<td>74999</td>\n</tr>\n<tr class="even">\n<td>10002</td>\n<td>5</td>\n<td>56371</td>\n<td>74999</td>\n</tr>\n<tr class="odd">\n<td>10003</td>\n<td>4</td>\n<td>61805</td>\n<td>74999</td>\n</tr>\n<tr class="even">\n<td>10004</td>\n<td>5</td>\n<td>36174</td>\n<td>74999</td>\n</tr>\n<tr class="odd">\n<td>10005</td>\n<td>1</td>\n<td>63528</td>\n<td>74999</td>\n</tr>\n</tbody>\n</table>\n<p>The following example shows how to calculate multiple aggregations with multiple grouping keys:</p>\n<pre class="esql"><code>FROM employees\n| WHERE still_hired\n| KEEP emp_no, languages, salary, hire_date\n| EVAL tenure = DATE_DIFF(&quot;year&quot;, hire_date, &quot;2025-09-18T00:00:00&quot;)\n| DROP hire_date\n| INLINE STATS avg_salary = AVG(salary), count = count(*) BY languages, tenure</code></pre>\n<table>\n<colgroup>\n<col style="width: 16%" />\n<col style="width: 16%" />\n<col style="width: 19%" />\n<col style="width: 12%" />\n<col style="width: 19%" />\n<col style="width: 16%" />\n</colgroup>\n<thead>\n<tr class="header">\n<th>emp_no:integer</th>\n<th>salary:integer</th>\n<th>avg_salary:double</th>\n<th>count:long</th>\n<th>languages:integer</th>\n<th>tenure:integer</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>10001</td>\n<td>57305</td>\n<td>51130.5</td>\n<td>2</td>\n<td>2</td>\n<td>39</td>\n</tr>\n<tr class="even">\n<td>10002</td>\n<td>56371</td>\n<td>40180.0</td>\n<td>3</td>\n<td>5</td>\n<td>39</td>\n</tr>\n<tr class="odd">\n<td>10004</td>\n<td>36174</td>\n<td>30749.0</td>\n<td>2</td>\n<td>5</td>\n<td>38</td>\n</tr>\n<tr class="even">\n<td>10005</td>\n<td>63528</td>\n<td>63528.0</td>\n<td>1</td>\n<td>1</td>\n<td>36</td>\n</tr>\n<tr class="odd">\n<td>10007</td>\n<td>74572</td>\n<td>58644.0</td>\n<td>2</td>\n<td>4</td>\n<td>36</td>\n</tr>\n</tbody>\n</table>\n<p>The following example shows how to filter which rows are used for each aggregation, using the <code>WHERE</code> clause:</p>\n<pre class="esql"><code>FROM employees\n| KEEP emp_no, salary\n| INLINE STATS avg_lt_50 = ROUND(AVG(salary)) WHERE salary &lt; 50000,\n               avg_lt_60 = ROUND(AVG(salary)) WHERE salary &gt;=50000 AND salary &lt; 60000,\n               avg_gt_60 = ROUND(AVG(salary)) WHERE salary &gt;= 60000</code></pre>\n<table>\n<colgroup>\n<col style="width: 18%" />\n<col style="width: 18%" />\n<col style="width: 20%" />\n<col style="width: 20%" />\n<col style="width: 20%" />\n</colgroup>\n<thead>\n<tr class="header">\n<th>emp_no:integer</th>\n<th>salary:integer</th>\n<th>avg_lt_50:double</th>\n<th>avg_lt_60:double</th>\n<th>avg_gt_60:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>10001</td>\n<td>57305</td>\n<td>38292.0</td>\n<td>54221.0</td>\n<td>67286.0</td>\n</tr>\n<tr class="even">\n<td>10002</td>\n<td>56371</td>\n<td>38292.0</td>\n<td>54221.0</td>\n<td>67286.0</td>\n</tr>\n<tr class="odd">\n<td>10003</td>\n<td>61805</td>\n<td>38292.0</td>\n<td>54221.0</td>\n<td>67286.0</td>\n</tr>\n<tr class="even">\n<td>10004</td>\n<td>36174</td>\n<td>38292.0</td>\n<td>54221.0</td>\n<td>67286.0</td>\n</tr>\n<tr class="odd">\n<td>10005</td>\n<td>63528</td>\n<td>38292.0</td>\n<td>54221.0</td>\n<td>67286.0</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Limitations</strong> - The <a href="/docs/reference/query-languages/esql/functions-operators/grouping-functions#esql-categorize"><code>CATEGORIZE</code></a> grouping function is not currently supported. - You cannot currently use <a href="https://www.elastic.co/docs/reference/query-languages/esql/commands/limit"><code>LIMIT</code></a> (explicit or implicit) before <code>INLINE STATS</code>, because this can lead to unexpected results. - You cannot currently use <a href="https://www.elastic.co/docs/reference/query-languages/esql/commands/fork"><code>FORK</code></a> before <code>INLINE STATS</code>, because <code>FORK</code> adds an implicit <a href="https://www.elastic.co/docs/reference/query-languages/esql/commands/limit"><code>LIMIT</code></a> to each branch, which can lead to unexpected results.</p>
"""),                     Map.entry("source-commands", """
<h1 id="esql-source-commands">ES|QL source commands</h1>\n<p>An ES|QL source command produces a table, typically with data from Elasticsearch. An ES|QL query must start with a source command. <img src="https://www.elastic.co/docs/reference/query-languages/images/source-command.svg" alt="A source command producing a table from Elasticsearch" /></p>\n<p>ES|QL supports these source commands: - <a href="https://www.elastic.co/docs/reference/query-languages/esql/commands/from"><code>FROM</code></a> - <a href="https://www.elastic.co/docs/reference/query-languages/esql/commands/row"><code>ROW</code></a> - <a href="https://www.elastic.co/docs/reference/query-languages/esql/commands/show"><code>SHOW</code></a> - <a href="https://www.elastic.co/docs/reference/query-languages/esql/commands/ts"><code>TS</code></a></p>
"""),                     Map.entry("right", """
<h2 id="right"><code>RIGHT</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/right.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="string"> The string from which to returns a substring. </definition> <definition term="length"> The number of characters to return. </definition> </definitions></p>\n<p><strong>Description</strong> Return the substring that extracts <em>length</em> chars from <em>str</em> starting from the right. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>string</th>\n<th>length</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>keyword</td>\n<td>integer</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>integer</td>\n<td>keyword</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>FROM employees\n| KEEP last_name\n| EVAL right = RIGHT(last_name, 3)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>last_name:keyword</th>\n<th>right:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>Awdeh</td>\n<td>deh</td>\n</tr>\n<tr class="even">\n<td>Azuma</td>\n<td>uma</td>\n</tr>\n<tr class="odd">\n<td>Baek</td>\n<td>aek</td>\n</tr>\n<tr class="even">\n<td>Bamford</td>\n<td>ord</td>\n</tr>\n<tr class="odd">\n<td>Bernatsky</td>\n<td>sky</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("tan", """
<h2 id="tan"><code>TAN</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/tan.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="angle"> An angle, in radians. If <code>null</code>, the function returns <code>null</code>. </definition> </definitions></p>\n<p><strong>Description</strong> Returns the <a href="https://en.wikipedia.org/wiki/Sine_and_cosine">tangent</a> of an angle. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>angle</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW a=1.8\n| EVAL tan=TAN(a)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:double</th>\n<th>tan:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>1.8</td>\n<td>-4.286261674628062</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("percentile", """
<h2 id="percentile"><code>PERCENTILE</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/percentile.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="number"> </definition> <definition term="percentile"> </definition> </definitions></p>\n<p><strong>Description</strong> Returns the value at which a certain percentage of observed values occur. For example, the 95th percentile is the value which is greater than 95% of the observed values and the 50th percentile is the <code>MEDIAN</code>. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>number</th>\n<th>percentile</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>double</td>\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>long</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Examples</strong></p>\n<pre class="esql"><code>FROM employees\n| STATS p0 = PERCENTILE(salary,  0)\n     , p50 = PERCENTILE(salary, 50)\n     , p99 = PERCENTILE(salary, 99)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>p0:double</th>\n<th>p50:double</th>\n<th>p99:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>25324</td>\n<td>47003</td>\n<td>74970.29</td>\n</tr>\n</tbody>\n</table>\n<p>The expression can use inline functions. For example, to calculate a percentile of the maximum values of a multivalued column, first use <code>MV_MAX</code> to get the maximum value per row, and use the result with the <code>PERCENTILE</code> function</p>\n<pre class="esql"><code>FROM employees\n| STATS p80_max_salary_change = PERCENTILE(MV_MAX(salary_change), 80)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>p80_max_salary_change:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>12.132</td>\n</tr>\n</tbody>\n</table>\n<h3 id="percentile-is-usually-approximate"><code>PERCENTILE</code> is (usually) approximate</h3>\n<p>There are many different algorithms to calculate percentiles. The naive implementation simply stores all the values in a sorted array. To find the 50th percentile, you simply find the value that is at <code>my_array[count(my_array) * 0.5]</code>. Clearly, the naive implementation does not scale — the sorted array grows linearly with the number of values in your dataset. To calculate percentiles across potentially billions of values in an Elasticsearch cluster, <em>approximate</em> percentiles are calculated. The algorithm used by the <code>percentile</code> metric is called TDigest (introduced by Ted Dunning in <a href="https://github.com/tdunning/t-digest/blob/master/docs/t-digest-paper/histo.pdf">Computing Accurate Quantiles using T-Digests</a>). When using this metric, there are a few guidelines to keep in mind: - Accuracy is proportional to <code>q(1-q)</code>. This means that extreme percentiles (e.g. 99%) are more accurate than less extreme percentiles, such as the median - For small sets of values, percentiles are highly accurate (and potentially 100% accurate if the data is small enough). - As the quantity of values in a bucket grows, the algorithm begins to approximate the percentiles. It is effectively trading accuracy for memory savings. The exact level of inaccuracy is difficult to generalize, since it depends on your data distribution and volume of data being aggregated</p>\nThe following chart shows the relative error on a uniform distribution depending on the number of collected values and the requested percentile: <img src="https://www.elastic.co/docs/reference/query-languages/images/percentiles_error.png" alt="percentiles error" /> It shows how precision is better for extreme percentiles. The reason why error diminishes for large number of values is that the law of large numbers makes the distribution of values more and more uniform and the t-digest tree can do a better job at summarizing it. It would not be the case on more skewed distributions.\n<warning>\n<code>PERCENTILE</code> is also <a href="https://en.wikipedia.org/wiki/Nondeterministic_algorithm">non-deterministic</a>. This means you can get slightly different results using the same data.\n</warning>
"""),                     Map.entry("fork", """
<h1 id="fork">FORK</h1>\n<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="fu">serverless</span><span class="kw">:</span><span class="at"> preview</span></span>\n<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="fu">stack</span><span class="kw">:</span><span class="at"> preview 9.1.0</span></span></code></pre></div>\n<p>The <code>FORK</code> processing command creates multiple execution branches to operate on the same input data and combines the results in a single output table. <strong>Syntax</strong></p>\n<pre class="esql"><code>FORK ( &lt;processing_commands&gt; ) ( &lt;processing_commands&gt; ) ... ( &lt;processing_commands&gt; )</code></pre>\n<p><strong>Description</strong> The <code>FORK</code> processing command creates multiple execution branches to operate on the same input data and combines the results in a single output table. A discriminator column (<code>_fork</code>) is added to identify which branch each row came from. <strong>Branch identification:</strong> - The <code>_fork</code> column identifies each branch with values like <code>fork1</code>, <code>fork2</code>, <code>fork3</code> - Values correspond to the order branches are defined - <code>fork1</code> always indicates the first branch</p>\n<p><strong>Column handling:</strong> - <code>FORK</code> branches can output different columns - Columns with the same name must have the same data type across all branches - Missing columns are filled with <code>null</code> values</p>\n<p><strong>Row ordering:</strong> - <code>FORK</code> preserves row order within each branch - Rows from different branches may be interleaved - Use <code>SORT _fork</code> to group results by branch</p>\n<note>\n<code>FORK</code> branches default to <code>LIMIT 1000</code> if no <code>LIMIT</code> is provided.\n</note>\n<p><strong>Limitations</strong> - <code>FORK</code> supports at most 8 execution branches. - Using remote cluster references and <code>FORK</code> is not supported. - Using more than one <code>FORK</code> command in a query is not supported.</p>\n<p><strong>Examples</strong> In the following example, each <code>FORK</code> branch returns one row. Notice how <code>FORK</code> adds a <code>_fork</code> column that indicates which row the branch originates from:</p>\n<pre class="esql"><code>FROM employees\n| FORK ( WHERE emp_no == 10001 )\n       ( WHERE emp_no == 10002 )\n| KEEP emp_no, _fork\n| SORT emp_no</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>emp_no:integer</th>\n<th>_fork:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>10001</td>\n<td>fork1</td>\n</tr>\n<tr class="even">\n<td>10002</td>\n<td>fork2</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("completion", """
<h1 id="completion">COMPLETION</h1>\n<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="fu">serverless</span><span class="kw">:</span><span class="at"> preview</span></span>\n<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="fu">stack</span><span class="kw">:</span><span class="at"> preview 9.1.0</span></span></code></pre></div>\nThe <code>COMPLETION</code> command allows you to send prompts and context to a Large Language Model (LLM) directly within your ESQL queries, to perform text generation tasks.\n<important>\n<strong>Every row processed by the COMPLETION command generates a separate API call to the LLM endpoint.</strong>Be careful to test with small datasets first before running on production data or in automated workflows, to avoid unexpected costs.Best practices: 1. <strong>Start with dry runs</strong>: Validate your query logic and row counts by running without <code>COMPLETION</code> initially. Use <code>| STATS count = COUNT(*)</code> to check result size. 2. <strong>Filter first</strong>: Use <code>WHERE</code> clauses to limit rows before applying <code>COMPLETION</code>. 3. <strong>Test with <code>LIMIT</code></strong>: Always start with a low <a href="https://www.elastic.co/docs/reference/query-languages/esql/commands/limit"><code>LIMIT</code></a> and gradually increase. 4. <strong>Monitor usage</strong>: Track your LLM API consumption and costs.\n</important>\n<p><strong>Syntax</strong> <tab-set></p>\n<p><tab-item title="9.2.0+"></p>\n<pre><code>```esql\nCOMPLETION [column =] prompt WITH { &quot;inference_id&quot; : &quot;my_inference_endpoint&quot; }\n```</code></pre>\n<p></tab-item></p>\n<p><tab-item title="9.1.x only"></p>\n<pre><code>```esql\nCOMPLETION [column =] prompt WITH my_inference_endpoint\n```</code></pre>\n<p></tab-item> </tab-set></p>\n<p><strong>Parameters</strong> <definitions> <definition term="column"> (Optional) The name of the output column containing the LLM’s response. If not specified, the results will be stored in a column named <code>completion</code>. If the specified column already exists, it will be overwritten with the new results. </definition> <definition term="prompt"> The input text or expression used to prompt the LLM. This can be a string literal or a reference to a column containing text. </definition> <definition term="my_inference_endpoint"> The ID of the <a href="https://www.elastic.co/docs/explore-analyze/elastic-inference/inference-api">inference endpoint</a> to use for the task. The inference endpoint must be configured with the <code>completion</code> task type. </definition> </definitions></p>\n<p><strong>Description</strong> The <code>COMPLETION</code> command provides a general-purpose interface for text generation tasks using a Large Language Model (LLM) in ES|QL. <code>COMPLETION</code> supports a wide range of text generation tasks. Depending on your prompt and the model you use, you can perform arbitrary text generation tasks including: - Question answering - Summarization - Translation - Content rewriting - Creative generation</p>\n<p><strong>Requirements</strong> To use this command, you must deploy your LLM model in Elasticsearch as an <a href="https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-inference-put">inference endpoint</a> with the task type <code>completion</code>.</p>\n<h4 id="handling-timeouts">Handling timeouts</h4>\n<p><code>COMPLETION</code> commands may time out when processing large datasets or complex prompts. The default timeout is 10 minutes, but you can increase this limit if necessary. How you increase the timeout depends on your deployment type: <tab-set></p>\n<p><tab-item title="Elastic Cloud Hosted"></p>\n<pre><code>- You can adjust Elasticsearch settings in the [Elastic Cloud Console](https://www.elastic.co/docs/deploy-manage/deploy/elastic-cloud/edit-stack-settings)\n- You can also adjust the `search.default_search_timeout` cluster setting using [Kibana&#39;s Advanced settings](https://www.elastic.co/docs/reference/kibana/advanced-settings#kibana-search-settings)</code></pre>\n<p></tab-item></p>\n<p><tab-item title="Self-managed"></p>\n<pre><code>- You can configure at the cluster level by setting `search.default_search_timeout` in `elasticsearch.yml` or updating via [Cluster Settings API](https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-cluster-put-settings)\n- You can also adjust the `search:timeout` setting using [Kibana&#39;s Advanced settings](https://www.elastic.co/docs/reference/kibana/advanced-settings#kibana-search-settings)\n- Alternatively, you can add timeout parameters to individual queries</code></pre>\n<p></tab-item></p>\n<p><tab-item title="Elastic Cloud Serverless"></p>\n<pre><code>- Requires a manual override from Elastic Support because you cannot modify timeout settings directly</code></pre>\n<p></tab-item> </tab-set></p>\n<p>If you don’t want to increase the timeout limit, try the following: - Reduce data volume with <code>LIMIT</code> or more selective filters before the <code>COMPLETION</code> command - Split complex operations into multiple simpler queries - Configure your HTTP client’s response timeout (Refer to <a href="/docs/reference/elasticsearch/configuration-reference/networking-settings#_http_client_configuration">HTTP client configuration</a>)</p>\n<p><strong>Examples</strong> Use the default column name (results stored in <code>completion</code> column):</p>\n<pre class="esql"><code>ROW question = &quot;What is Elasticsearch?&quot;\n| COMPLETION question WITH { &quot;inference_id&quot; : &quot;my_inference_endpoint&quot; }\n| KEEP question, completion</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>question:keyword</th>\n<th>completion:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>What is Elasticsearch?</td>\n<td>A distributed search and analytics engine</td>\n</tr>\n</tbody>\n</table>\n<p>Specify the output column (results stored in <code>answer</code> column):</p>\n<pre class="esql"><code>ROW question = &quot;What is Elasticsearch?&quot;\n| COMPLETION answer = question WITH { &quot;inference_id&quot; : &quot;my_inference_endpoint&quot; }\n| KEEP question, answer</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>question:keyword</th>\n<th>answer:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>What is Elasticsearch?</td>\n<td>A distributed search and analytics engine</td>\n</tr>\n</tbody>\n</table>\n<p>Summarize the top 10 highest-rated movies using a prompt:</p>\n<pre class="esql"><code>FROM movies\n| SORT rating DESC\n| LIMIT 10\n| EVAL prompt = CONCAT(\n   &quot;Summarize this movie using the following information: \n&quot;,\n   &quot;Title: &quot;, title, &quot;\n&quot;,\n   &quot;Synopsis: &quot;, synopsis, &quot;\n&quot;,\n   &quot;Actors: &quot;, MV_CONCAT(actors, &quot;, &quot;), &quot;\n&quot;,\n  )\n| COMPLETION summary = prompt WITH { &quot;inference_id&quot; : &quot;my_inference_endpoint&quot; }\n| KEEP title, summary, rating</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>title:keyword</th>\n<th>summary:keyword</th>\n<th>rating:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>The Shawshank Redemption</td>\n<td>A tale of hope and redemption in prison.</td>\n<td>9.3</td>\n</tr>\n<tr class="even">\n<td>The Godfather</td>\n<td>A mafia family’s rise and fall.</td>\n<td>9.2</td>\n</tr>\n<tr class="odd">\n<td>The Dark Knight</td>\n<td>Batman battles the Joker in Gotham.</td>\n<td>9.0</td>\n</tr>\n<tr class="even">\n<td>Pulp Fiction</td>\n<td>Interconnected crime stories with dark humor.</td>\n<td>8.9</td>\n</tr>\n<tr class="odd">\n<td>Fight Club</td>\n<td>A man starts an underground fight club.</td>\n<td>8.8</td>\n</tr>\n<tr class="even">\n<td>Inception</td>\n<td>A thief steals secrets through dreams.</td>\n<td>8.8</td>\n</tr>\n<tr class="odd">\n<td>The Matrix</td>\n<td>A hacker discovers reality is a simulation.</td>\n<td>8.7</td>\n</tr>\n<tr class="even">\n<td>Parasite</td>\n<td>Class conflict between two families.</td>\n<td>8.6</td>\n</tr>\n<tr class="odd">\n<td>Interstellar</td>\n<td>A team explores space to save humanity.</td>\n<td>8.6</td>\n</tr>\n<tr class="even">\n<td>The Prestige</td>\n<td>Rival magicians engage in dangerous competition.</td>\n<td>8.5</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("mv_zip", """
<h2 id="mv_zip"><code>MV_ZIP</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/mv_zip.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="string1"> Multivalue expression. </definition> <definition term="string2"> Multivalue expression. </definition> <definition term="delim"> Delimiter. Optional; if omitted, <code>,</code> is used as a default delimiter. </definition> </definitions></p>\n<p><strong>Description</strong> Combines the values from two multivalued fields with a delimiter that joins them together. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>string1</th>\n<th>string2</th>\n<th>delim</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>keyword</td>\n<td>keyword</td>\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>keyword</td>\n<td>text</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>keyword</td>\n<td>keyword</td>\n<td></td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>text</td>\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>keyword</td>\n<td>text</td>\n<td>text</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>text</td>\n<td></td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>keyword</td>\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>keyword</td>\n<td>text</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>keyword</td>\n<td></td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>text</td>\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>text</td>\n<td>text</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>text</td>\n<td></td>\n<td>keyword</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW a = [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;], b = [&quot;1&quot;, &quot;2&quot;]\n| EVAL c = mv_zip(a, b, &quot;-&quot;)\n| KEEP a, b, c</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:keyword</th>\n<th>b:keyword</th>\n<th>c:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>[x, y, z]</td>\n<td>[1 ,2]</td>\n<td>[x-1, y-2, z]</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("log", """
<h2 id="log"><code>LOG</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/log.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="base"> Base of logarithm. If <code>null</code>, the function returns <code>null</code>. If not provided, this function returns the natural logarithm (base e) of a value. </definition> <definition term="number"> Numeric expression. If <code>null</code>, the function returns <code>null</code>. </definition> </definitions></p>\n<p><strong>Description</strong> Returns the logarithm of a value to a base. The input can be any numeric value, the return value is always a double. Logs of zero, negative numbers, and base of one return <code>null</code> as well as a warning. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>base</th>\n<th>number</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>double</td>\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>unsigned_long</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>double</td>\n<td></td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>unsigned_long</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td></td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>unsigned_long</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td></td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>unsigned_long</td>\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>unsigned_long</td>\n<td>unsigned_long</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td></td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Examples</strong></p>\n<pre class="esql"><code>ROW base = 2.0, value = 8.0\n| EVAL s = LOG(base, value)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>base: double</th>\n<th>value: double</th>\n<th>s:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>2.0</td>\n<td>8.0</td>\n<td>3.0</td>\n</tr>\n</tbody>\n</table>\n<pre class="esql"><code>ROW value = 100\n| EVAL s = LOG(value);</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>value: integer</th>\n<th>s:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>100</td>\n<td>4.605170185988092</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("to_ip", """
<h2 id="to_ip"><code>TO_IP</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/to_ip.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> Input value. The input can be a single- or multi-valued column or an expression. </definition> <definition term="options"> (Optional) Additional options. </definition> </definitions></p>\n<p><strong>Description</strong> Converts an input string to an IP value. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>options</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>ip</td>\n<td></td>\n<td>ip</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td></td>\n<td>ip</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td></td>\n<td>ip</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Supported function named parameters</strong> <definitions> <definition term="leading_zeros"> (keyword) What to do with leading 0s in IPv4 addresses. </definition> </definitions></p>\n<p><strong>Examples</strong></p>\n<pre class="esql"><code>ROW str1 = &quot;1.1.1.1&quot;, str2 = &quot;foo&quot;\n| EVAL ip1 = TO_IP(str1), ip2 = TO_IP(str2)\n| WHERE CIDR_MATCH(ip1, &quot;1.0.0.0/8&quot;)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>str1:keyword</th>\n<th>str2:keyword</th>\n<th>ip1:ip</th>\n<th>ip2:ip</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>1.1.1.1</td>\n<td>foo</td>\n<td>1.1.1.1</td>\n<td>null</td>\n</tr>\n</tbody>\n</table>\n<p>Note that in this example, the last conversion of the string isn’t possible. When this happens, the result is a <code>null</code> value. In this case a <em>Warning</em> header is added to the response. The header will provide information on the source of the failure: <code>"Line 1:68: evaluation of [TO_IP(str2)] failed, treating result as null. Only first 20 failures recorded."</code> A following header will contain the failure reason and the offending value: <code>"java.lang.IllegalArgumentException: 'foo' is not an IP string literal."</code></p>\n<pre class="esql"><code>ROW s = &quot;1.1.010.1&quot; | EVAL ip = TO_IP(s, {&quot;leading_zeros&quot;:&quot;octal&quot;})</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>s:keyword</th>\n<th>ip:ip</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>1.1.010.1</td>\n<td>1.1.8.1</td>\n</tr>\n</tbody>\n</table>\n<p>Parse v4 addresses with leading zeros as octal. Like <code>ping</code> or <code>ftp</code>.</p>\n<pre class="esql"><code>ROW s = &quot;1.1.010.1&quot; | EVAL ip = TO_IP(s, {&quot;leading_zeros&quot;:&quot;decimal&quot;})</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>s:keyword</th>\n<th>ip:ip</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>1.1.010.1</td>\n<td>1.1.10.1</td>\n</tr>\n</tbody>\n</table>\n<p>Parse v4 addresses with leading zeros as decimal. Java’s <code>InetAddress.getByName</code>.</p>
"""),                     Map.entry("pi", """
<h2 id="pi"><code>PI</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/pi.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <strong>Description</strong> Returns <a href="https://en.wikipedia.org/wiki/Pi">Pi</a>, the ratio of a circle’s circumference to its diameter. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW PI()</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>PI():double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>3.141592653589793</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("lookup-join", """
<h1 id="lookup-join">LOOKUP JOIN</h1>\n<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="fu">stack</span><span class="kw">:</span><span class="at"> preview 9.0.0, ga 9.1.0</span></span>\n<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="fu">serverless</span><span class="kw">:</span><span class="at"> ga</span></span></code></pre></div>\n<p><code>LOOKUP JOIN</code> enables you to add data from another index, AKA a ‘lookup’ index, to your ES|QL query results, simplifying data enrichment and analysis workflows. Refer to <a href="https://www.elastic.co/docs/reference/query-languages/esql/esql-lookup-join">the high-level landing page</a> for an overview of the <code>LOOKUP JOIN</code> command, including use cases, prerequisites, and current limitations. <strong>Syntax</strong></p>\n<pre class="esql"><code>FROM &lt;source_index&gt;\n| LOOKUP JOIN &lt;lookup_index&gt; ON &lt;field_name&gt;</code></pre>\n<pre class="esql"><code>FROM &lt;source_index&gt;\n| LOOKUP JOIN &lt;lookup_index&gt; ON &lt;field_name1&gt;, &lt;field_name2&gt;, &lt;field_name3&gt;</code></pre>\n<pre class="esql"><code>FROM &lt;source_index&gt;\n| LOOKUP JOIN &lt;lookup_index&gt; ON &lt;left_field1&gt; &gt;= &lt;lookup_field1&gt; AND &lt;left_field2&gt; == &lt;lookup_field2&gt;</code></pre>\n<p><strong>Parameters</strong> <definitions> <definition term="<lookup_index>"> The name of the lookup index. This must be a specific index name - wildcards, aliases, and remote cluster references are not supported. Indices used for lookups must be configured with the <a href="/docs/reference/elasticsearch/index-settings/index-modules#index-mode-setting"><code>lookup</code> index mode</a>. </definition> <definition term="<field_name> or <field_name1>, <field_name2>, <field_name3> or <left_field1> >= <lookup_field1> AND <left_field2> == <lookup_field2>"> The join condition. Can be one of the following: - A single field name - A comma-separated list of field names <code>stack: ga 9.2</code> - An expression with one or more join conditions linked by <code>AND</code>. Each condition compares a field from the left index with a field from the lookup index using <a href="/docs/reference/query-languages/esql/functions-operators/operators#esql-binary-operators">binary operators</a> (<code>==</code>, <code>&gt;=</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&lt;</code>, <code>!=</code>). Each field name in the join condition must exist in only one of the indexes. Use RENAME to resolve naming conflicts. <code>stack: preview 9.2</code> <code>serverless: preview</code> </definition> <definition term="If using join on a single field or a field list, the fields used must exist in both your current query results and in the lookup index. If the fields contains multi-valued entries, those entries will not match anything (the added fields will contain null for those rows)."> </definition> </definitions></p>\n<strong>Description</strong> The <code>LOOKUP JOIN</code> command adds new columns to your ES|QL query results table by finding documents in a lookup index that share the same join field value as your result rows. For each row in your results table that matches a document in the lookup index based on the join fields, all fields from the matching document are added as new columns to that row. If multiple documents in the lookup index match a single row in your results, the output will contain one row for each matching combination.\n<tip>\nFor important information about using <code>LOOKUP JOIN</code>, refer to <a href="/docs/reference/query-languages/esql/esql-lookup-join#usage-notes">Usage notes</a>.\n</tip>\n<p><strong>Supported types</strong></p>\n<table>\n<colgroup>\n<col style="width: 28%" />\n<col style="width: 71%" />\n</colgroup>\n<thead>\n<tr class="header">\n<th>field from the left index</th>\n<th>field from the lookup index</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>boolean</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>byte</td>\n<td>byte, short, integer, long, half_float, float, double, scaled_float</td>\n</tr>\n<tr class="odd">\n<td>date</td>\n<td>date</td>\n</tr>\n<tr class="even">\n<td>date_nanos</td>\n<td>date_nanos</td>\n</tr>\n<tr class="odd">\n<td>double</td>\n<td>half_float, float, double, scaled_float, byte, short, integer, long</td>\n</tr>\n<tr class="even">\n<td>float</td>\n<td>half_float, float, double, scaled_float, byte, short, integer, long</td>\n</tr>\n<tr class="odd">\n<td>half_float</td>\n<td>half_float, float, double, scaled_float, byte, short, integer, long</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>byte, short, integer, long, half_float, float, double, scaled_float</td>\n</tr>\n<tr class="odd">\n<td>ip</td>\n<td>ip</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>byte, short, integer, long, half_float, float, double, scaled_float</td>\n</tr>\n<tr class="even">\n<td>scaled_float</td>\n<td>half_float, float, double, scaled_float, byte, short, integer, long</td>\n</tr>\n<tr class="odd">\n<td>short</td>\n<td>byte, short, integer, long, half_float, float, double, scaled_float</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>keyword</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Examples</strong> <strong>IP Threat correlation</strong>: This query would allow you to see if any source IPs match known malicious addresses.</p>\n<pre class="esql"><code>FROM firewall_logs\n| LOOKUP JOIN threat_list ON source.IP</code></pre>\n<p>To filter only for those rows that have a matching <code>threat_list</code> entry, use <code>WHERE ... IS NOT NULL</code> with a field from the lookup index:</p>\n<pre class="esql"><code>FROM firewall_logs\n| LOOKUP JOIN threat_list ON source.IP\n| WHERE threat_level IS NOT NULL</code></pre>\n<p><strong>Host metadata correlation</strong>: This query pulls in environment or ownership details for each host to correlate with your metrics data.</p>\n<pre class="esql"><code>FROM system_metrics\n| LOOKUP JOIN host_inventory ON host.name\n| LOOKUP JOIN ownerships ON host.name</code></pre>\n<p><strong>Service ownership mapping</strong>: This query would show logs with the owning team or escalation information for faster triage and incident response.</p>\n<pre class="esql"><code>FROM app_logs\n| LOOKUP JOIN service_owners ON service_id</code></pre>\n<p><code>LOOKUP JOIN</code> is generally faster when there are fewer rows to join with. ES|QL will try and perform any <code>WHERE</code> clause before the <code>LOOKUP JOIN</code> where possible. The following two examples will have the same results. One has the <code>WHERE</code> clause before and the other after the <code>LOOKUP JOIN</code>. It does not matter how you write your query, our optimizer will move the filter before the lookup when possible.</p>\n<pre class="esql"><code>FROM employees\n| EVAL language_code = languages\n| WHERE emp_no &gt;= 10091 AND emp_no &lt; 10094\n| LOOKUP JOIN languages_lookup ON language_code</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>emp_no:integer</th>\n<th>language_code:integer</th>\n<th>language_name:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>10091</td>\n<td>3</td>\n<td>Spanish</td>\n</tr>\n<tr class="even">\n<td>10092</td>\n<td>1</td>\n<td>English</td>\n</tr>\n<tr class="odd">\n<td>10093</td>\n<td>3</td>\n<td>Spanish</td>\n</tr>\n</tbody>\n</table>\n<pre class="esql"><code>FROM employees\n| EVAL language_code = languages\n| LOOKUP JOIN languages_lookup ON language_code\n| WHERE emp_no &gt;= 10091 AND emp_no &lt; 10094</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>emp_no:integer</th>\n<th>language_code:integer</th>\n<th>language_name:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>10091</td>\n<td>3</td>\n<td>Spanish</td>\n</tr>\n<tr class="even">\n<td>10092</td>\n<td>1</td>\n<td>English</td>\n</tr>\n<tr class="odd">\n<td>10093</td>\n<td>3</td>\n<td>Spanish</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("keep", """
<h1 id="keep">KEEP</h1>\n<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="fu">serverless</span><span class="kw">:</span><span class="at"> ga</span></span>\n<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="fu">stack</span><span class="kw">:</span><span class="at"> ga</span></span></code></pre></div>\n<p>The <code>KEEP</code> processing command enables you to specify what columns are returned and the order in which they are returned. <strong>Syntax</strong></p>\n<pre class="esql"><code>KEEP columns</code></pre>\n<p><strong>Parameters</strong> <definitions> <definition term="columns"> A comma-separated list of columns to keep. Supports wildcards. See below for the behavior in case an existing column matches multiple given wildcards or column names. </definition> </definitions></p>\n<p><strong>Description</strong> The <code>KEEP</code> processing command enables you to specify what columns are returned and the order in which they are returned. Precedence rules are applied when a field name matches multiple expressions. Fields are added in the order they appear. If one field matches multiple expressions, the following precedence rules apply (from highest to lowest priority): 1. Complete field name (no wildcards) 2. Partial wildcard expressions (for example: <code>fieldNam*</code>) 3. Wildcard only (<code>*</code>)</p>\n<p>If a field matches two expressions with the same precedence, the rightmost expression wins. Refer to the examples for illustrations of these precedence rules. <strong>Examples</strong> The columns are returned in the specified order:</p>\n<pre class="esql"><code>FROM employees\n| KEEP emp_no, first_name, last_name, height</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>emp_no:integer</th>\n<th>first_name:keyword</th>\n<th>last_name:keyword</th>\n<th>height:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>10001</td>\n<td>Georgi</td>\n<td>Facello</td>\n<td>2.03</td>\n</tr>\n<tr class="even">\n<td>10002</td>\n<td>Bezalel</td>\n<td>Simmel</td>\n<td>2.08</td>\n</tr>\n<tr class="odd">\n<td>10003</td>\n<td>Parto</td>\n<td>Bamford</td>\n<td>1.83</td>\n</tr>\n<tr class="even">\n<td>10004</td>\n<td>Chirstian</td>\n<td>Koblick</td>\n<td>1.78</td>\n</tr>\n<tr class="odd">\n<td>10005</td>\n<td>Kyoichi</td>\n<td>Maliniak</td>\n<td>2.05</td>\n</tr>\n</tbody>\n</table>\n<p>Rather than specify each column by name, you can use wildcards to return all columns with a name that matches a pattern:</p>\n<pre class="esql"><code>FROM employees\n| KEEP h*</code></pre>\n<table>\n<colgroup>\n<col style="width: 14%" />\n<col style="width: 19%" />\n<col style="width: 24%" />\n<col style="width: 26%" />\n<col style="width: 15%" />\n</colgroup>\n<thead>\n<tr class="header">\n<th>height:double</th>\n<th>height.float:double</th>\n<th>height.half_float:double</th>\n<th>height.scaled_float:double</th>\n<th>hire_date:date</th>\n</tr>\n</thead>\n<tbody>\n</tbody>\n</table>\n<p>The asterisk wildcard (<code>*</code>) by itself translates to all columns that do not match the other arguments. This query will first return all columns with a name that starts with <code>h</code>, followed by all other columns:</p>\n<pre class="esql"><code>FROM employees\n| KEEP h*, *</code></pre>\n<table style="width:100%;">\n<colgroup>\n<col style="width: 3%" />\n<col style="width: 4%" />\n<col style="width: 5%" />\n<col style="width: 5%" />\n<col style="width: 3%" />\n<col style="width: 5%" />\n<col style="width: 3%" />\n<col style="width: 3%" />\n<col style="width: 4%" />\n<col style="width: 3%" />\n<col style="width: 4%" />\n<col style="width: 4%" />\n<col style="width: 3%" />\n<col style="width: 4%" />\n<col style="width: 4%" />\n<col style="width: 5%" />\n<col style="width: 3%" />\n<col style="width: 3%" />\n<col style="width: 4%" />\n<col style="width: 5%" />\n<col style="width: 6%" />\n<col style="width: 5%" />\n<col style="width: 4%" />\n</colgroup>\n<thead>\n<tr class="header">\n<th>height:double</th>\n<th>height.float:double</th>\n<th>height.half_float:double</th>\n<th>height.scaled_float:double</th>\n<th>hire_date:date</th>\n<th>avg_worked_seconds:long</th>\n<th>birth_date:date</th>\n<th>emp_no:integer</th>\n<th>first_name:keyword</th>\n<th>gender:keyword</th>\n<th>is_rehired:boolean</th>\n<th>job_positions:keyword</th>\n<th>languages:integer</th>\n<th>languages.byte:integer</th>\n<th>languages.long:long</th>\n<th>languages.short:integer</th>\n<th>last_name:keyword</th>\n<th>salary:integer</th>\n<th>salary_change:double</th>\n<th>salary_change.int:integer</th>\n<th>salary_change.keyword:keyword</th>\n<th>salary_change.long:long</th>\n<th>still_hired:boolean</th>\n</tr>\n</thead>\n<tbody>\n</tbody>\n</table>\n<p>The following examples show how precedence rules work when a field name matches multiple expressions. Complete field name has precedence over wildcard expressions:</p>\n<pre class="esql"><code>FROM employees\n| KEEP first_name, last_name, first_name*</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>first_name:keyword</th>\n<th>last_name:keyword</th>\n</tr>\n</thead>\n<tbody>\n</tbody>\n</table>\n<p>Wildcard expressions have the same priority, but last one wins (despite being less specific):</p>\n<pre class="esql"><code>FROM employees\n| KEEP first_name*, last_name, first_na*</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>last_name:keyword</th>\n<th>first_name:keyword</th>\n</tr>\n</thead>\n<tbody>\n</tbody>\n</table>\n<p>A simple wildcard expression <code>*</code> has the lowest precedence. Output order is determined by the other arguments:</p>\n<pre class="esql"><code>FROM employees\n| KEEP *, first_name</code></pre>\n<table>\n<colgroup>\n<col style="width: 5%" />\n<col style="width: 3%" />\n<col style="width: 3%" />\n<col style="width: 3%" />\n<col style="width: 3%" />\n<col style="width: 4%" />\n<col style="width: 5%" />\n<col style="width: 5%" />\n<col style="width: 3%" />\n<col style="width: 4%" />\n<col style="width: 4%" />\n<col style="width: 3%" />\n<col style="width: 4%" />\n<col style="width: 4%" />\n<col style="width: 5%" />\n<col style="width: 3%" />\n<col style="width: 3%" />\n<col style="width: 4%" />\n<col style="width: 5%" />\n<col style="width: 6%" />\n<col style="width: 5%" />\n<col style="width: 4%" />\n<col style="width: 4%" />\n</colgroup>\n<thead>\n<tr class="header">\n<th>avg_worked_seconds:long</th>\n<th>birth_date:date</th>\n<th>emp_no:integer</th>\n<th>gender:keyword</th>\n<th>height:double</th>\n<th>height.float:double</th>\n<th>height.half_float:double</th>\n<th>height.scaled_float:double</th>\n<th>hire_date:date</th>\n<th>is_rehired:boolean</th>\n<th>job_positions:keyword</th>\n<th>languages:integer</th>\n<th>languages.byte:integer</th>\n<th>languages.long:long</th>\n<th>languages.short:integer</th>\n<th>last_name:keyword</th>\n<th>salary:integer</th>\n<th>salary_change:double</th>\n<th>salary_change.int:integer</th>\n<th>salary_change.keyword:keyword</th>\n<th>salary_change.long:long</th>\n<th>still_hired:boolean</th>\n<th>first_name:keyword</th>\n</tr>\n</thead>\n<tbody>\n</tbody>\n</table>
"""),                     Map.entry("rerank", """
<h1 id="rerank">RERANK</h1>\n<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="fu">serverless</span><span class="kw">:</span><span class="at"> preview</span></span>\n<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="fu">stack</span><span class="kw">:</span><span class="at"> preview 9.2.0</span></span></code></pre></div>\n<p>The <code>RERANK</code> command uses an inference model to compute a new relevance score for an initial set of documents, directly within your ES|QL queries. <strong>Syntax</strong></p>\n<pre class="esql"><code>RERANK [column =] query ON field [, field, ...] [WITH { &quot;inference_id&quot; : &quot;my_inference_endpoint&quot; }]</code></pre>\n<p><strong>Parameters</strong> <definitions> <definition term="column"> (Optional) The name of the output column containing the reranked scores. If not specified, the results will be stored in a column named <code>_score</code>. If the specified column already exists, it will be overwritten with the new results. </definition> <definition term="query"> The query text used to rerank the documents. This is typically the same query used in the initial search. </definition> <definition term="field"> One or more fields to use for reranking. These fields should contain the text that the reranking model will evaluate. </definition> <definition term="my_inference_endpoint"> The ID of the <a href="https://www.elastic.co/docs/explore-analyze/elastic-inference/inference-api">inference endpoint</a> to use for the task. The inference endpoint must be configured with the <code>rerank</code> task type. </definition> </definitions></p>\n<p><strong>Description</strong> The <code>RERANK</code> command uses an inference model to compute a new relevance score for an initial set of documents, directly within your ES|QL queries. Typically, you first use a <code>WHERE</code> clause with a function like <code>MATCH</code> to retrieve an initial set of documents. This set is often sorted by <code>_score</code> and reduced to the top results (for example, 100) using <code>LIMIT</code>. The <code>RERANK</code> command then processes this smaller, refined subset, which is a good balance between performance and accuracy. <strong>Requirements</strong> To use this command, you must deploy your reranking model in Elasticsearch as an <a href="https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-inference-put">inference endpoint</a> with the task type <code>rerank</code>.</p>\n<h4 id="handling-timeouts">Handling timeouts</h4>\n<p><code>RERANK</code> commands may time out when processing large datasets or complex queries. The default timeout is 10 minutes, but you can increase this limit if necessary. How you increase the timeout depends on your deployment type: <tab-set></p>\n<p><tab-item title="Elastic Cloud Hosted"></p>\n<pre><code>- You can adjust Elasticsearch settings in\n  the [Elastic Cloud Console](https://www.elastic.co/docs/deploy-manage/deploy/elastic-cloud/edit-stack-settings)\n- You can also adjust the `search.default_search_timeout` cluster setting\n  using [Kibana&#39;s Advanced settings](https://www.elastic.co/docs/reference/kibana/advanced-settings#kibana-search-settings)</code></pre>\n<p></tab-item></p>\n<p><tab-item title="Self-managed"></p>\n<pre><code>- You can configure at the cluster level by setting\n  `search.default_search_timeout` in `elasticsearch.yml` or updating\n  via [Cluster Settings API](https://www.elastic.co/docs/api/doc/elasticsearch/operation/operation-cluster-put-settings)\n- You can also adjust the `search:timeout` setting\n  using [Kibana&#39;s Advanced settings](https://www.elastic.co/docs/reference/kibana/advanced-settings#kibana-search-settings)\n- Alternatively, you can add timeout parameters to individual queries</code></pre>\n<p></tab-item></p>\n<p><tab-item title="Elastic Cloud Serverless"></p>\n<pre><code>- Requires a manual override from Elastic Support because you cannot modify\n  timeout settings directly</code></pre>\n<p></tab-item> </tab-set></p>\n<p>If you don’t want to increase the timeout limit, try the following: - Reduce data volume with <code>LIMIT</code> or more selective filters before the <code>RERANK</code> command - Split complex operations into multiple simpler queries - Configure your HTTP client’s response timeout (Refer to <a href="/docs/reference/elasticsearch/configuration-reference/networking-settings#_http_client_configuration">HTTP client configuration</a>)</p>\n<p><strong>Examples</strong> Rerank search results using a simple query and a single field:</p>\n<pre class="esql"><code>FROM books METADATA _score\n| WHERE MATCH(description, &quot;hobbit&quot;)\n| SORT _score DESC\n| LIMIT 100\n| RERANK &quot;hobbit&quot; ON description WITH { &quot;inference_id&quot; : &quot;test_reranker&quot; }\n| LIMIT 3\n| KEEP title, _score</code></pre>\n<table>\n<colgroup>\n<col style="width: 80%" />\n<col style="width: 19%" />\n</colgroup>\n<thead>\n<tr class="header">\n<th>title:text</th>\n<th>_score:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>Poems from the Hobbit</td>\n<td>0.0015673980815336108</td>\n</tr>\n<tr class="even">\n<td>A Tolkien Compass: Including J. R. R. Tolkien’s Guide to the Names in The Lord of the Rings</td>\n<td>0.007936508394777775</td>\n</tr>\n<tr class="odd">\n<td>Return of the King Being the Third Part of The Lord of the Rings</td>\n<td>9.960159659385681E-4</td>\n</tr>\n</tbody>\n</table>\n<p>Rerank search results using a query and multiple fields, and store the new score in a column named <code>rerank_score</code>:</p>\n<pre class="esql"><code>FROM books METADATA _score\n| WHERE MATCH(description, &quot;hobbit&quot;) OR MATCH(author, &quot;Tolkien&quot;)\n| SORT _score DESC\n| LIMIT 100\n| RERANK rerank_score = &quot;hobbit&quot; ON description, author WITH { &quot;inference_id&quot; : &quot;test_reranker&quot; }\n| SORT rerank_score\n| LIMIT 3\n| KEEP title, _score, rerank_score</code></pre>\n<table>\n<colgroup>\n<col style="width: 61%" />\n<col style="width: 18%" />\n<col style="width: 20%" />\n</colgroup>\n<thead>\n<tr class="header">\n<th>title:text</th>\n<th>_score:double</th>\n<th>rerank_score:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>Return of the Shadow</td>\n<td>2.8181066513061523</td>\n<td>5.740527994930744E-4</td>\n</tr>\n<tr class="even">\n<td>Return of the King Being the Third Part of The Lord of the Rings</td>\n<td>3.6248698234558105</td>\n<td>9.000900317914784E-4</td>\n</tr>\n<tr class="odd">\n<td>The Lays of Beleriand</td>\n<td>1.3002015352249146</td>\n<td>9.36329597607255E-4</td>\n</tr>\n</tbody>\n</table>\n<p>Combine the original score with the reranked score:</p>\n<pre class="esql"><code>FROM books METADATA _score\n| WHERE MATCH(description, &quot;hobbit&quot;) OR MATCH(author, &quot;Tolkien&quot;)\n| SORT _score DESC\n| LIMIT 100\n| RERANK rerank_score = &quot;hobbit&quot; ON description, author WITH { &quot;inference_id&quot; : &quot;test_reranker&quot; }\n| EVAL original_score = _score, _score = rerank_score + original_score\n| SORT _score\n| LIMIT 3\n| KEEP title, original_score, rerank_score, _score</code></pre>\n<table>\n<colgroup>\n<col style="width: 50%" />\n<col style="width: 15%" />\n<col style="width: 17%" />\n<col style="width: 16%" />\n</colgroup>\n<thead>\n<tr class="header">\n<th>title:text</th>\n<th>_score:double</th>\n<th>rerank_score:double</th>\n<th>rerank_score:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>Poems from the Hobbit</td>\n<td>4.012462615966797</td>\n<td>0.001396648003719747</td>\n<td>0.001396648003719747</td>\n</tr>\n<tr class="even">\n<td>The Lord of the Rings - Boxed Set</td>\n<td>3.768855094909668</td>\n<td>0.0010020040208473802</td>\n<td>0.001396648003719747</td>\n</tr>\n<tr class="odd">\n<td>Return of the King Being the Third Part of The Lord of the Rings</td>\n<td>3.6248698234558105</td>\n<td>9.000900317914784E-4</td>\n<td>0.001396648003719747</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("ltrim", """
<h2 id="ltrim"><code>LTRIM</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/ltrim.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="string"> String expression. If <code>null</code>, the function returns <code>null</code>. </definition> </definitions></p>\n<p><strong>Description</strong> Removes leading whitespaces from a string. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>string</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>keyword</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW message = &quot;   some text  &quot;,  color = &quot; red &quot;\n| EVAL message = LTRIM(message)\n| EVAL color = LTRIM(color)\n| EVAL message = CONCAT(&quot;&#39;&quot;, message, &quot;&#39;&quot;)\n| EVAL color = CONCAT(&quot;&#39;&quot;, color, &quot;&#39;&quot;)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>message:keyword</th>\n<th>color:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>‘some text’</td>\n<td>‘red’</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("change-point", """
<h1 id="change_point">CHANGE_POINT</h1>\n<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="fu">serverless</span><span class="kw">:</span><span class="at"> preview</span></span>\n<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="fu">stack</span><span class="kw">:</span><span class="at"> preview 9.1.0</span></span></code></pre></div>\n<note>\nThe <code>CHANGE_POINT</code> command requires a <a href="https://www.elastic.co/subscriptions">platinum license</a>.\n</note>\n<p><code>CHANGE_POINT</code> detects spikes, dips, and change points in a metric. <strong>Syntax</strong></p>\n<pre class="esql"><code>CHANGE_POINT value [ON key] [AS type_name, pvalue_name]</code></pre>\n<p><strong>Parameters</strong> <definitions> <definition term="value"> The column with the metric in which you want to detect a change point. </definition> <definition term="key"> The column with the key to order the values by. If not specified, <code>@timestamp</code> is used. </definition> <definition term="type_name"> The name of the output column with the change point type. If not specified, <code>type</code> is used. </definition> <definition term="pvalue_name"> The name of the output column with the p-value that indicates how extreme the change point is. If not specified, <code>pvalue</code> is used. </definition> </definitions></p>\n<p><strong>Description</strong> <code>CHANGE_POINT</code> detects spikes, dips, and change points in a metric. The command adds columns to the table with the change point type and p-value, that indicates how extreme the change point is (lower values indicate greater changes). The possible change point types are: - <code>dip</code>: a significant dip occurs at this change point - <code>distribution_change</code>: the overall distribution of the values has changed significantly - <code>spike</code>: a significant spike occurs at this point - <code>step_change</code>: the change indicates a statistically significant step up or down in value distribution - <code>trend_change</code>: there is an overall trend change occurring at this point</p>\n<note>\nThere must be at least 22 values for change point detection. Fewer than 1,000 is preferred.\n</note>\n<p><strong>Examples</strong> The following example shows the detection of a step change:</p>\n<pre class="esql"><code>ROW key=[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]\n| MV_EXPAND key\n| EVAL value = CASE(key&lt;13, 0, 42)\n| CHANGE_POINT value ON key\n| WHERE type IS NOT NULL</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>key:integer</th>\n<th>value:integer</th>\n<th>type:keyword</th>\n<th>pvalue:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>13</td>\n<td>42</td>\n<td>step_change</td>\n<td>0.0</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("to_lower", """
<h2 id="to_lower"><code>TO_LOWER</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/to_lower.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="str"> String expression. If <code>null</code>, the function returns <code>null</code>. The input can be a single-valued column or expression, or a multi-valued column or expression <code>stack: ga 9.1.0</code>. </definition> </definitions></p>\n<p><strong>Description</strong> Returns a new string representing the input string converted to lower case. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>str</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>keyword</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Examples</strong></p>\n<pre class="esql"><code>ROW message = &quot;Some Text&quot;\n| EVAL message_lower = TO_LOWER(message)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>message:keyword</th>\n<th>message_lower:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>Some Text</td>\n<td>some text</td>\n</tr>\n</tbody>\n</table>\n<pre><code>stack: ga 9.1.0</code></pre>\n<pre class="esql"><code>ROW v = TO_LOWER([&quot;Some&quot;, &quot;Text&quot;])</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>v:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>[“some”, “text”]</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("ends_with", """
<h2 id="ends_with"><code>ENDS_WITH</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/ends_with.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="str"> String expression. If <code>null</code>, the function returns <code>null</code>. </definition> <definition term="suffix"> String expression. If <code>null</code>, the function returns <code>null</code>. </definition> </definitions></p>\n<p><strong>Description</strong> Returns a boolean that indicates whether a keyword string ends with another string. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>str</th>\n<th>suffix</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>keyword</td>\n<td>keyword</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>text</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>keyword</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>text</td>\n<td>boolean</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>FROM employees\n| KEEP last_name\n| EVAL ln_E = ENDS_WITH(last_name, &quot;d&quot;)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>last_name:keyword</th>\n<th>ln_E:boolean</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>Awdeh</td>\n<td>false</td>\n</tr>\n<tr class="even">\n<td>Azuma</td>\n<td>false</td>\n</tr>\n<tr class="odd">\n<td>Baek</td>\n<td>false</td>\n</tr>\n<tr class="even">\n<td>Bamford</td>\n<td>true</td>\n</tr>\n<tr class="odd">\n<td>Bernatsky</td>\n<td>false</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("to_geohash", """
<h2 id="to_geohash"><code>TO_GEOHASH</code></h2>\n<pre><code>stack: preview\nserverless: preview</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/to_geohash.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> Input value. The input can be a single- or multi-valued column or an expression. </definition> </definitions></p>\n<p><strong>Description</strong> Converts an input value to a <code>geohash</code> value. A string will only be successfully converted if it respects the <code>geohash</code> format, as described for the <a href="https://www.elastic.co/docs/reference/aggregations/search-aggregations-bucket-geohashgrid-aggregation">geohash grid aggregation</a>. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>geohash</td>\n<td>geohash</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>geohash</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>geohash</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>geohash</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW string = &quot;u3bu&quot;\n| EVAL geohash = TO_GEOHASH(string)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>string:keyword</th>\n<th>geohash:geohash</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>u3bu</td>\n<td>u3bu</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("acos", """
<h2 id="acos"><code>ACOS</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/acos.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="number"> Number between -1 and 1. If <code>null</code>, the function returns <code>null</code>. </definition> </definitions></p>\n<p><strong>Description</strong> Returns the <a href="https://en.wikipedia.org/wiki/Inverse_trigonometric_functions">arccosine</a> of <code>n</code> as an angle, expressed in radians. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>number</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW a=.9\n| EVAL acos=ACOS(a)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:double</th>\n<th>acos:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>.9</td>\n<td>0.45102681179626236</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("to_version", """
<h2 id="to_version"><code>TO_VERSION</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/to_version.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> Input value. The input can be a single- or multi-valued column or an expression. </definition> </definitions></p>\n<p><strong>Description</strong> Converts an input string to a version value. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>keyword</td>\n<td>version</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>version</td>\n</tr>\n<tr class="odd">\n<td>version</td>\n<td>version</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW v = TO_VERSION(&quot;1.2.3&quot;)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>v:version</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>1.2.3</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("mv_pseries_weighted_sum", """
<h2 id="mv_pseries_weighted_sum"><code>MV_PSERIES_WEIGHTED_SUM</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/mv_pseries_weighted_sum.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="number"> Multivalue expression. </definition> <definition term="p"> It is a constant number that represents the <em>p</em> parameter in the P-Series. It impacts every element’s contribution to the weighted sum. </definition> </definitions></p>\n<p><strong>Description</strong> Converts a multivalued expression into a single-valued column by multiplying every element on the input list by its corresponding term in P-Series and computing the sum. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>number</th>\n<th>p</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW a = [70.0, 45.0, 21.0, 21.0, 21.0]\n| EVAL sum = MV_PSERIES_WEIGHTED_SUM(a, 1.5)\n| KEEP sum</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>sum:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>94.45465156212452</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("bucket", """
<h2 id="bucket"><code>BUCKET</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/bucket.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> Numeric or date expression from which to derive buckets. </definition> <definition term="buckets"> Target number of buckets, or desired bucket size if <code>from</code> and <code>to</code> parameters are omitted. </definition> <definition term="from"> Start of the range. Can be a number, a date or a date expressed as a string. </definition> <definition term="to"> End of the range. Can be a number, a date or a date expressed as a string. </definition> </definitions></p>\n<p><strong>Description</strong> Creates groups of values - buckets - out of a datetime or numeric input. The size of the buckets can either be provided directly, or chosen based on a recommended count and values range. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>buckets</th>\n<th>from</th>\n<th>to</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>date</td>\n<td>date_period</td>\n<td></td>\n<td></td>\n<td>date</td>\n</tr>\n<tr class="even">\n<td>date</td>\n<td>integer</td>\n<td>date</td>\n<td>date</td>\n<td>date</td>\n</tr>\n<tr class="odd">\n<td>date</td>\n<td>integer</td>\n<td>date</td>\n<td>keyword</td>\n<td>date</td>\n</tr>\n<tr class="even">\n<td>date</td>\n<td>integer</td>\n<td>date</td>\n<td>text</td>\n<td>date</td>\n</tr>\n<tr class="odd">\n<td>date</td>\n<td>integer</td>\n<td>keyword</td>\n<td>date</td>\n<td>date</td>\n</tr>\n<tr class="even">\n<td>date</td>\n<td>integer</td>\n<td>keyword</td>\n<td>keyword</td>\n<td>date</td>\n</tr>\n<tr class="odd">\n<td>date</td>\n<td>integer</td>\n<td>keyword</td>\n<td>text</td>\n<td>date</td>\n</tr>\n<tr class="even">\n<td>date</td>\n<td>integer</td>\n<td>text</td>\n<td>date</td>\n<td>date</td>\n</tr>\n<tr class="odd">\n<td>date</td>\n<td>integer</td>\n<td>text</td>\n<td>keyword</td>\n<td>date</td>\n</tr>\n<tr class="even">\n<td>date</td>\n<td>integer</td>\n<td>text</td>\n<td>text</td>\n<td>date</td>\n</tr>\n<tr class="odd">\n<td>date</td>\n<td>time_duration</td>\n<td></td>\n<td></td>\n<td>date</td>\n</tr>\n<tr class="even">\n<td>date_nanos</td>\n<td>date_period</td>\n<td></td>\n<td></td>\n<td>date_nanos</td>\n</tr>\n<tr class="odd">\n<td>date_nanos</td>\n<td>integer</td>\n<td>date</td>\n<td>date</td>\n<td>date_nanos</td>\n</tr>\n<tr class="even">\n<td>date_nanos</td>\n<td>integer</td>\n<td>date</td>\n<td>keyword</td>\n<td>date_nanos</td>\n</tr>\n<tr class="odd">\n<td>date_nanos</td>\n<td>integer</td>\n<td>date</td>\n<td>text</td>\n<td>date_nanos</td>\n</tr>\n<tr class="even">\n<td>date_nanos</td>\n<td>integer</td>\n<td>keyword</td>\n<td>date</td>\n<td>date_nanos</td>\n</tr>\n<tr class="odd">\n<td>date_nanos</td>\n<td>integer</td>\n<td>keyword</td>\n<td>keyword</td>\n<td>date_nanos</td>\n</tr>\n<tr class="even">\n<td>date_nanos</td>\n<td>integer</td>\n<td>keyword</td>\n<td>text</td>\n<td>date_nanos</td>\n</tr>\n<tr class="odd">\n<td>date_nanos</td>\n<td>integer</td>\n<td>text</td>\n<td>date</td>\n<td>date_nanos</td>\n</tr>\n<tr class="even">\n<td>date_nanos</td>\n<td>integer</td>\n<td>text</td>\n<td>keyword</td>\n<td>date_nanos</td>\n</tr>\n<tr class="odd">\n<td>date_nanos</td>\n<td>integer</td>\n<td>text</td>\n<td>text</td>\n<td>date_nanos</td>\n</tr>\n<tr class="even">\n<td>date_nanos</td>\n<td>time_duration</td>\n<td></td>\n<td></td>\n<td>date_nanos</td>\n</tr>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n<td></td>\n<td></td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>integer</td>\n<td>double</td>\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>double</td>\n<td>integer</td>\n<td>double</td>\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>integer</td>\n<td>double</td>\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>double</td>\n<td>integer</td>\n<td>integer</td>\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>integer</td>\n<td>integer</td>\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>double</td>\n<td>integer</td>\n<td>integer</td>\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>integer</td>\n<td>long</td>\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>double</td>\n<td>integer</td>\n<td>long</td>\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>integer</td>\n<td>long</td>\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>double</td>\n<td>integer</td>\n<td></td>\n<td></td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>long</td>\n<td></td>\n<td></td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>double</td>\n<td></td>\n<td></td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>integer</td>\n<td>double</td>\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>integer</td>\n<td>double</td>\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>integer</td>\n<td>double</td>\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>integer</td>\n<td>integer</td>\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>integer</td>\n<td>integer</td>\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>integer</td>\n<td>integer</td>\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>integer</td>\n<td>long</td>\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>integer</td>\n<td>long</td>\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>integer</td>\n<td>long</td>\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>integer</td>\n<td></td>\n<td></td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>long</td>\n<td></td>\n<td></td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>double</td>\n<td></td>\n<td></td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>integer</td>\n<td>double</td>\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>integer</td>\n<td>double</td>\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>integer</td>\n<td>double</td>\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>integer</td>\n<td>integer</td>\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>integer</td>\n<td>integer</td>\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>integer</td>\n<td>integer</td>\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>integer</td>\n<td>long</td>\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>integer</td>\n<td>long</td>\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>integer</td>\n<td>long</td>\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>integer</td>\n<td></td>\n<td></td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>long</td>\n<td></td>\n<td></td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Examples</strong> <code>BUCKET</code> can work in two modes: one in which the size of the bucket is computed based on a buckets count recommendation (four parameters) and a range, and another in which the bucket size is provided directly (two parameters). Using a target number of buckets, a start of a range, and an end of a range, <code>BUCKET</code> picks an appropriate bucket size to generate the target number of buckets or fewer. For example, asking for at most 20 buckets over a year results in monthly buckets:</p>\n<pre class="esql"><code>FROM employees\n| WHERE hire_date &gt;= &quot;1985-01-01T00:00:00Z&quot; AND hire_date &lt; &quot;1986-01-01T00:00:00Z&quot;\n| STATS hire_date = MV_SORT(VALUES(hire_date)) BY month = BUCKET(hire_date, 20, &quot;1985-01-01T00:00:00Z&quot;, &quot;1986-01-01T00:00:00Z&quot;)</code></pre>\n<table>\n<colgroup>\n<col style="width: 75%" />\n<col style="width: 24%" />\n</colgroup>\n<thead>\n<tr class="header">\n<th>hire_date:date</th>\n<th>month:date</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>[1985-02-18T00:00:00.000Z, 1985-02-24T00:00:00.000Z]</td>\n<td>1985-02-01T00:00:00.000Z</td>\n</tr>\n<tr class="even">\n<td>1985-05-13T00:00:00.000Z</td>\n<td>1985-05-01T00:00:00.000Z</td>\n</tr>\n<tr class="odd">\n<td>1985-07-09T00:00:00.000Z</td>\n<td>1985-07-01T00:00:00.000Z</td>\n</tr>\n<tr class="even">\n<td>1985-09-17T00:00:00.000Z</td>\n<td>1985-09-01T00:00:00.000Z</td>\n</tr>\n<tr class="odd">\n<td>[1985-10-14T00:00:00.000Z, 1985-10-20T00:00:00.000Z]</td>\n<td>1985-10-01T00:00:00.000Z</td>\n</tr>\n<tr class="even">\n<td>[1985-11-19T00:00:00.000Z, 1985-11-20T00:00:00.000Z, 1985-11-21T00:00:00.000Z]</td>\n<td>1985-11-01T00:00:00.000Z</td>\n</tr>\n</tbody>\n</table>\n<p>The goal isn’t to provide <strong>exactly</strong> the target number of buckets, it’s to pick a range that people are comfortable with that provides at most the target number of buckets. Combine <code>BUCKET</code> with an <a href="https://www.elastic.co/docs/reference/query-languages/esql/functions-operators/aggregation-functions">aggregation</a> to create a histogram:</p>\n<pre class="esql"><code>FROM employees\n| WHERE hire_date &gt;= &quot;1985-01-01T00:00:00Z&quot; AND hire_date &lt; &quot;1986-01-01T00:00:00Z&quot;\n| STATS hires_per_month = COUNT(*) BY month = BUCKET(hire_date, 20, &quot;1985-01-01T00:00:00Z&quot;, &quot;1986-01-01T00:00:00Z&quot;)\n| SORT month</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>hires_per_month:long</th>\n<th>month:date</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>2</td>\n<td>1985-02-01T00:00:00.000Z</td>\n</tr>\n<tr class="even">\n<td>1</td>\n<td>1985-05-01T00:00:00.000Z</td>\n</tr>\n<tr class="odd">\n<td>1</td>\n<td>1985-07-01T00:00:00.000Z</td>\n</tr>\n<tr class="even">\n<td>1</td>\n<td>1985-09-01T00:00:00.000Z</td>\n</tr>\n<tr class="odd">\n<td>2</td>\n<td>1985-10-01T00:00:00.000Z</td>\n</tr>\n<tr class="even">\n<td>4</td>\n<td>1985-11-01T00:00:00.000Z</td>\n</tr>\n</tbody>\n</table>\n<note>\n<code>BUCKET</code> does not create buckets that don’t match any documents. That’s why this example is missing <code>1985-03-01</code> and other dates.\n</note>\n<p>Asking for more buckets can result in a smaller range. For example, asking for at most 100 buckets in a year results in weekly buckets:</p>\n<pre class="esql"><code>FROM employees\n| WHERE hire_date &gt;= &quot;1985-01-01T00:00:00Z&quot; AND hire_date &lt; &quot;1986-01-01T00:00:00Z&quot;\n| STATS hires_per_week = COUNT(*) BY week = BUCKET(hire_date, 100, &quot;1985-01-01T00:00:00Z&quot;, &quot;1986-01-01T00:00:00Z&quot;)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>hires_per_week:long</th>\n<th>week:date</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>2</td>\n<td>1985-02-18T00:00:00.000Z</td>\n</tr>\n<tr class="even">\n<td>1</td>\n<td>1985-05-13T00:00:00.000Z</td>\n</tr>\n<tr class="odd">\n<td>1</td>\n<td>1985-07-08T00:00:00.000Z</td>\n</tr>\n<tr class="even">\n<td>1</td>\n<td>1985-09-16T00:00:00.000Z</td>\n</tr>\n<tr class="odd">\n<td>2</td>\n<td>1985-10-14T00:00:00.000Z</td>\n</tr>\n<tr class="even">\n<td>4</td>\n<td>1985-11-18T00:00:00.000Z</td>\n</tr>\n</tbody>\n</table>\n<note>\n<code>BUCKET</code> does not filter any rows. It only uses the provided range to pick a good bucket size. For rows with a value outside of the range, it returns a bucket value that corresponds to a bucket outside the range. Combine <code>BUCKET</code> with <a href="https://www.elastic.co/docs/reference/query-languages/esql/commands/where"><code>WHERE</code></a> to filter rows.\n</note>\n<p>If the desired bucket size is known in advance, simply provide it as the second argument, leaving the range out:</p>\n<pre class="esql"><code>FROM employees\n| WHERE hire_date &gt;= &quot;1985-01-01T00:00:00Z&quot; AND hire_date &lt; &quot;1986-01-01T00:00:00Z&quot;\n| STATS hires_per_week = COUNT(*) BY week = BUCKET(hire_date, 1 week)\n| SORT week</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>hires_per_week:long</th>\n<th>week:date</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>2</td>\n<td>1985-02-18T00:00:00.000Z</td>\n</tr>\n<tr class="even">\n<td>1</td>\n<td>1985-05-13T00:00:00.000Z</td>\n</tr>\n<tr class="odd">\n<td>1</td>\n<td>1985-07-08T00:00:00.000Z</td>\n</tr>\n<tr class="even">\n<td>1</td>\n<td>1985-09-16T00:00:00.000Z</td>\n</tr>\n<tr class="odd">\n<td>2</td>\n<td>1985-10-14T00:00:00.000Z</td>\n</tr>\n<tr class="even">\n<td>4</td>\n<td>1985-11-18T00:00:00.000Z</td>\n</tr>\n</tbody>\n</table>\n<note>\nWhen providing the bucket size as the second parameter, it must be a time duration or date period. Also the reference is epoch, which starts at <code>0001-01-01T00:00:00Z</code>.\n</note>\n<p><code>BUCKET</code> can also operate on numeric fields. For example, to create a salary histogram:</p>\n<pre class="esql"><code>FROM employees\n| STATS COUNT(*) by bs = BUCKET(salary, 20, 25324, 74999)\n| SORT bs</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>COUNT(*):long</th>\n<th>bs:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>9</td>\n<td>25000.0</td>\n</tr>\n<tr class="even">\n<td>9</td>\n<td>30000.0</td>\n</tr>\n<tr class="odd">\n<td>18</td>\n<td>35000.0</td>\n</tr>\n<tr class="even">\n<td>11</td>\n<td>40000.0</td>\n</tr>\n<tr class="odd">\n<td>11</td>\n<td>45000.0</td>\n</tr>\n<tr class="even">\n<td>10</td>\n<td>50000.0</td>\n</tr>\n<tr class="odd">\n<td>7</td>\n<td>55000.0</td>\n</tr>\n<tr class="even">\n<td>9</td>\n<td>60000.0</td>\n</tr>\n<tr class="odd">\n<td>8</td>\n<td>65000.0</td>\n</tr>\n<tr class="even">\n<td>8</td>\n<td>70000.0</td>\n</tr>\n</tbody>\n</table>\n<p>Unlike the earlier example that intentionally filters on a date range, you rarely want to filter on a numeric range. You have to find the <code>min</code> and <code>max</code> separately. ES|QL doesn’t yet have an easy way to do that automatically. The range can be omitted if the desired bucket size is known in advance. Simply provide it as the second argument:</p>\n<pre class="esql"><code>FROM employees\n| WHERE hire_date &gt;= &quot;1985-01-01T00:00:00Z&quot; AND hire_date &lt; &quot;1986-01-01T00:00:00Z&quot;\n| STATS c = COUNT(1) BY b = BUCKET(salary, 5000.)\n| SORT b</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>c:long</th>\n<th>b:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>1</td>\n<td>25000.0</td>\n</tr>\n<tr class="even">\n<td>1</td>\n<td>30000.0</td>\n</tr>\n<tr class="odd">\n<td>1</td>\n<td>40000.0</td>\n</tr>\n<tr class="even">\n<td>2</td>\n<td>45000.0</td>\n</tr>\n<tr class="odd">\n<td>2</td>\n<td>50000.0</td>\n</tr>\n<tr class="even">\n<td>1</td>\n<td>55000.0</td>\n</tr>\n<tr class="odd">\n<td>1</td>\n<td>60000.0</td>\n</tr>\n<tr class="even">\n<td>1</td>\n<td>65000.0</td>\n</tr>\n<tr class="odd">\n<td>1</td>\n<td>70000.0</td>\n</tr>\n</tbody>\n</table>\n<p>Create hourly buckets for the last 24 hours, and calculate the number of events per hour:</p>\n<pre class="esql"><code>FROM sample_data\n| WHERE @timestamp &gt;= NOW() - 1 day and @timestamp &lt; NOW()\n| STATS COUNT(*) BY bucket = BUCKET(@timestamp, 25, NOW() - 1 day, NOW())</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>COUNT(*):long</th>\n<th>bucket:date</th>\n</tr>\n</thead>\n<tbody>\n</tbody>\n</table>\n<p>Create monthly buckets for the year 1985, and calculate the average salary by hiring month</p>\n<pre class="esql"><code>FROM employees\n| WHERE hire_date &gt;= &quot;1985-01-01T00:00:00Z&quot; AND hire_date &lt; &quot;1986-01-01T00:00:00Z&quot;\n| STATS AVG(salary) BY bucket = BUCKET(hire_date, 20, &quot;1985-01-01T00:00:00Z&quot;, &quot;1986-01-01T00:00:00Z&quot;)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>AVG(salary):double</th>\n<th>bucket:date</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>46305.0</td>\n<td>1985-02-01T00:00:00.000Z</td>\n</tr>\n<tr class="even">\n<td>44817.0</td>\n<td>1985-05-01T00:00:00.000Z</td>\n</tr>\n<tr class="odd">\n<td>62405.0</td>\n<td>1985-07-01T00:00:00.000Z</td>\n</tr>\n<tr class="even">\n<td>49095.0</td>\n<td>1985-09-01T00:00:00.000Z</td>\n</tr>\n<tr class="odd">\n<td>51532.0</td>\n<td>1985-10-01T00:00:00.000Z</td>\n</tr>\n<tr class="even">\n<td>54539.75</td>\n<td>1985-11-01T00:00:00.000Z</td>\n</tr>\n</tbody>\n</table>\n<p><code>BUCKET</code> may be used in both the aggregating and grouping part of the <a href="https://www.elastic.co/docs/reference/query-languages/esql/commands/stats-by">STATS … BY …</a> command provided that in the aggregating part the function is referenced by an alias defined in the grouping part, or that it is invoked with the exact same expression:</p>\n<pre class="esql"><code>FROM employees\n| STATS s1 = b1 + 1, s2 = BUCKET(salary / 1000 + 999, 50.) + 2 BY b1 = BUCKET(salary / 100 + 99, 50.), b2 = BUCKET(salary / 1000 + 999, 50.)\n| SORT b1, b2\n| KEEP s1, b1, s2, b2</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>s1:double</th>\n<th>b1:double</th>\n<th>s2:double</th>\n<th>b2:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>351.0</td>\n<td>350.0</td>\n<td>1002.0</td>\n<td>1000.0</td>\n</tr>\n<tr class="even">\n<td>401.0</td>\n<td>400.0</td>\n<td>1002.0</td>\n<td>1000.0</td>\n</tr>\n<tr class="odd">\n<td>451.0</td>\n<td>450.0</td>\n<td>1002.0</td>\n<td>1000.0</td>\n</tr>\n<tr class="even">\n<td>501.0</td>\n<td>500.0</td>\n<td>1002.0</td>\n<td>1000.0</td>\n</tr>\n<tr class="odd">\n<td>551.0</td>\n<td>550.0</td>\n<td>1002.0</td>\n<td>1000.0</td>\n</tr>\n<tr class="even">\n<td>601.0</td>\n<td>600.0</td>\n<td>1002.0</td>\n<td>1000.0</td>\n</tr>\n<tr class="odd">\n<td>601.0</td>\n<td>600.0</td>\n<td>1052.0</td>\n<td>1050.0</td>\n</tr>\n<tr class="even">\n<td>651.0</td>\n<td>650.0</td>\n<td>1052.0</td>\n<td>1050.0</td>\n</tr>\n<tr class="odd">\n<td>701.0</td>\n<td>700.0</td>\n<td>1052.0</td>\n<td>1050.0</td>\n</tr>\n<tr class="even">\n<td>751.0</td>\n<td>750.0</td>\n<td>1052.0</td>\n<td>1050.0</td>\n</tr>\n<tr class="odd">\n<td>801.0</td>\n<td>800.0</td>\n<td>1052.0</td>\n<td>1050.0</td>\n</tr>\n</tbody>\n</table>\n<p>Sometimes you need to change the start value of each bucket by a given duration (similar to date histogram aggregation’s <a href="https://www.elastic.co/docs/reference/aggregations/search-aggregations-bucket-histogram-aggregation"><code>offset</code></a> parameter). To do so, you will need to take into account how the language handles expressions within the <code>STATS</code> command: if these contain functions or arithmetic operators, a virtual <code>EVAL</code> is inserted before and/or after the <code>STATS</code> command. Consequently, a double compensation is needed to adjust the bucketed date value before the aggregation and then again after. For instance, inserting a negative offset of <code>1 hour</code> to buckets of <code>1 year</code> looks like this:</p>\n<pre class="esql"><code>FROM employees\n| STATS dates = MV_SORT(VALUES(birth_date)) BY b = BUCKET(birth_date + 1 HOUR, 1 YEAR) - 1 HOUR\n| EVAL d_count = MV_COUNT(dates)</code></pre>\n<table>\n<colgroup>\n<col style="width: 71%" />\n<col style="width: 17%" />\n<col style="width: 11%" />\n</colgroup>\n<thead>\n<tr class="header">\n<th>dates:date</th>\n<th>b:date</th>\n<th>d_count:integer</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>1965-01-03T00:00:00.000Z</td>\n<td>1964-12-31T23:00:00.000Z</td>\n<td>1</td>\n</tr>\n<tr class="even">\n<td>[1955-01-21T00:00:00.000Z, 1955-08-20T00:00:00.000Z, 1955-08-28T00:00:00.000Z, 1955-10-04T00:00:00.000Z]</td>\n<td>1954-12-31T23:00:00.000Z</td>\n<td>4</td>\n</tr>\n<tr class="odd">\n<td>[1957-04-04T00:00:00.000Z, 1957-05-23T00:00:00.000Z, 1957-05-25T00:00:00.000Z, 1957-12-03T00:00:00.000Z]</td>\n<td>1956-12-31T23:00:00.000Z</td>\n<td>4</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("log10", """
<h2 id="log10"><code>LOG10</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/log10.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="number"> Numeric expression. If <code>null</code>, the function returns <code>null</code>. </definition> </definitions></p>\n<p><strong>Description</strong> Returns the logarithm of a value to base 10. The input can be any numeric value, the return value is always a double. Logs of 0 and negative numbers return <code>null</code> as well as a warning. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>number</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW d = 1000.0\n| EVAL s = LOG10(d)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>d: double</th>\n<th>s:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>1000.0</td>\n<td>3.0</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("date_trunc", """
<h2 id="date_trunc"><code>DATE_TRUNC</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/date_trunc.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="interval"> Interval; expressed using the timespan literal syntax. </definition> <definition term="date"> Date expression </definition> </definitions></p>\n<p><strong>Description</strong> Rounds down a date to the closest interval since epoch, which starts at <code>0001-01-01T00:00:00Z</code>. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>interval</th>\n<th>date</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>date_period</td>\n<td>date</td>\n<td>date</td>\n</tr>\n<tr class="even">\n<td>date_period</td>\n<td>date_nanos</td>\n<td>date_nanos</td>\n</tr>\n<tr class="odd">\n<td>time_duration</td>\n<td>date</td>\n<td>date</td>\n</tr>\n<tr class="even">\n<td>time_duration</td>\n<td>date_nanos</td>\n<td>date_nanos</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Examples</strong></p>\n<pre class="esql"><code>FROM employees\n| KEEP first_name, last_name, hire_date\n| EVAL year_hired = DATE_TRUNC(1 year, hire_date)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>first_name:keyword</th>\n<th>last_name:keyword</th>\n<th>hire_date:date</th>\n<th>year_hired:date</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>Alejandro</td>\n<td>McAlpine</td>\n<td>1991-06-26T00:00:00.000Z</td>\n<td>1991-01-01T00:00:00.000Z</td>\n</tr>\n<tr class="even">\n<td>Amabile</td>\n<td>Gomatam</td>\n<td>1992-11-18T00:00:00.000Z</td>\n<td>1992-01-01T00:00:00.000Z</td>\n</tr>\n<tr class="odd">\n<td>Anneke</td>\n<td>Preusig</td>\n<td>1989-06-02T00:00:00.000Z</td>\n<td>1989-01-01T00:00:00.000Z</td>\n</tr>\n</tbody>\n</table>\n<p>Combine <code>DATE_TRUNC</code> with <a href="https://www.elastic.co/docs/reference/query-languages/esql/commands/stats-by"><code>STATS</code></a> to create date histograms. For example, the number of hires per year:</p>\n<pre class="esql"><code>FROM employees\n| EVAL year = DATE_TRUNC(1 year, hire_date)\n| STATS hires = COUNT(emp_no) BY year\n| SORT year</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>hires:long</th>\n<th>year:date</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>11</td>\n<td>1985-01-01T00:00:00.000Z</td>\n</tr>\n<tr class="even">\n<td>11</td>\n<td>1986-01-01T00:00:00.000Z</td>\n</tr>\n<tr class="odd">\n<td>15</td>\n<td>1987-01-01T00:00:00.000Z</td>\n</tr>\n<tr class="even">\n<td>9</td>\n<td>1988-01-01T00:00:00.000Z</td>\n</tr>\n<tr class="odd">\n<td>13</td>\n<td>1989-01-01T00:00:00.000Z</td>\n</tr>\n<tr class="even">\n<td>12</td>\n<td>1990-01-01T00:00:00.000Z</td>\n</tr>\n<tr class="odd">\n<td>6</td>\n<td>1991-01-01T00:00:00.000Z</td>\n</tr>\n<tr class="even">\n<td>8</td>\n<td>1992-01-01T00:00:00.000Z</td>\n</tr>\n<tr class="odd">\n<td>3</td>\n<td>1993-01-01T00:00:00.000Z</td>\n</tr>\n<tr class="even">\n<td>4</td>\n<td>1994-01-01T00:00:00.000Z</td>\n</tr>\n<tr class="odd">\n<td>5</td>\n<td>1995-01-01T00:00:00.000Z</td>\n</tr>\n<tr class="even">\n<td>1</td>\n<td>1996-01-01T00:00:00.000Z</td>\n</tr>\n<tr class="odd">\n<td>1</td>\n<td>1997-01-01T00:00:00.000Z</td>\n</tr>\n<tr class="even">\n<td>1</td>\n<td>1999-01-01T00:00:00.000Z</td>\n</tr>\n</tbody>\n</table>\n<p>Or an hourly error rate:</p>\n<pre class="esql"><code>FROM sample_data\n| EVAL error = CASE(message LIKE &quot;*error*&quot;, 1, 0)\n| EVAL hour = DATE_TRUNC(1 hour, @timestamp)\n| STATS error_rate = AVG(error) by hour\n| SORT hour</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>error_rate:double</th>\n<th>hour:date</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>0.0</td>\n<td>2023-10-23T12:00:00.000Z</td>\n</tr>\n<tr class="even">\n<td>0.6</td>\n<td>2023-10-23T13:00:00.000Z</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("length", """
<h2 id="length"><code>LENGTH</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/length.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="string"> String expression. If <code>null</code>, the function returns <code>null</code>. </definition> </definitions></p>\n<strong>Description</strong> Returns the character length of a string.\n<note>\nAll strings are in UTF-8, so a single character can use multiple bytes.\n</note>\n<p><strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>string</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>keyword</td>\n<td>integer</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>integer</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>FROM airports\n| WHERE country == &quot;India&quot;\n| KEEP city\n| EVAL fn_length = LENGTH(city)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>city:keyword</th>\n<th>fn_length:integer</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>Agwār</td>\n<td>5</td>\n</tr>\n<tr class="even">\n<td>Ahmedabad</td>\n<td>9</td>\n</tr>\n<tr class="odd">\n<td>Bangalore</td>\n<td>9</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("to_upper", """
<h2 id="to_upper"><code>TO_UPPER</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/to_upper.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="str"> String expression. If <code>null</code>, the function returns <code>null</code>. The input can be a single-valued column or expression, or a multi-valued column or expression <code>stack: ga 9.1.0</code>. </definition> </definitions></p>\n<p><strong>Description</strong> Returns a new string representing the input string converted to upper case. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>str</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>keyword</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW message = &quot;Some Text&quot;\n| EVAL message_upper = TO_UPPER(message)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>message:keyword</th>\n<th>message_upper:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>Some Text</td>\n<td>SOME TEXT</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("st_within", """
<h2 id="st_within"><code>ST_WITHIN</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/st_within.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="geomA"> Expression of type <code>geo_point</code>, <code>cartesian_point</code>, <code>geo_shape</code> or <code>cartesian_shape</code>. If <code>null</code>, the function returns <code>null</code>. </definition> <definition term="geomB"> Expression of type <code>geo_point</code>, <code>cartesian_point</code>, <code>geo_shape</code> or <code>cartesian_shape</code>. If <code>null</code>, the function returns <code>null</code>. The second parameter must also have the same coordinate system as the first. This means it is not possible to combine <code>geo_*</code> and <code>cartesian_*</code> parameters. </definition> </definitions></p>\n<p><strong>Description</strong> Returns whether the first geometry is within the second geometry. This is the inverse of the <a href="#esql-st_contains">ST_CONTAINS</a> function. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>geomA</th>\n<th>geomB</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>cartesian_point</td>\n<td>cartesian_point</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>cartesian_point</td>\n<td>cartesian_shape</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>cartesian_shape</td>\n<td>cartesian_point</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>cartesian_shape</td>\n<td>cartesian_shape</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>geo_point</td>\n<td>geo_point</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>geo_point</td>\n<td>geo_shape</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>geo_shape</td>\n<td>geo_point</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>geo_shape</td>\n<td>geo_shape</td>\n<td>boolean</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>FROM airport_city_boundaries\n| WHERE ST_WITHIN(city_boundary, TO_GEOSHAPE(&quot;POLYGON((109.1 18.15, 109.6 18.15, 109.6 18.65, 109.1 18.65, 109.1 18.15))&quot;))\n| KEEP abbrev, airport, region, city, city_location</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>abbrev:keyword</th>\n<th>airport:text</th>\n<th>region:text</th>\n<th>city:keyword</th>\n<th>city_location:geo_point</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>SYX</td>\n<td>Sanya Phoenix Int’l</td>\n<td>天涯区</td>\n<td>Sanya</td>\n<td>POINT(109.5036 18.2533)</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("to_radians", """
<h2 id="to_radians"><code>TO_RADIANS</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/to_radians.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="number"> Input value. The input can be a single- or multi-valued column or an expression. </definition> </definitions></p>\n<p><strong>Description</strong> Converts a number in <a href="https://en.wikipedia.org/wiki/Degree_(angle)">degrees</a> to <a href="https://en.wikipedia.org/wiki/Radian">radians</a>. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>number</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW deg = [90.0, 180.0, 270.0]\n| EVAL rad = TO_RADIANS(deg)</code></pre>\n<table>\n<colgroup>\n<col style="width: 27%" />\n<col style="width: 72%" />\n</colgroup>\n<thead>\n<tr class="header">\n<th>deg:double</th>\n<th>rad:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>[90.0, 180.0, 270.0]</td>\n<td>[1.5707963267948966, 3.141592653589793, 4.71238898038469]</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("to_degrees", """
<h2 id="to_degrees"><code>TO_DEGREES</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/to_degrees.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="number"> Input value. The input can be a single- or multi-valued column or an expression. </definition> </definitions></p>\n<p><strong>Description</strong> Converts a number in <a href="https://en.wikipedia.org/wiki/Radian">radians</a> to <a href="https://en.wikipedia.org/wiki/Degree_(angle)">degrees</a>. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>number</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW rad = [1.57, 3.14, 4.71]\n| EVAL deg = TO_DEGREES(rad)</code></pre>\n<table>\n<colgroup>\n<col style="width: 25%" />\n<col style="width: 75%" />\n</colgroup>\n<thead>\n<tr class="header">\n<th>rad:double</th>\n<th>deg:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>[1.57, 3.14, 4.71]</td>\n<td>[89.95437383553924, 179.9087476710785, 269.86312150661774]</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("url_encode_component", """
<h2 id="url_encode_component"><code>URL_ENCODE_COMPONENT</code></h2>\n<pre><code>stack: ga 9.2.0</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/url_encode_component.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="string"> The URL to encode. </definition> </definitions></p>\n<p><strong>Description</strong> URL-encodes the input. All characters are <a href="https://en.wikipedia.org/wiki/Percent-encoding">percent-encoded</a> except for alphanumerics, <code>.</code>, <code>-</code>, <code>_</code>, and <code>~</code>. Spaces are encoded as <code>%20</code>. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>string</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>keyword</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW u = &quot;https://example.com/?x=foo bar&amp;y=baz&quot;\n| EVAL u = URL_ENCODE_COMPONENT(u)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>u:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>https%3A%2F%2Fexample.com%2F%3Fx%3Dfoo%20bar%26y%3Dbaz</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("mv_avg", """
<h2 id="mv_avg"><code>MV_AVG</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/mv_avg.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="number"> Multivalue expression. </definition> </definitions></p>\n<p><strong>Description</strong> Converts a multivalued field into a single valued field containing the average of all of the values. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>number</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW a=[3, 5, 1, 6]\n| EVAL avg_a = MV_AVG(a)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:integer</th>\n<th>avg_a:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>[3, 5, 1, 6]</td>\n<td>3.75</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("categorize", """
<h2 id="categorize"><code>CATEGORIZE</code></h2>\n<pre><code>stack: preview 9.0, ga 9.1</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/categorize.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> Expression to categorize </definition> <definition term="options"> (Optional) Categorize additional options as <a href="/docs/reference/query-languages/esql/esql-syntax#esql-function-named-params">function named parameters</a>. <code>stack: ga 9.2</code>} </definition> </definitions></p>\n<p><strong>Description</strong> Groups text messages into categories of similarly formatted text values. <code>CATEGORIZE</code> has the following limitations: - can’t be used within other expressions - can’t be used more than once in the groupings - can’t be used or referenced within aggregate functions and it has to be the first grouping</p>\n<p><strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>options</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>keyword</td>\n<td></td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td></td>\n<td>keyword</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Supported function named parameters</strong> <definitions> <definition term="output_format"> (keyword) The output format of the categories. Defaults to regex. </definition> <definition term="similarity_threshold"> (integer) The minimum percentage of token weight that must match for text to be added to the category bucket. Must be between 1 and 100. The larger the value the narrower the categories. Larger values will increase memory usage and create narrower categories. Defaults to 70. </definition> <definition term="analyzer"> (keyword) Analyzer used to convert the field into tokens for text categorization. </definition> </definitions></p>\n<p><strong>Example</strong> This example categorizes server logs messages into categories and aggregates their counts.</p>\n<pre class="esql"><code>FROM sample_data\n| STATS count=COUNT() BY category=CATEGORIZE(message)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>count:long</th>\n<th>category:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>3</td>\n<td>.<em>?Connected.+?to.</em>?</td>\n</tr>\n<tr class="even">\n<td>3</td>\n<td>.<em>?Connection.+?error.</em>?</td>\n</tr>\n<tr class="odd">\n<td>1</td>\n<td>.<em>?Disconnected.</em>?</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("rename", """
<h1 id="rename">RENAME</h1>\n<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="fu">serverless</span><span class="kw">:</span><span class="at"> ga</span></span>\n<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="fu">stack</span><span class="kw">:</span><span class="at"> ga</span></span></code></pre></div>\n<p>The <code>RENAME</code> processing command renames one or more columns. <strong>Syntax</strong></p>\n<pre class="esql"><code>RENAME old_name1 AS new_name1[, ..., old_nameN AS new_nameN]</code></pre>\n<p>The following syntax is also supported <code>stack: ga 9.1</code>:</p>\n<pre class="esql"><code>RENAME new_name1 = old_name1[, ..., new_nameN = old_nameN]</code></pre>\n<tip>\nBoth syntax options can be used interchangeably but we recommend sticking to one for consistency and readability.\n</tip>\n<p><strong>Parameters</strong> <definitions> <definition term="old_nameX"> The name of a column you want to rename. </definition> <definition term="new_nameX"> The new name of the column. If it conflicts with an existing column name, the existing column is dropped. If multiple columns are renamed to the same name, all but the rightmost column with the same new name are dropped. </definition> </definitions></p>\n<p><strong>Description</strong> The <code>RENAME</code> processing command renames one or more columns. If a column with the new name already exists, it will be replaced by the new column. A <code>RENAME</code> with multiple column renames is equivalent to multiple sequential <code>RENAME</code> commands. <strong>Examples</strong></p>\n<pre class="esql"><code>FROM employees\n| KEEP first_name, last_name, still_hired\n| RENAME  still_hired AS employed</code></pre>\n<p>Multiple columns can be renamed with a single <code>RENAME</code> command:</p>\n<pre class="esql"><code>FROM employees\n| KEEP first_name, last_name\n| RENAME first_name AS fn, last_name AS ln</code></pre>\n<p>With multiple <code>RENAME</code> commands:</p>\n<pre class="esql"><code>FROM employees\n| KEEP first_name, last_name\n| RENAME first_name AS fn\n| RENAME last_name AS ln</code></pre>
"""),                     Map.entry("std_dev", """
<h2 id="std_dev"><code>STD_DEV</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/std_dev.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="number"> </definition> </definitions></p>\n<p><strong>Description</strong> The population standard deviation of a numeric field. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>number</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Examples</strong></p>\n<pre class="esql"><code>FROM employees\n| STATS std_dev_height = STD_DEV(height)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>std_dev_height:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>0.2063704</td>\n</tr>\n</tbody>\n</table>\n<p>The expression can use inline functions. For example, to calculate the population standard deviation of each employee’s maximum salary changes, first use <code>MV_MAX</code> on each row, and then use <code>STD_DEV</code> on the result</p>\n<pre class="esql"><code>FROM employees\n| STATS stddev_salary_change = STD_DEV(MV_MAX(salary_change))</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>stddev_salary_change:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>6.87583</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("where", """
<h1 id="where">WHERE</h1>\n<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="fu">serverless</span><span class="kw">:</span><span class="at"> ga</span></span>\n<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="fu">stack</span><span class="kw">:</span><span class="at"> ga</span></span></code></pre></div>\nThe <code>WHERE</code> processing command produces a table that contains all the rows from the input table for which the provided condition evaluates to <code>true</code>.\n<tip>\nIn case of value exclusions, fields with <code>null</code> values will be excluded from search results. In this context a <code>null</code> means either there is an explicit <code>null</code> value in the document or there is no value at all. For example: <code>WHERE field != "value"</code> will be interpreted as <code>WHERE field != "value" AND field IS NOT NULL</code>.\n</tip>\n<p><strong>Syntax</strong></p>\n<pre class="esql"><code>WHERE expression</code></pre>\n<p><strong>Parameters</strong> <definitions> <definition term="expression"> A boolean expression. </definition> </definitions></p>\n<p><strong>Examples</strong></p>\n<pre class="esql"><code>FROM employees\n| KEEP first_name, last_name, still_hired\n| WHERE still_hired == true</code></pre>\n<p>Which, if <code>still_hired</code> is a boolean field, can be simplified to:</p>\n<pre class="esql"><code>FROM employees\n| KEEP first_name, last_name, still_hired\n| WHERE still_hired</code></pre>\n<p>Use date math to retrieve data from a specific time range. For example, to retrieve the last hour of logs:</p>\n<pre class="esql"><code>FROM sample_data\n| WHERE @timestamp &gt; NOW() - 1 hour</code></pre>\n<p><code>WHERE</code> supports various <a href="/docs/reference/query-languages/esql/esql-functions-operators#esql-functions">functions</a>. For example the <a href="/docs/reference/query-languages/esql/functions-operators/string-functions#esql-length"><code>LENGTH</code></a> function:</p>\n<pre class="esql"><code>FROM employees\n| KEEP first_name, last_name, height\n| WHERE LENGTH(first_name) &lt; 4</code></pre>\n<p>For a complete list of all functions, refer to <a href="/docs/reference/query-languages/esql/esql-functions-operators#esql-functions">Functions overview</a>.</p>\n<h3 id="null-predicates">NULL Predicates</h3>\n<p>For NULL comparison, use the <code>IS NULL</code> and <code>IS NOT NULL</code> predicates. <strong>Example</strong></p>\n<pre class="esql"><code>FROM employees\n| WHERE birth_date IS NULL</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>first_name:keyword</th>\n<th>last_name:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>Basil</td>\n<td>Tramer</td>\n</tr>\n<tr class="even">\n<td>Florian</td>\n<td>Syrotiuk</td>\n</tr>\n<tr class="odd">\n<td>Lucien</td>\n<td>Rosenbaum</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>FROM employees\n| WHERE is_rehired IS NOT NULL\n| STATS COUNT(emp_no)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>COUNT(emp_no):long</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>84</td>\n</tr>\n</tbody>\n</table>\n<h3 id="matching-text">Matching text</h3>\n<p>For matching text, you can use <a href="https://www.elastic.co/docs/reference/query-languages/esql/functions-operators/search-functions">full text search functions</a> like <code>MATCH</code>. Use <a href="/docs/reference/query-languages/esql/functions-operators/search-functions#esql-match"><code>MATCH</code></a> to perform a <a href="https://www.elastic.co/docs/reference/query-languages/query-dsl/query-dsl-match-query">match query</a> on a specified field. Match can be used on text fields, as well as other field types like boolean, dates, and numeric types. <strong>Examples</strong></p>\n<pre class="esql"><code>FROM books\n| WHERE MATCH(author, &quot;Faulkner&quot;)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>book_no:keyword</th>\n<th>author:text</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>2378</td>\n<td>[Carol Faulkner, Holly Byers Ochoa, Lucretia Mott]</td>\n</tr>\n<tr class="even">\n<td>2713</td>\n<td>William Faulkner</td>\n</tr>\n<tr class="odd">\n<td>2847</td>\n<td>Colleen Faulkner</td>\n</tr>\n<tr class="even">\n<td>2883</td>\n<td>William Faulkner</td>\n</tr>\n<tr class="odd">\n<td>3293</td>\n<td>Danny Faulkner</td>\n</tr>\n</tbody>\n</table>\n<pre class="esql"><code>FROM books\n| WHERE MATCH(title, &quot;Hobbit Back Again&quot;, {&quot;operator&quot;: &quot;AND&quot;})\n| KEEP title;</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>title:text</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>The Hobbit or There and Back Again</td>\n</tr>\n</tbody>\n</table>\n<tip>\nYou can also use the shorthand <a href="/docs/reference/query-languages/esql/functions-operators/operators#esql-match-operator">match operator</a> <code>:</code> instead of <code>MATCH</code>.\n</tip>\n<h3 id="like-and-rlike">LIKE and RLIKE</h3>\n<p>Use <code>LIKE</code> to filter data based on string patterns using wildcards. <code>LIKE</code> usually acts on a field placed on the left-hand side of the operator, but it can also act on a constant (literal) expression. The right-hand side of the operator represents the pattern. The following wildcard characters are supported: - <code>*</code> matches zero or more characters. - <code>?</code> matches one character.</p>\n<p><strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>str</th>\n<th>pattern</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>keyword</td>\n<td>keyword</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>keyword</td>\n<td>boolean</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>FROM employees\n| WHERE first_name LIKE &quot;&quot;&quot;?b*&quot;&quot;&quot;\n| KEEP first_name, last_name</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>first_name:keyword</th>\n<th>last_name:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>Ebbe</td>\n<td>Callaway</td>\n</tr>\n<tr class="even">\n<td>Eberhardt</td>\n<td>Terkki</td>\n</tr>\n</tbody>\n</table>\n<p>Matching the exact characters <code>*</code> and <code>.</code> will require escaping. The escape character is backslash <code>\\</code>. Since also backslash is a special character in string literals, it will require further escaping.</p>\n<pre class="esql"><code>ROW message = &quot;foo * bar&quot;\n| WHERE message LIKE &quot;foo \\* bar&quot;</code></pre>\n<p>To reduce the overhead of escaping, we suggest using triple quotes strings <code>\"\"\"</code></p>\n<pre class="esql"><code>ROW message = &quot;foo * bar&quot;\n| WHERE message LIKE &quot;&quot;&quot;foo \\* bar&quot;&quot;&quot;</code></pre>\n<pre><code>stack: ga 9.1\nserverless: ga</code></pre>\n<p>Both a single pattern or a list of patterns are supported. If a list of patterns is provided, the expression will return true if any of the patterns match.</p>\n<pre class="esql"><code>ROW message = &quot;foobar&quot;\n| WHERE message like (&quot;foo*&quot;, &quot;bar?&quot;)</code></pre>\n<p>Use <code>RLIKE</code> to filter data based on string patterns using using <a href="https://www.elastic.co/docs/reference/query-languages/query-dsl/regexp-syntax">regular expressions</a>. <code>RLIKE</code> usually acts on a field placed on the left-hand side of the operator, but it can also act on a constant (literal) expression. The right-hand side of the operator represents the pattern. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>str</th>\n<th>pattern</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>keyword</td>\n<td>keyword</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>keyword</td>\n<td>boolean</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>FROM employees\n| WHERE first_name RLIKE &quot;&quot;&quot;.leja.*&quot;&quot;&quot;\n| KEEP first_name, last_name</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>first_name:keyword</th>\n<th>last_name:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>Alejandro</td>\n<td>McAlpine</td>\n</tr>\n</tbody>\n</table>\n<p>Matching special characters (eg. <code>.</code>, <code>*</code>, <code>(</code>…) will require escaping. The escape character is backslash <code>\\</code>. Since also backslash is a special character in string literals, it will require further escaping.</p>\n<pre class="esql"><code>ROW message = &quot;foo ( bar&quot;\n| WHERE message RLIKE &quot;foo \\( bar&quot;</code></pre>\n<p>To reduce the overhead of escaping, we suggest using triple quotes strings <code>\"\"\"</code></p>\n<pre class="esql"><code>ROW message = &quot;foo ( bar&quot;\n| WHERE message RLIKE &quot;&quot;&quot;foo \\( bar&quot;&quot;&quot;</code></pre>\n<pre><code>stack: ga 9.2\nserverless: ga</code></pre>\n<p>Both a single pattern or a list of patterns are supported. If a list of patterns is provided, the expression will return true if any of the patterns match.</p>\n<pre class="esql"><code>ROW message = &quot;foobar&quot;\n| WHERE message RLIKE (&quot;foo.*&quot;, &quot;bar.&quot;)</code></pre>\n<h3 id="in">IN</h3>\n<p>The <code>IN</code> operator allows testing whether a field or expression equals an element in a list of literals, fields or expressions: <strong>Example</strong></p>\n<pre class="esql"><code>ROW a = 1, b = 4, c = 3\n| WHERE c-a IN (3, b / 2, a)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:integer</th>\n<th>b:integer</th>\n<th>c:integer</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>1</td>\n<td>4</td>\n<td>3</td>\n</tr>\n</tbody>\n</table>\n<p>For a complete list of all operators, refer to <a href="/docs/reference/query-languages/esql/esql-functions-operators#esql-operators-overview">Operators</a>.</p>
"""),                     Map.entry("concat", """
<h2 id="concat"><code>CONCAT</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/concat.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="string1"> Strings to concatenate. </definition> <definition term="string2"> Strings to concatenate. </definition> </definitions></p>\n<p><strong>Description</strong> Concatenates two or more strings. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>string1</th>\n<th>string2</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>keyword</td>\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>text</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>text</td>\n<td>keyword</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>FROM employees\n| KEEP first_name, last_name\n| EVAL fullname = CONCAT(first_name, &quot; &quot;, last_name)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>first_name:keyword</th>\n<th>last_name:keyword</th>\n<th>fullname:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>Alejandro</td>\n<td>McAlpine</td>\n<td>Alejandro McAlpine</td>\n</tr>\n<tr class="even">\n<td>Amabile</td>\n<td>Gomatam</td>\n<td>Amabile Gomatam</td>\n</tr>\n<tr class="odd">\n<td>Anneke</td>\n<td>Preusig</td>\n<td>Anneke Preusig</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("top", """
<h2 id="top"><code>TOP</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/top.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> The field to collect the top values for. </definition> <definition term="limit"> The maximum number of values to collect. </definition> <definition term="order"> The order to calculate the top values. Either <code>asc</code> or <code>desc</code>, and defaults to <code>asc</code> if omitted. </definition> </definitions></p>\n<p><strong>Description</strong> Collects the top values for a field. Includes repeated values. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>limit</th>\n<th>order</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>boolean</td>\n<td>integer</td>\n<td>keyword</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>boolean</td>\n<td>integer</td>\n<td></td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>date</td>\n<td>integer</td>\n<td>keyword</td>\n<td>date</td>\n</tr>\n<tr class="even">\n<td>date</td>\n<td>integer</td>\n<td></td>\n<td>date</td>\n</tr>\n<tr class="odd">\n<td>double</td>\n<td>integer</td>\n<td>keyword</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>integer</td>\n<td></td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>integer</td>\n<td>keyword</td>\n<td>integer</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>integer</td>\n<td></td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>ip</td>\n<td>integer</td>\n<td>keyword</td>\n<td>ip</td>\n</tr>\n<tr class="even">\n<td>ip</td>\n<td>integer</td>\n<td></td>\n<td>ip</td>\n</tr>\n<tr class="odd">\n<td>keyword</td>\n<td>integer</td>\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>integer</td>\n<td></td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>integer</td>\n<td>keyword</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>integer</td>\n<td></td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>integer</td>\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>integer</td>\n<td></td>\n<td>keyword</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>FROM employees\n| STATS top_salaries = TOP(salary, 3, &quot;desc&quot;), top_salary = MAX(salary)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>top_salaries:integer</th>\n<th>top_salary:integer</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>[74999, 74970, 74572]</td>\n<td>74999</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("from", """
<h1 id="from">FROM</h1>\n<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="fu">serverless</span><span class="kw">:</span><span class="at"> ga</span></span>\n<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="fu">stack</span><span class="kw">:</span><span class="at"> ga</span></span></code></pre></div>\n<p>The <code>FROM</code> source command returns a table with data from a data stream, index, or alias. <strong>Syntax</strong></p>\n<pre class="esql"><code>FROM index_pattern [METADATA fields]</code></pre>\n<p><strong>Parameters</strong> <definitions> <definition term="index_pattern"> A list of indices, data streams or aliases. Supports wildcards and date math. </definition> <definition term="fields"> A comma-separated list of <a href="https://www.elastic.co/docs/reference/query-languages/esql/esql-metadata-fields">metadata fields</a> to retrieve. </definition> </definitions></p>\n<strong>Description</strong> The <code>FROM</code> source command returns a table with data from a data stream, index, or alias. Each row in the resulting table represents a document. Each column corresponds to a field, and can be accessed by the name of that field.\n<note>\nBy default, an ES|QL query without an explicit <a href="#esql-limit"><code>LIMIT</code></a> uses an implicit limit of 1000. This applies to <code>FROM</code> too. A <code>FROM</code> command without <code>LIMIT</code>: <code>esql   FROM employees</code> is executed as: <code>esql   FROM employees   | LIMIT 1000</code>\n</note>\n<p><strong>Examples</strong></p>\n<pre class="esql"><code>FROM employees</code></pre>\n<p>You can use <a href="/docs/reference/elasticsearch/rest-apis/api-conventions#api-date-math-index-names">date math</a> to refer to indices, aliases and data streams. This can be useful for time series data, for example to access today’s index:</p>\n<pre class="esql"><code>FROM &lt;logs-{now/d}&gt;</code></pre>\n<p>Use comma-separated lists or wildcards to <a href="https://www.elastic.co/docs/reference/query-languages/esql/esql-multi-index">query multiple data streams, indices, or aliases</a>:</p>\n<pre class="esql"><code>FROM employees-00001,other-employees-*</code></pre>\n<p>Use the format <code>&lt;remote_cluster_name&gt;:&lt;target&gt;</code> to <a href="https://www.elastic.co/docs/reference/query-languages/esql/esql-cross-clusters">query data streams and indices on remote clusters</a>:</p>\n<pre class="esql"><code>FROM cluster_one:employees-00001,cluster_two:other-employees-*</code></pre>\n<p>Use the optional <code>METADATA</code> directive to enable <a href="https://www.elastic.co/docs/reference/query-languages/esql/esql-metadata-fields">metadata fields</a>:</p>\n<pre class="esql"><code>FROM employees METADATA _id</code></pre>\n<p>Use enclosing double quotes (<code>"</code>) or three enclosing double quotes (<code>\"\"\"</code>) to escape index names that contain special characters:</p>\n<pre class="esql"><code>FROM &quot;this=that&quot;, &quot;&quot;&quot;this[that&quot;&quot;&quot;</code></pre>
"""),                     Map.entry("signum", """
<h2 id="signum"><code>SIGNUM</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/signum.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="number"> Numeric expression. If <code>null</code>, the function returns <code>null</code>. </definition> </definitions></p>\n<p><strong>Description</strong> Returns the sign of the given number. It returns <code>-1</code> for negative numbers, <code>0</code> for <code>0</code> and <code>1</code> for positive numbers. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>number</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW d = 100.0\n| EVAL s = SIGNUM(d)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>d: double</th>\n<th>s:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>100</td>\n<td>1.0</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("first", """
<h2 id="first"><code>FIRST</code></h2>\n<pre><code>stack: ga 9.2.0</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/first.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="value"> Values to return </definition> <definition term="sort"> Sort key </definition> </definitions></p>\n<p><strong>Description</strong> Calculates the earliest value of a field. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>value</th>\n<th>sort</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n<td>date</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>date_nanos</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>date</td>\n<td>integer</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>date_nanos</td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>keyword</td>\n<td>date</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>date_nanos</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>date</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>date_nanos</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>date</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>date_nanos</td>\n<td>keyword</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>FROM k8s\n| STATS first_bytes_in = FIRST(network.bytes_in, @timestamp) BY pod\n| SORT pod ASC</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>first_bytes_in:long</th>\n<th>pod:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>278</td>\n<td>one</td>\n</tr>\n<tr class="even">\n<td>473</td>\n<td>three</td>\n</tr>\n<tr class="odd">\n<td>699</td>\n<td>two</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("present_over_time", """
<h2 id="present_over_time"><code>PRESENT_OVER_TIME</code></h2>\n<pre><code>stack: preview 9.2.0\nserverless: preview</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/present_over_time.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> </definition> </definitions></p>\n<p><strong>Description</strong> Calculates the presence of a field in the output result over time range. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>aggregate_metric_double</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>boolean</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>cartesian_point</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>cartesian_shape</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>date</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>date_nanos</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>double</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>geo_point</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>geo_shape</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>geohash</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>geohex</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>geotile</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>ip</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>keyword</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>version</td>\n<td>boolean</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>TS k8s\n| WHERE cluster == &quot;prod&quot; AND pod == &quot;two&quot;\n| STATS events_received = MAX(PRESENT_OVER_TIME(events_received)) BY pod, time_bucket = TBUCKET(2 minute)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>events_received:boolean</th>\n<th>pod:keyword</th>\n<th>time_bucket:datetime</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>true</td>\n<td>two</td>\n<td>2024-05-10T00:02:00.000Z</td>\n</tr>\n<tr class="even">\n<td>true</td>\n<td>two</td>\n<td>2024-05-10T00:08:00.000Z</td>\n</tr>\n<tr class="odd">\n<td>false</td>\n<td>two</td>\n<td>2024-05-10T00:10:00.000Z</td>\n</tr>\n<tr class="even">\n<td>false</td>\n<td>two</td>\n<td>2024-05-10T00:12:00.000Z</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("floor", """
<h2 id="floor"><code>FLOOR</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/floor.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="number"> Numeric expression. If <code>null</code>, the function returns <code>null</code>. </definition> </definitions></p>\n<strong>Description</strong> Round a number down to the nearest integer.\n<note>\nThis is a noop for <code>long</code> (including unsigned) and <code>integer</code>. For <code>double</code> this picks the closest <code>double</code> value to the integer similar to <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/Math.html#floor(double)">Math.floor</a>.\n</note>\n<p><strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>number</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>unsigned_long</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW a=1.8\n| EVAL a=FLOOR(a)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>1</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("space", """
<h2 id="space"><code>SPACE</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/space.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="number"> Number of spaces in result. </definition> </definitions></p>\n<p><strong>Description</strong> Returns a string made of <code>number</code> spaces. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>number</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>integer</td>\n<td>keyword</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW message = CONCAT(&quot;Hello&quot;, SPACE(1), &quot;World!&quot;);</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>message:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>Hello World!</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("date_diff", """
<h2 id="date_diff"><code>DATE_DIFF</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/date_diff.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="unit"> Time difference unit </definition> <definition term="startTimestamp"> A string representing a start timestamp </definition> <definition term="endTimestamp"> A string representing an end timestamp </definition> </definitions></p>\n<p><strong>Description</strong> Subtracts the <code>startTimestamp</code> from the <code>endTimestamp</code> and returns the difference in multiples of <code>unit</code>. If <code>startTimestamp</code> is later than the <code>endTimestamp</code>, negative values are returned. <strong>Datetime difference units</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>unit</th>\n<th>abbreviations</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>year</td>\n<td>years, yy, yyyy</td>\n</tr>\n<tr class="even">\n<td>quarter</td>\n<td>quarters, qq, q</td>\n</tr>\n<tr class="odd">\n<td>month</td>\n<td>months, mm, m</td>\n</tr>\n<tr class="even">\n<td>dayofyear</td>\n<td>dy, y</td>\n</tr>\n<tr class="odd">\n<td>day</td>\n<td>days, dd, d</td>\n</tr>\n<tr class="even">\n<td>week</td>\n<td>weeks, wk, ww</td>\n</tr>\n<tr class="odd">\n<td>weekday</td>\n<td>weekdays, dw</td>\n</tr>\n<tr class="even">\n<td>hour</td>\n<td>hours, hh</td>\n</tr>\n<tr class="odd">\n<td>minute</td>\n<td>minutes, mi, n</td>\n</tr>\n<tr class="even">\n<td>second</td>\n<td>seconds, ss, s</td>\n</tr>\n<tr class="odd">\n<td>millisecond</td>\n<td>milliseconds, ms</td>\n</tr>\n<tr class="even">\n<td>microsecond</td>\n<td>microseconds, mcs</td>\n</tr>\n<tr class="odd">\n<td>nanosecond</td>\n<td>nanoseconds, ns</td>\n</tr>\n</tbody>\n</table>\n<p>Note that while there is an overlap between the function’s supported units and ES|QL’s supported time span literals, these sets are distinct and not interchangeable. Similarly, the supported abbreviations are conveniently shared with implementations of this function in other established products and not necessarily common with the date-time nomenclature used by Elasticsearch. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>unit</th>\n<th>startTimestamp</th>\n<th>endTimestamp</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>keyword</td>\n<td>date</td>\n<td>date</td>\n<td>integer</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>date</td>\n<td>date_nanos</td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>keyword</td>\n<td>date_nanos</td>\n<td>date</td>\n<td>integer</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>date_nanos</td>\n<td>date_nanos</td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>date</td>\n<td>date</td>\n<td>integer</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>date</td>\n<td>date_nanos</td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>date_nanos</td>\n<td>date</td>\n<td>integer</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>date_nanos</td>\n<td>date_nanos</td>\n<td>integer</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Examples</strong></p>\n<pre class="esql"><code>ROW date1 = TO_DATETIME(&quot;2023-12-02T11:00:00.000Z&quot;),\n    date2 = TO_DATETIME(&quot;2023-12-02T11:00:00.001Z&quot;)\n| EVAL dd_ms = DATE_DIFF(&quot;microseconds&quot;, date1, date2)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>date1:date</th>\n<th>date2:date</th>\n<th>dd_ms:integer</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>2023-12-02T11:00:00.000Z</td>\n<td>2023-12-02T11:00:00.001Z</td>\n<td>1000</td>\n</tr>\n</tbody>\n</table>\n<p>When subtracting in calendar units - like year, month a.s.o. - only the fully elapsed units are counted. To avoid this and obtain also remainders, simply switch to the next smaller unit and do the date math accordingly.</p>\n<pre class="esql"><code>ROW end_23 = TO_DATETIME(&quot;2023-12-31T23:59:59.999Z&quot;),\n  start_24 = TO_DATETIME(&quot;2024-01-01T00:00:00.000Z&quot;),\n    end_24 = TO_DATETIME(&quot;2024-12-31T23:59:59.999&quot;)\n| EVAL end23_to_start24 = DATE_DIFF(&quot;year&quot;, end_23, start_24)\n| EVAL end23_to_end24   = DATE_DIFF(&quot;year&quot;, end_23, end_24)\n| EVAL start_to_end_24  = DATE_DIFF(&quot;year&quot;, start_24, end_24)</code></pre>\n<table>\n<colgroup>\n<col style="width: 16%" />\n<col style="width: 16%" />\n<col style="width: 16%" />\n<col style="width: 16%" />\n<col style="width: 15%" />\n<col style="width: 16%" />\n</colgroup>\n<thead>\n<tr class="header">\n<th>end_23:date</th>\n<th>start_24:date</th>\n<th>end_24:date</th>\n<th>end23_to_start24:integer</th>\n<th>end23_to_end24:integer</th>\n<th>start_to_end_24:integer</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>2023-12-31T23:59:59.999Z</td>\n<td>2024-01-01T00:00:00.000Z</td>\n<td>2024-12-31T23:59:59.999Z</td>\n<td>0</td>\n<td>1</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("dissect", """
<h1 id="dissect">DISSECT</h1>\n<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="fu">serverless</span><span class="kw">:</span><span class="at"> ga</span></span>\n<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="fu">stack</span><span class="kw">:</span><span class="at"> ga</span></span></code></pre></div>\n<p><code>DISSECT</code> enables you to <a href="https://www.elastic.co/docs/reference/query-languages/esql/esql-process-data-with-dissect-grok">extract structured data out of a string</a>. <strong>Syntax</strong></p>\n<pre class="esql"><code>DISSECT input &quot;pattern&quot; [APPEND_SEPARATOR=&quot;&lt;separator&gt;&quot;]</code></pre>\n<p><strong>Parameters</strong> <definitions> <definition term="input"> The column that contains the string you want to structure. If the column has multiple values, <code>DISSECT</code> will process each value. </definition> <definition term="pattern"> A <a href="/docs/reference/query-languages/esql/esql-process-data-with-dissect-grok#esql-dissect-patterns">dissect pattern</a>. If a field name conflicts with an existing column, the existing column is dropped. If a field name is used more than once, only the rightmost duplicate creates a column. </definition> <definition term="<separator>"> A string used as the separator between appended values, when using the <a href="/docs/reference/query-languages/esql/esql-process-data-with-dissect-grok#esql-append-modifier">append modifier</a>. </definition> </definitions></p>\n<p><strong>Description</strong> <code>DISSECT</code> enables you to <a href="https://www.elastic.co/docs/reference/query-languages/esql/esql-process-data-with-dissect-grok">extract structured data out of a string</a>. <code>DISSECT</code> matches the string against a delimiter-based pattern, and extracts the specified keys as columns. Refer to <a href="/docs/reference/query-languages/esql/esql-process-data-with-dissect-grok#esql-process-data-with-dissect">Process data with <code>DISSECT</code></a> for the syntax of dissect patterns. <strong>Examples</strong> The following example parses a string that contains a timestamp, some text, and an IP address:</p>\n<pre class="esql"><code>ROW a = &quot;2023-01-23T12:15:00.000Z - some text - 127.0.0.1&quot;\n| DISSECT a &quot;&quot;&quot;%{date} - %{msg} - %{ip}&quot;&quot;&quot;\n| KEEP date, msg, ip</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>date:keyword</th>\n<th>msg:keyword</th>\n<th>ip:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>2023-01-23T12:15:00.000Z</td>\n<td>some text</td>\n<td>127.0.0.1</td>\n</tr>\n</tbody>\n</table>\n<p>By default, <code>DISSECT</code> outputs keyword string columns. To convert to another type, use <a href="https://www.elastic.co/docs/reference/query-languages/esql/functions-operators/type-conversion-functions">Type conversion functions</a>:</p>\n<pre class="esql"><code>ROW a = &quot;2023-01-23T12:15:00.000Z - some text - 127.0.0.1&quot;\n| DISSECT a &quot;&quot;&quot;%{date} - %{msg} - %{ip}&quot;&quot;&quot;\n| KEEP date, msg, ip\n| EVAL date = TO_DATETIME(date)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>msg:keyword</th>\n<th>ip:keyword</th>\n<th>date:date</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>some text</td>\n<td>127.0.0.1</td>\n<td>2023-01-23T12:15:00.000Z</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("mv_percentile", """
<h2 id="mv_percentile"><code>MV_PERCENTILE</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/mv_percentile.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="number"> Multivalue expression. </definition> <definition term="percentile"> The percentile to calculate. Must be a number between 0 and 100. Numbers out of range will return a null instead. </definition> </definitions></p>\n<p><strong>Description</strong> Converts a multivalued field into a single valued field containing the value at which a certain percentage of observed values occur. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>number</th>\n<th>percentile</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>double</td>\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>double</td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>integer</td>\n<td>integer</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>long</td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>double</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>integer</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>long</td>\n<td>long</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW values = [5, 5, 10, 12, 5000]\n| EVAL p50 = MV_PERCENTILE(values, 50), median = MV_MEDIAN(values)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>values:integer</th>\n<th>p50:integer</th>\n<th>median:integer</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>[5, 5, 10, 12, 5000]</td>\n<td>10</td>\n<td>10</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("to_cartesianshape", """
<h2 id="to_cartesianshape"><code>TO_CARTESIANSHAPE</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/to_cartesianshape.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> Input value. The input can be a single- or multi-valued column or an expression. </definition> </definitions></p>\n<p><strong>Description</strong> Converts an input value to a <code>cartesian_shape</code> value. A string will only be successfully converted if it respects the <a href="https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry">WKT</a> format. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>cartesian_point</td>\n<td>cartesian_shape</td>\n</tr>\n<tr class="even">\n<td>cartesian_shape</td>\n<td>cartesian_shape</td>\n</tr>\n<tr class="odd">\n<td>keyword</td>\n<td>cartesian_shape</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>cartesian_shape</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW wkt = [&quot;POINT(4297.11 -1475.53)&quot;, &quot;POLYGON ((3339584.72 1118889.97, 4452779.63 4865942.27, 2226389.81 4865942.27, 1113194.90 2273030.92, 3339584.72 1118889.97))&quot;]\n| MV_EXPAND wkt\n| EVAL geom = TO_CARTESIANSHAPE(wkt)</code></pre>\n<table>\n<colgroup>\n<col style="width: 50%" />\n<col style="width: 49%" />\n</colgroup>\n<thead>\n<tr class="header">\n<th>wkt:keyword</th>\n<th>geom:cartesian_shape</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>“POINT(4297.11 -1475.53)”</td>\n<td>POINT(4297.11 -1475.53)</td>\n</tr>\n<tr class="even">\n<td>“POLYGON ((3339584.72 1118889.97, 4452779.63 4865942.27, 2226389.81 4865942.27, 1113194.90 2273030.92, 3339584.72 1118889.97))”</td>\n<td>POLYGON ((3339584.72 1118889.97, 4452779.63 4865942.27, 2226389.81 4865942.27, 1113194.90 2273030.92, 3339584.72 1118889.97))</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("cidr_match", """
<h2 id="cidr_match"><code>CIDR_MATCH</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/cidr_match.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="ip"> IP address of type <code>ip</code> (both IPv4 and IPv6 are supported). </definition> <definition term="blockX"> CIDR block to test the IP against. </definition> </definitions></p>\n<p><strong>Description</strong> Returns true if the provided IP is contained in one of the provided CIDR blocks. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>ip</th>\n<th>blockX</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>ip</td>\n<td>keyword</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>ip</td>\n<td>text</td>\n<td>boolean</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>FROM hosts\n| WHERE CIDR_MATCH(ip1, &quot;127.0.0.2/32&quot;, &quot;127.0.0.3/32&quot;)\n| KEEP card, host, ip0, ip1</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>card:keyword</th>\n<th>host:keyword</th>\n<th>ip0:ip</th>\n<th>ip1:ip</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>eth1</td>\n<td>beta</td>\n<td>127.0.0.1</td>\n<td>127.0.0.2</td>\n</tr>\n<tr class="even">\n<td>eth0</td>\n<td>gamma</td>\n<td>fe80::cae2:65ff:fece:feb9</td>\n<td>127.0.0.3</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("enrich", """
<h1 id="enrich">ENRICH</h1>\n<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="fu">serverless</span><span class="kw">:</span><span class="at"> ga</span></span>\n<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="fu">stack</span><span class="kw">:</span><span class="at"> ga</span></span></code></pre></div>\n<p><code>ENRICH</code> enables you to add data from existing indices as new columns using an enrich policy. <strong>Syntax</strong></p>\n<pre class="esql"><code>ENRICH policy [ON match_field] [WITH [new_name1 = ]field1, [new_name2 = ]field2, ...]</code></pre>\n<p><strong>Parameters</strong> <definitions> <definition term="policy"> The name of the enrich policy. You need to <a href="/docs/reference/query-languages/esql/esql-enrich-data#esql-set-up-enrich-policy">create</a> and <a href="/docs/reference/query-languages/esql/esql-enrich-data#esql-execute-enrich-policy">execute</a> the enrich policy first. </definition> <definition term="mode"> The mode of the enrich command in cross cluster ES|QL. See <a href="/docs/reference/query-languages/esql/esql-cross-clusters#ccq-enrich">enrich across clusters</a>. </definition> <definition term="match_field"> The match field. <code>ENRICH</code> uses its value to look for records in the enrich index. If not specified, the match will be performed on the column with the same name as the <code>match_field</code> defined in the <a href="/docs/reference/query-languages/esql/esql-enrich-data#esql-enrich-policy">enrich policy</a>. </definition> <definition term="fieldX"> The enrich fields from the enrich index that are added to the result as new columns. If a column with the same name as the enrich field already exists, the existing column will be replaced by the new column. If not specified, each of the enrich fields defined in the policy is added. A column with the same name as the enrich field will be dropped unless the enrich field is renamed. </definition> <definition term="new_nameX"> Enables you to change the name of the column that’s added for each of the enrich fields. Defaults to the enrich field name. If a column has the same name as the new name, it will be discarded. If a name (new or original) occurs more than once, only the rightmost duplicate creates a new column. </definition> </definitions></p>\n<p><strong>Description</strong> <code>ENRICH</code> enables you to add data from existing indices as new columns using an enrich policy. Refer to <a href="https://www.elastic.co/docs/reference/query-languages/esql/esql-enrich-data">Data enrichment</a> for information about setting up a policy. <img src="https://www.elastic.co/docs/reference/query-languages/images/esql-enrich.png" alt="esql enrich" /></p>\n<tip>\nBefore you can use <code>ENRICH</code>, you need to <a href="/docs/reference/query-languages/esql/esql-enrich-data#esql-set-up-enrich-policy">create and execute an enrich policy</a>.\n</tip>\n<p><strong>Examples</strong> The following example uses the <code>languages_policy</code> enrich policy to add a new column for each enrich field defined in the policy. The match is performed using the <code>match_field</code> defined in the <a href="/docs/reference/query-languages/esql/esql-enrich-data#esql-enrich-policy">enrich policy</a> and requires that the input table has a column with the same name (<code>language_code</code> in this example). <code>ENRICH</code> will look for records in th <a href="/docs/reference/query-languages/esql/esql-enrich-data#esql-enrich-index">enrich index</a> based on the match field value.</p>\n<pre class="esql"><code>ROW language_code = &quot;1&quot;\n| ENRICH languages_policy</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>language_code:keyword</th>\n<th>language_name:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>1</td>\n<td>English</td>\n</tr>\n</tbody>\n</table>\n<p>To use a column with a different name than the <code>match_field</code> defined in the policy as the match field, use <code>ON &lt;column-name&gt;</code>:</p>\n<pre class="esql"><code>ROW a = &quot;1&quot;\n| ENRICH languages_policy ON a</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:keyword</th>\n<th>language_name:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>1</td>\n<td>English</td>\n</tr>\n</tbody>\n</table>\n<p>By default, each of the enrich fields defined in the policy is added as a column. To explicitly select the enrich fields that are added, use <code>WITH &lt;field1&gt;, &lt;field2&gt;, ...</code>:</p>\n<pre class="esql"><code>ROW a = &quot;1&quot;\n| ENRICH languages_policy ON a WITH language_name</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:keyword</th>\n<th>language_name:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>1</td>\n<td>English</td>\n</tr>\n</tbody>\n</table>\n<p>You can rename the columns that are added using <code>WITH new_name=&lt;field1&gt;</code>:</p>\n<pre class="esql"><code>ROW a = &quot;1&quot;\n| ENRICH languages_policy ON a WITH name = language_name</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:keyword</th>\n<th>name:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>1</td>\n<td>English</td>\n</tr>\n</tbody>\n</table>\n<p>In case of name collisions, the newly created columns will override existing columns.</p>
"""),                     Map.entry("pow", """
<h2 id="pow"><code>POW</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/pow.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="base"> Numeric expression for the base. If <code>null</code>, the function returns <code>null</code>. </definition> <definition term="exponent"> Numeric expression for the exponent. If <code>null</code>, the function returns <code>null</code>. </definition> </definitions></p>\n<strong>Description</strong> Returns the value of <code>base</code> raised to the power of <code>exponent</code>.\n<note>\nIt is still possible to overflow a double result here; in that case, null will be returned.\n</note>\n<p><strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>base</th>\n<th>exponent</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>double</td>\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>unsigned_long</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>unsigned_long</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>unsigned_long</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>unsigned_long</td>\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>unsigned_long</td>\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>unsigned_long</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Examples</strong></p>\n<pre class="esql"><code>ROW base = 2.0, exponent = 2\n| EVAL result = POW(base, exponent)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>base:double</th>\n<th>exponent:integer</th>\n<th>result:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>2.0</td>\n<td>2</td>\n<td>4.0</td>\n</tr>\n</tbody>\n</table>\n<p>The exponent can be a fraction, which is similar to performing a root. For example, the exponent of <code>0.5</code> will give the square root of the base:</p>\n<pre class="esql"><code>ROW base = 4, exponent = 0.5\n| EVAL s = POW(base, exponent)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>base:integer</th>\n<th>exponent:double</th>\n<th>s:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>4</td>\n<td>0.5</td>\n<td>2.0</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("variance", """
<h2 id="variance"><code>VARIANCE</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/variance.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="number"> </definition> </definitions></p>\n<p><strong>Description</strong> The population variance of a numeric field. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>number</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>FROM employees\n| STATS var_height = VARIANCE(height)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>var_height:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>0.0425888</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("byte_length", """
<h2 id="byte_length"><code>BYTE_LENGTH</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/byte_length.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="string"> String expression. If <code>null</code>, the function returns <code>null</code>. </definition> </definitions></p>\n<strong>Description</strong> Returns the byte length of a string.\n<note>\nAll strings are in UTF-8, so a single character can use multiple bytes.\n</note>\n<p><strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>string</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>keyword</td>\n<td>integer</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>integer</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>FROM airports\n| WHERE country == &quot;India&quot;\n| KEEP city\n| EVAL fn_length = LENGTH(city), fn_byte_length = BYTE_LENGTH(city)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>city:keyword</th>\n<th>fn_length:integer</th>\n<th>fn_byte_length:integer</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>Agwār</td>\n<td>5</td>\n<td>6</td>\n</tr>\n<tr class="even">\n<td>Ahmedabad</td>\n<td>9</td>\n<td>9</td>\n</tr>\n<tr class="odd">\n<td>Bangalore</td>\n<td>9</td>\n<td>9</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("to_geopoint", """
<h2 id="to_geopoint"><code>TO_GEOPOINT</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/to_geopoint.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> Input value. The input can be a single- or multi-valued column or an expression. </definition> </definitions></p>\n<p><strong>Description</strong> Converts an input value to a <code>geo_point</code> value. A string will only be successfully converted if it respects the <a href="https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry">WKT Point</a> format. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>geo_point</td>\n<td>geo_point</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>geo_point</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>geo_point</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW wkt = &quot;POINT(42.97109630194 14.7552534413725)&quot;\n| EVAL pt = TO_GEOPOINT(wkt)</code></pre>\n<table>\n<colgroup>\n<col style="width: 51%" />\n<col style="width: 48%" />\n</colgroup>\n<thead>\n<tr class="header">\n<th>wkt:keyword</th>\n<th>pt:geo_point</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>“POINT(42.97109630194 14.7552534413725)”</td>\n<td>POINT(42.97109630194 14.7552534413725)</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("mv_median_absolute_deviation", """
<h2 id="mv_median_absolute_deviation"><code>MV_MEDIAN_ABSOLUTE_DEVIATION</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/mv_median_absolute_deviation.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="number"> Multivalue expression. </definition> </definitions></p>\n<strong>Description</strong> Converts a multivalued field into a single valued field containing the median absolute deviation. It is calculated as the median of each data point’s deviation from the median of the entire sample. That is, for a random variable <code>X</code>, the median absolute deviation is <code>median(|median(X) - X|)</code>.\n<note>\nIf the field has an even number of values, the medians will be calculated as the average of the middle two values. If the value is not a floating point number, the averages are rounded towards 0.\n</note>\n<p><strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>number</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>unsigned_long</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW values = [0, 2, 5, 6]\n| EVAL median_absolute_deviation = MV_MEDIAN_ABSOLUTE_DEVIATION(values), median = MV_MEDIAN(values)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>values:integer</th>\n<th>median_absolute_deviation:integer</th>\n<th>median:integer</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>[0, 2, 5, 6]</td>\n<td>2</td>\n<td>3</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("avg_over_time", """
<h2 id="avg_over_time"><code>AVG_OVER_TIME</code></h2>\n<pre><code>stack: preview 9.2.0\nserverless: preview</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/avg_over_time.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="number"> Expression that outputs values to average. </definition> </definitions></p>\n<p><strong>Description</strong> Calculates the average over time of a numeric field. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>number</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>aggregate_metric_double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>TS k8s\n| STATS max_cost=MAX(AVG_OVER_TIME(network.cost)) BY cluster, time_bucket = TBUCKET(1minute)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>max_cost:double</th>\n<th>cluster:keyword</th>\n<th>time_bucket:datetime</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>12.375</td>\n<td>prod</td>\n<td>2024-05-10T00:17:00.000Z</td>\n</tr>\n<tr class="even">\n<td>12.375</td>\n<td>qa</td>\n<td>2024-05-10T00:01:00.000Z</td>\n</tr>\n<tr class="odd">\n<td>12.25</td>\n<td>prod</td>\n<td>2024-05-10T00:19:00.000Z</td>\n</tr>\n<tr class="even">\n<td>12.0625</td>\n<td>qa</td>\n<td>2024-05-10T00:06:00.000Z</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("mv_sort", """
<h2 id="mv_sort"><code>MV_SORT</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/mv_sort.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> Multivalue expression. If <code>null</code>, the function returns <code>null</code>. </definition> <definition term="order"> Sort order. The valid options are ASC and DESC, the default is ASC. </definition> </definitions></p>\n<p><strong>Description</strong> Sorts a multivalued field in lexicographical order. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>order</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>boolean</td>\n<td>keyword</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>date</td>\n<td>keyword</td>\n<td>date</td>\n</tr>\n<tr class="odd">\n<td>date_nanos</td>\n<td>keyword</td>\n<td>date_nanos</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>keyword</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>keyword</td>\n<td>integer</td>\n</tr>\n<tr class="even">\n<td>ip</td>\n<td>keyword</td>\n<td>ip</td>\n</tr>\n<tr class="odd">\n<td>keyword</td>\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>keyword</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>version</td>\n<td>keyword</td>\n<td>version</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW a = [4, 2, -3, 2]\n| EVAL sa = mv_sort(a), sd = mv_sort(a, &quot;DESC&quot;)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:integer</th>\n<th>sa:integer</th>\n<th>sd:integer</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>[4, 2, -3, 2]</td>\n<td>[-3, 2, 2, 4]</td>\n<td>[4, 2, 2, -3]</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("stddev_over_time", """
<h2 id="stddev_over_time"><code>STDDEV_OVER_TIME</code></h2>\n<pre><code>stack: preview 9.3.0\nserverless: preview</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/stddev_over_time.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="number"> Expression that outputs values to calculate the standard deviation of. </definition> </definitions></p>\n<p><strong>Description</strong> Calculates the population standard deviation over time of a numeric field. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>number</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>TS k8s\n| STATS max_stddev_cost=MAX(STDDEV_OVER_TIME(network.cost)) BY cluster, time_bucket = TBUCKET(1minute)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>cluster:keyword</th>\n<th>time_bucket:datetime</th>\n<th>max_stddev_cost:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>staging</td>\n<td>2024-05-10T00:03:00.000Z</td>\n<td>5.4375</td>\n</tr>\n<tr class="even">\n<td>staging</td>\n<td>2024-05-10T00:09:00.000Z</td>\n<td>5.1875</td>\n</tr>\n<tr class="odd">\n<td>qa</td>\n<td>2024-05-10T00:18:00.000Z</td>\n<td>4.097764</td>\n</tr>\n<tr class="even">\n<td>qa</td>\n<td>2024-05-10T00:21:00.000Z</td>\n<td>4.0</td>\n</tr>\n<tr class="odd">\n<td>staging</td>\n<td>2024-05-10T00:20:00.000Z</td>\n<td>3.9375</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("tanh", """
<h2 id="tanh"><code>TANH</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/tanh.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="number"> Numeric expression. If <code>null</code>, the function returns <code>null</code>. </definition> </definitions></p>\n<p><strong>Description</strong> Returns the <a href="https://en.wikipedia.org/wiki/Hyperbolic_functions">hyperbolic tangent</a> of a number. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>number</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW a=1.8\n| EVAL tanh=TANH(a)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:double</th>\n<th>tanh:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>1.8</td>\n<td>0.9468060128462683</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("median", """
<h2 id="median"><code>MEDIAN</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/median.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="number"> Expression that outputs values to calculate the median of. </definition> </definitions></p>\n<strong>Description</strong> The value that is greater than half of all values and less than half of all values, also known as the 50% <a href="#esql-percentile"><code>PERCENTILE</code></a>.\n<note>\nLike <a href="#esql-percentile"><code>PERCENTILE</code></a>, <code>MEDIAN</code> is <a href="#esql-percentile-approximate">usually approximate</a>.\n</note>\n<p><strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>number</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Examples</strong></p>\n<pre class="esql"><code>FROM employees\n| STATS MEDIAN(salary), PERCENTILE(salary, 50)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>MEDIAN(salary):double</th>\n<th>PERCENTILE(salary, 50):double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>47003</td>\n<td>47003</td>\n</tr>\n</tbody>\n</table>\n<p>The expression can use inline functions. For example, to calculate the median of the maximum values of a multivalued column, first use <code>MV_MAX</code> to get the maximum value per row, and use the result with the <code>MEDIAN</code> function</p>\n<pre class="esql"><code>FROM employees\n| STATS median_max_salary_change = MEDIAN(MV_MAX(salary_change))</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>median_max_salary_change:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>7.69</td>\n</tr>\n</tbody>\n</table>\n<warning>\n<code>MEDIAN</code> is also <a href="https://en.wikipedia.org/wiki/Nondeterministic_algorithm">non-deterministic</a>. This means you can get slightly different results using the same data.\n</warning>
"""),                     Map.entry("max", """
<h2 id="max"><code>MAX</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/max.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> </definition> </definitions></p>\n<p><strong>Description</strong> The maximum value of a field. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>aggregate_metric_double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>boolean</td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>date</td>\n<td>date</td>\n</tr>\n<tr class="even">\n<td>date_nanos</td>\n<td>date_nanos</td>\n</tr>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>ip</td>\n<td>ip</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>unsigned_long <code>stack: ga 9.2.0</code></td>\n<td>unsigned_long</td>\n</tr>\n<tr class="even">\n<td>version</td>\n<td>version</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Examples</strong></p>\n<pre class="esql"><code>FROM employees\n| STATS MAX(languages)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>MAX(languages):integer</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>5</td>\n</tr>\n</tbody>\n</table>\n<p>The expression can use inline functions. For example, to calculate the maximum over an average of a multivalued column, use <code>MV_AVG</code> to first average the multiple values per row, and use the result with the <code>MAX</code> function</p>\n<pre class="esql"><code>FROM employees\n| STATS max_avg_salary_change = MAX(MV_AVG(salary_change))</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>max_avg_salary_change:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>13.75</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("avg", """
<h2 id="avg"><code>AVG</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/avg.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="number"> Expression that outputs values to average. </definition> </definitions></p>\n<p><strong>Description</strong> The average of a numeric field. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>number</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>aggregate_metric_double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Examples</strong></p>\n<pre class="esql"><code>FROM employees\n| STATS AVG(height)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>AVG(height):double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>1.7682</td>\n</tr>\n</tbody>\n</table>\n<p>The expression can use inline functions. For example, to calculate the average over a multivalued column, first use <code>MV_AVG</code> to average the multiple values per row, and use the result with the <code>AVG</code> function</p>\n<pre class="esql"><code>FROM employees\n| STATS avg_salary_change = ROUND(AVG(MV_AVG(salary_change)), 10)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>avg_salary_change:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>1.3904535865</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("mv_first", """
<h2 id="mv_first"><code>MV_FIRST</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/mv_first.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> Multivalue expression. </definition> </definitions></p>\n<p><strong>Description</strong> Converts a multivalued expression into a single valued column containing the first value. This is most useful when reading from a function that emits multivalued columns in a known order like <a href="/docs/reference/query-languages/esql/functions-operators/string-functions#esql-split"><code>SPLIT</code></a>. The order that <a href="https://www.elastic.co/docs/reference/query-languages/esql/esql-multivalued-fields">multivalued fields</a> are read from underlying storage is not guaranteed. It is <strong>frequently</strong> ascending, but don’t rely on that. If you need the minimum value use <a href="#esql-mv_min"><code>MV_MIN</code></a> instead of <code>MV_FIRST</code>. <code>MV_MIN</code> has optimizations for sorted values so there isn’t a performance benefit to <code>MV_FIRST</code>. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>boolean</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>cartesian_point</td>\n<td>cartesian_point</td>\n</tr>\n<tr class="odd">\n<td>cartesian_shape</td>\n<td>cartesian_shape</td>\n</tr>\n<tr class="even">\n<td>date</td>\n<td>date</td>\n</tr>\n<tr class="odd">\n<td>date_nanos</td>\n<td>date_nanos</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>geo_point</td>\n<td>geo_point</td>\n</tr>\n<tr class="even">\n<td>geo_shape</td>\n<td>geo_shape</td>\n</tr>\n<tr class="odd">\n<td>geohash</td>\n<td>geohash</td>\n</tr>\n<tr class="even">\n<td>geohex</td>\n<td>geohex</td>\n</tr>\n<tr class="odd">\n<td>geotile</td>\n<td>geotile</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>ip</td>\n<td>ip</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>unsigned_long</td>\n<td>unsigned_long</td>\n</tr>\n<tr class="even">\n<td>version</td>\n<td>version</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW a=&quot;foo;bar;baz&quot;\n| EVAL first_a = MV_FIRST(SPLIT(a, &quot;;&quot;))</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:keyword</th>\n<th>first_a:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>foo;bar;baz</td>\n<td>“foo”</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("locate", """
<h2 id="locate"><code>LOCATE</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/locate.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="string"> An input string </definition> <definition term="substring"> A substring to locate in the input string </definition> <definition term="start"> The start index </definition> </definitions></p>\n<p><strong>Description</strong> Returns an integer that indicates the position of a keyword substring within another string. Returns <code>0</code> if the substring cannot be found. Note that string positions start from <code>1</code>. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>string</th>\n<th>substring</th>\n<th>start</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>keyword</td>\n<td>keyword</td>\n<td>integer</td>\n<td>integer</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>keyword</td>\n<td></td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>keyword</td>\n<td>text</td>\n<td>integer</td>\n<td>integer</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>text</td>\n<td></td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>keyword</td>\n<td>integer</td>\n<td>integer</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>keyword</td>\n<td></td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>text</td>\n<td>integer</td>\n<td>integer</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>text</td>\n<td></td>\n<td>integer</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW a = &quot;hello&quot;\n| EVAL a_ll = LOCATE(a, &quot;ll&quot;)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:keyword</th>\n<th>a_ll:integer</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>hello</td>\n<td>3</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("substring", """
<h2 id="substring"><code>SUBSTRING</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/substring.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="string"> String expression. If <code>null</code>, the function returns <code>null</code>. </definition> <definition term="start"> Start position. </definition> <definition term="length"> Length of the substring from the start position. Optional; if omitted, all positions after <code>start</code> are returned. </definition> </definitions></p>\n<p><strong>Description</strong> Returns a substring of a string, specified by a start position and an optional length. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>string</th>\n<th>start</th>\n<th>length</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>keyword</td>\n<td>integer</td>\n<td>integer</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>integer</td>\n<td>integer</td>\n<td>keyword</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Examples</strong> This example returns the first three characters of every last name:</p>\n<pre class="esql"><code>FROM employees\n| KEEP last_name\n| EVAL ln_sub = SUBSTRING(last_name, 1, 3)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>last_name:keyword</th>\n<th>ln_sub:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>Awdeh</td>\n<td>Awd</td>\n</tr>\n<tr class="even">\n<td>Azuma</td>\n<td>Azu</td>\n</tr>\n<tr class="odd">\n<td>Baek</td>\n<td>Bae</td>\n</tr>\n<tr class="even">\n<td>Bamford</td>\n<td>Bam</td>\n</tr>\n<tr class="odd">\n<td>Bernatsky</td>\n<td>Ber</td>\n</tr>\n</tbody>\n</table>\n<p>A negative start position is interpreted as being relative to the end of the string. This example returns the last three characters of every last name:</p>\n<pre class="esql"><code>FROM employees\n| KEEP last_name\n| EVAL ln_sub = SUBSTRING(last_name, -3, 3)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>last_name:keyword</th>\n<th>ln_sub:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>Awdeh</td>\n<td>deh</td>\n</tr>\n<tr class="even">\n<td>Azuma</td>\n<td>uma</td>\n</tr>\n<tr class="odd">\n<td>Baek</td>\n<td>aek</td>\n</tr>\n<tr class="even">\n<td>Bamford</td>\n<td>ord</td>\n</tr>\n<tr class="odd">\n<td>Bernatsky</td>\n<td>sky</td>\n</tr>\n</tbody>\n</table>\n<p>If length is omitted, substring returns the remainder of the string. This example returns all characters except for the first:</p>\n<pre class="esql"><code>FROM employees\n| KEEP last_name\n| EVAL ln_sub = SUBSTRING(last_name, 2)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>last_name:keyword</th>\n<th>ln_sub:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>Awdeh</td>\n<td>wdeh</td>\n</tr>\n<tr class="even">\n<td>Azuma</td>\n<td>zuma</td>\n</tr>\n<tr class="odd">\n<td>Baek</td>\n<td>aek</td>\n</tr>\n<tr class="even">\n<td>Bamford</td>\n<td>amford</td>\n</tr>\n<tr class="odd">\n<td>Bernatsky</td>\n<td>ernatsky</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("median_absolute_deviation", """
<h2 id="median_absolute_deviation"><code>MEDIAN_ABSOLUTE_DEVIATION</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/median_absolute_deviation.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="number"> </definition> </definitions></p>\n<strong>Description</strong> Returns the median absolute deviation, a measure of variability. It is a robust statistic, meaning that it is useful for describing data that may have outliers, or may not be normally distributed. For such data it can be more descriptive than standard deviation. It is calculated as the median of each data point’s deviation from the median of the entire sample. That is, for a random variable <code>X</code>, the median absolute deviation is <code>median(|median(X) - X|)</code>.\n<note>\nLike <a href="#esql-percentile"><code>PERCENTILE</code></a>, <code>MEDIAN_ABSOLUTE_DEVIATION</code> is <a href="#esql-percentile-approximate">usually approximate</a>.\n</note>\n<p><strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>number</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Examples</strong></p>\n<pre class="esql"><code>FROM employees\n| STATS MEDIAN(salary), MEDIAN_ABSOLUTE_DEVIATION(salary)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>MEDIAN(salary):double</th>\n<th>MEDIAN_ABSOLUTE_DEVIATION(salary):double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>47003</td>\n<td>10096.5</td>\n</tr>\n</tbody>\n</table>\n<p>The expression can use inline functions. For example, to calculate the median absolute deviation of the maximum values of a multivalued column, first use <code>MV_MAX</code> to get the maximum value per row, and use the result with the <code>MEDIAN_ABSOLUTE_DEVIATION</code> function</p>\n<pre class="esql"><code>FROM employees\n| STATS m_a_d_max_salary_change = MEDIAN_ABSOLUTE_DEVIATION(MV_MAX(salary_change))</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>m_a_d_max_salary_change:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>5.69</td>\n</tr>\n</tbody>\n</table>\n<warning>\n<code>MEDIAN_ABSOLUTE_DEVIATION</code> is also <a href="https://en.wikipedia.org/wiki/Nondeterministic_algorithm">non-deterministic</a>. This means you can get slightly different results using the same data.\n</warning>
"""),                     Map.entry("stats", """
<h1 id="stats">STATS</h1>\n<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="fu">serverless</span><span class="kw">:</span><span class="at"> ga</span></span>\n<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="fu">stack</span><span class="kw">:</span><span class="at"> ga</span></span></code></pre></div>\n<p>The <code>STATS</code> processing command groups rows according to a common value and calculates one or more aggregated values over the grouped rows. <strong>Syntax</strong></p>\n<pre class="esql"><code>STATS [column1 =] expression1 [WHERE boolean_expression1][,\n      ...,\n      [columnN =] expressionN [WHERE boolean_expressionN]]\n      [BY grouping_expression1[, ..., grouping_expressionN]]</code></pre>\n<p><strong>Parameters</strong> <definitions> <definition term="columnX"> The name by which the aggregated value is returned. If omitted, the name is equal to the corresponding expression (<code>expressionX</code>). If multiple columns have the same name, all but the rightmost column with this name will be ignored. </definition> <definition term="expressionX"> An expression that computes an aggregated value. </definition> <definition term="grouping_expressionX"> An expression that outputs the values to group by. If its name coincides with one of the computed columns, that column will be ignored. </definition> <definition term="boolean_expressionX"> The condition that must be met for a row to be included in the evaluation of <code>expressionX</code>. </definition> </definitions></p>\n<note>\nIndividual <code>null</code> values are skipped when computing aggregations.\n</note>\n<p><strong>Description</strong> The <code>STATS</code> processing command groups rows according to a common value and calculates one or more aggregated values over the grouped rows. For the calculation of each aggregated value, the rows in a group can be filtered with <code>WHERE</code>. If <code>BY</code> is omitted, the output table contains exactly one row with the aggregations applied over the entire dataset. The following <a href="https://www.elastic.co/docs/reference/query-languages/esql/functions-operators/aggregation-functions">aggregation functions</a> are supported: - <a href="/docs/reference/query-languages/esql/functions-operators/aggregation-functions#esql-absent"><code>ABSENT</code></a> <code>stack: ga 9.2</code> - <a href="/docs/reference/query-languages/esql/functions-operators/aggregation-functions#esql-avg"><code>AVG</code></a> - <a href="/docs/reference/query-languages/esql/functions-operators/aggregation-functions#esql-count"><code>COUNT</code></a> - <a href="/docs/reference/query-languages/esql/functions-operators/aggregation-functions#esql-count_distinct"><code>COUNT_DISTINCT</code></a> - <a href="/docs/reference/query-languages/esql/functions-operators/aggregation-functions#esql-first"><code>FIRST</code></a> <code>stack: ga 9.2</code> - <a href="/docs/reference/query-languages/esql/functions-operators/aggregation-functions#esql-last"><code>LAST</code></a> <code>stack: ga 9.2</code> - <a href="/docs/reference/query-languages/esql/functions-operators/aggregation-functions#esql-max"><code>MAX</code></a> - <a href="/docs/reference/query-languages/esql/functions-operators/aggregation-functions#esql-median"><code>MEDIAN</code></a> - <a href="/docs/reference/query-languages/esql/functions-operators/aggregation-functions#esql-median_absolute_deviation"><code>MEDIAN_ABSOLUTE_DEVIATION</code></a> - <a href="/docs/reference/query-languages/esql/functions-operators/aggregation-functions#esql-min"><code>MIN</code></a> - <a href="/docs/reference/query-languages/esql/functions-operators/aggregation-functions#esql-percentile"><code>PERCENTILE</code></a> - <a href="/docs/reference/query-languages/esql/functions-operators/aggregation-functions#esql-present"><code>PRESENT</code></a> <code>stack: ga 9.2</code> - <a href="/docs/reference/query-languages/esql/functions-operators/aggregation-functions#esql-sample"><code>SAMPLE</code></a> - <a href="/docs/reference/query-languages/esql/functions-operators/aggregation-functions#esql-st_centroid_agg"><code>ST_CENTROID_AGG</code></a> <code>stack: preview</code> <code>serverless: preview</code> - <a href="/docs/reference/query-languages/esql/functions-operators/aggregation-functions#esql-st_extent_agg"><code>ST_EXTENT_AGG</code></a> <code>stack: preview</code> <code>serverless: preview</code> - <a href="/docs/reference/query-languages/esql/functions-operators/aggregation-functions#esql-std_dev"><code>STD_DEV</code></a> - <a href="/docs/reference/query-languages/esql/functions-operators/aggregation-functions#esql-sum"><code>SUM</code></a> - <a href="/docs/reference/query-languages/esql/functions-operators/aggregation-functions#esql-top"><code>TOP</code></a> - <a href="/docs/reference/query-languages/esql/functions-operators/aggregation-functions#esql-values"><code>VALUES</code></a> <code>stack: preview</code> <code>serverless: preview</code> - <a href="/docs/reference/query-languages/esql/functions-operators/aggregation-functions#esql-variance"><code>VARIANCE</code></a> - <a href="/docs/reference/query-languages/esql/functions-operators/aggregation-functions#esql-weighted_avg"><code>WEIGHTED_AVG</code></a></p>\n<p>When <code>STATS</code> is used under the <a href="https://www.elastic.co/docs/reference/query-languages/esql/commands/ts"><code>TS</code></a> source command, <a href="https://www.elastic.co/docs/reference/query-languages/esql/functions-operators/time-series-aggregation-functions">time series aggregation functions</a> are also supported. The following <a href="https://www.elastic.co/docs/reference/query-languages/esql/functions-operators/grouping-functions">grouping functions</a> are supported: - <a href="/docs/reference/query-languages/esql/functions-operators/grouping-functions#esql-bucket"><code>BUCKET</code></a> - <a href="/docs/reference/query-languages/esql/functions-operators/grouping-functions#esql-tbucket"><code>TBUCKET</code></a> - <a href="/docs/reference/query-languages/esql/functions-operators/grouping-functions#esql-categorize"><code>CATEGORIZE</code></a></p>\n<note>\n<code>STATS</code> without any groups is much much faster than adding a group.\n</note>\n<note>\nGrouping on a single expression is currently much more optimized than grouping on many expressions. In some tests we have seen grouping on a single <code>keyword</code> column to be five times faster than grouping on two <code>keyword</code> columns. Do not try to work around this by combining the two columns together with something like <a href="/docs/reference/query-languages/esql/functions-operators/string-functions#esql-concat"><code>CONCAT</code></a> and then grouping - that is not going to be faster.\n</note>\n<h3 id="examples">Examples</h3>\n<p>Calculating a statistic and grouping by the values of another column:</p>\n<pre class="esql"><code>FROM employees\n| STATS count = COUNT(emp_no) BY languages\n| SORT languages</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>count:long</th>\n<th>languages:integer</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>15</td>\n<td>1</td>\n</tr>\n<tr class="even">\n<td>19</td>\n<td>2</td>\n</tr>\n<tr class="odd">\n<td>17</td>\n<td>3</td>\n</tr>\n<tr class="even">\n<td>18</td>\n<td>4</td>\n</tr>\n<tr class="odd">\n<td>21</td>\n<td>5</td>\n</tr>\n<tr class="even">\n<td>10</td>\n<td>null</td>\n</tr>\n</tbody>\n</table>\n<p>Omitting <code>BY</code> returns one row with the aggregations applied over the entire dataset:</p>\n<pre class="esql"><code>FROM employees\n| STATS avg_lang = AVG(languages)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>avg_lang:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>3.1222222222222222</td>\n</tr>\n</tbody>\n</table>\n<p>It’s possible to calculate multiple values:</p>\n<pre class="esql"><code>FROM employees\n| STATS avg_lang = AVG(languages), max_lang = MAX(languages)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>avg_lang:double</th>\n<th>max_lang:integer</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>3.1222222222222222</td>\n<td>5</td>\n</tr>\n</tbody>\n</table>\n<p>To filter the rows that go into an aggregation, use the <code>WHERE</code> clause:</p>\n<pre class="esql"><code>FROM employees\n| STATS avg50s = AVG(salary)::LONG WHERE birth_date &lt; &quot;1960-01-01&quot;,\n        avg60s = AVG(salary)::LONG WHERE birth_date &gt;= &quot;1960-01-01&quot;\n        BY gender\n| SORT gender</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>avg50s:long</th>\n<th>avg60s:long</th>\n<th>gender:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>55462</td>\n<td>46637</td>\n<td>F</td>\n</tr>\n<tr class="even">\n<td>48279</td>\n<td>44879</td>\n<td>M</td>\n</tr>\n</tbody>\n</table>\n<p>The aggregations can be mixed, with and without a filter and grouping is optional as well:</p>\n<pre class="esql"><code>FROM employees\n| EVAL Ks = salary / 1000\n| STATS under_40K = COUNT(*) WHERE Ks &lt; 40,\n        inbetween = COUNT(*) WHERE 40 &lt;= Ks AND Ks &lt; 60,\n        over_60K  = COUNT(*) WHERE 60 &lt;= Ks,\n        total     = COUNT(*)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>under_40K:long</th>\n<th>inbetween:long</th>\n<th>over_60K:long</th>\n<th>total:long</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>36</td>\n<td>39</td>\n<td>25</td>\n<td>100</td>\n</tr>\n</tbody>\n</table>\n<p>It’s also possible to group by multiple values:</p>\n<pre class="esql"><code>FROM employees\n| EVAL hired = DATE_FORMAT(&quot;yyyy&quot;, hire_date)\n| STATS avg_salary = AVG(salary) BY hired, languages.long\n| EVAL avg_salary = ROUND(avg_salary)\n| SORT hired, languages.long</code></pre>\n<h4 id="multivalued-inputs">Multivalued inputs</h4>\n<p>If the grouping key is multivalued then the input row is in all groups:</p>\n<pre class="esql"><code>ROW price = 10, color = [&quot;blue&quot;, &quot;pink&quot;, &quot;yellow&quot;]\n| STATS SUM(price) BY color</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>SUM(price):long</th>\n<th>color:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>10</td>\n<td>blue</td>\n</tr>\n<tr class="even">\n<td>10</td>\n<td>pink</td>\n</tr>\n<tr class="odd">\n<td>10</td>\n<td>yellow</td>\n</tr>\n</tbody>\n</table>\n<p>If all the grouping keys are multivalued then the input row is in all groups:</p>\n<pre class="esql"><code>ROW price = 10, color = [&quot;blue&quot;, &quot;pink&quot;, &quot;yellow&quot;], size = [&quot;s&quot;, &quot;m&quot;, &quot;l&quot;]\n| STATS SUM(price) BY color, size</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>SUM(price):long</th>\n<th>color:keyword</th>\n<th>size:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>10</td>\n<td>blue</td>\n<td>l</td>\n</tr>\n<tr class="even">\n<td>10</td>\n<td>blue</td>\n<td>m</td>\n</tr>\n<tr class="odd">\n<td>10</td>\n<td>blue</td>\n<td>s</td>\n</tr>\n<tr class="even">\n<td>10</td>\n<td>pink</td>\n<td>l</td>\n</tr>\n<tr class="odd">\n<td>10</td>\n<td>pink</td>\n<td>m</td>\n</tr>\n<tr class="even">\n<td>10</td>\n<td>pink</td>\n<td>s</td>\n</tr>\n<tr class="odd">\n<td>10</td>\n<td>yellow</td>\n<td>l</td>\n</tr>\n<tr class="even">\n<td>10</td>\n<td>yellow</td>\n<td>m</td>\n</tr>\n<tr class="odd">\n<td>10</td>\n<td>yellow</td>\n<td>s</td>\n</tr>\n</tbody>\n</table>\n<p>The input <strong>ROW</strong> is in all groups. The entire row. All the values. Even group keys. That means that:</p>\n<pre class="esql"><code>ROW color = [&quot;blue&quot;, &quot;pink&quot;, &quot;yellow&quot;]\n| STATS VALUES(color) BY color</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>VALUES(color):keyword</th>\n<th>color:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>[blue, pink, yellow]</td>\n<td>blue</td>\n</tr>\n<tr class="even">\n<td>[blue, pink, yellow]</td>\n<td>pink</td>\n</tr>\n<tr class="odd">\n<td>[blue, pink, yellow]</td>\n<td>yellow</td>\n</tr>\n</tbody>\n</table>\n<p>The <code>VALUES</code> function above sees the whole row - all of the values of the group key. If you want to send the group key to the function then <code>MV_EXPAND</code> first:</p>\n<pre class="esql"><code>ROW color = [&quot;blue&quot;, &quot;pink&quot;, &quot;yellow&quot;]\n| MV_EXPAND color\n| STATS VALUES(color) BY color</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>VALUES(color):keyword</th>\n<th>color:keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>blue</td>\n<td>blue</td>\n</tr>\n<tr class="even">\n<td>pink</td>\n<td>pink</td>\n</tr>\n<tr class="odd">\n<td>yellow</td>\n<td>yellow</td>\n</tr>\n</tbody>\n</table>\n<p>Refer to <a href="https://github.com/elastic/elasticsearch/issues/134792#issuecomment-3361168090">elasticsearch/issues/134792</a> for an even more in depth explanation.</p>\n<h4 id="multivalue-functions">Multivalue functions</h4>\n<p>Both the aggregating functions and the grouping expressions accept other functions. This is useful for using <code>STATS</code> on multivalue columns. For example, to calculate the average salary change, you can use <code>MV_AVG</code> to first average the multiple values per employee, and use the result with the <code>AVG</code> function:</p>\n<pre class="esql"><code>FROM employees\n| STATS avg_salary_change = ROUND(AVG(MV_AVG(salary_change)), 10)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>avg_salary_change:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>1.3904535865</td>\n</tr>\n</tbody>\n</table>\n<p>An example of grouping by an expression is grouping employees on the first letter of their last name:</p>\n<pre class="esql"><code>FROM employees\n| STATS my_count = COUNT() BY LEFT(last_name, 1)\n| SORT `LEFT(last_name, 1)`</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>my_count:long</th>\n<th>LEFT(last_name, 1):keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>2</td>\n<td>A</td>\n</tr>\n<tr class="even">\n<td>11</td>\n<td>B</td>\n</tr>\n<tr class="odd">\n<td>5</td>\n<td>C</td>\n</tr>\n<tr class="even">\n<td>5</td>\n<td>D</td>\n</tr>\n<tr class="odd">\n<td>2</td>\n<td>E</td>\n</tr>\n<tr class="even">\n<td>4</td>\n<td>F</td>\n</tr>\n<tr class="odd">\n<td>4</td>\n<td>G</td>\n</tr>\n<tr class="even">\n<td>6</td>\n<td>H</td>\n</tr>\n<tr class="odd">\n<td>2</td>\n<td>J</td>\n</tr>\n<tr class="even">\n<td>3</td>\n<td>K</td>\n</tr>\n<tr class="odd">\n<td>5</td>\n<td>L</td>\n</tr>\n<tr class="even">\n<td>12</td>\n<td>M</td>\n</tr>\n<tr class="odd">\n<td>4</td>\n<td>N</td>\n</tr>\n<tr class="even">\n<td>1</td>\n<td>O</td>\n</tr>\n<tr class="odd">\n<td>7</td>\n<td>P</td>\n</tr>\n<tr class="even">\n<td>5</td>\n<td>R</td>\n</tr>\n<tr class="odd">\n<td>13</td>\n<td>S</td>\n</tr>\n<tr class="even">\n<td>4</td>\n<td>T</td>\n</tr>\n<tr class="odd">\n<td>2</td>\n<td>W</td>\n</tr>\n<tr class="even">\n<td>3</td>\n<td>Z</td>\n</tr>\n</tbody>\n</table>\n<h4 id="naming">Naming</h4>\n<p>Specifying the output column name is optional. If not specified, the new column name is equal to the expression. The following query returns a column named <code>AVG(salary)</code>:</p>\n<pre class="esql"><code>FROM employees\n| STATS AVG(salary)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>AVG(salary):double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>48248.55</td>\n</tr>\n</tbody>\n</table>\n<p>Because this name contains special characters, <a href="/docs/reference/query-languages/esql/esql-syntax#esql-identifiers">it needs to be quoted</a> with backticks (<code>) when using it in subsequent commands:</code>esql FROM employees | STATS AVG(salary) | EVAL avg_salary_rounded = ROUND(<code>AVG(salary)</code>) ```</p>\n<table>\n<thead>\n<tr class="header">\n<th>AVG(salary):double</th>\n<th>avg_salary_rounded:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>48248.55</td>\n<td>48249.0</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("ts", """
<h1 id="ts">TS</h1>\n<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="fu">serverless</span><span class="kw">:</span><span class="at"> preview</span></span>\n<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="fu">stack</span><span class="kw">:</span><span class="at"> preview 9.2.0</span></span></code></pre></div>\n<p><strong>Brief description</strong> The <code>TS</code> source command is similar to the <a href="https://www.elastic.co/docs/reference/query-languages/esql/commands/from"><code>FROM</code></a> source command, with the following key differences: - Targets only <a href="https://www.elastic.co/docs/manage-data/data-store/data-streams/time-series-data-stream-tsds">time series indices</a> - Enables the use of <a href="https://www.elastic.co/docs/reference/query-languages/esql/functions-operators/time-series-aggregation-functions">time series aggregation functions</a> inside the <a href="https://www.elastic.co/docs/reference/query-languages/esql/commands/stats-by">STATS</a> command</p>\n<p><strong>Syntax</strong></p>\n<pre class="esql"><code>TS index_pattern [METADATA fields]</code></pre>\n<p><strong>Parameters</strong> <definitions> <definition term="index_pattern"> A list of indices, data streams or aliases. Supports wildcards and date math. </definition> <definition term="fields"> A comma-separated list of <a href="https://www.elastic.co/docs/reference/query-languages/esql/esql-metadata-fields">metadata fields</a> to retrieve. </definition> </definitions></p>\n<p><strong>Description</strong> The <code>TS</code> source command enables time series semantics and adds support for <a href="https://www.elastic.co/docs/reference/query-languages/esql/functions-operators/time-series-aggregation-functions">time series aggregation functions</a> to the <code>STATS</code> command, such as <a href="/docs/reference/query-languages/esql/functions-operators/time-series-aggregation-functions#esql-avg_over_time"><code>AVG_OVER_TIME()</code></a>, or <a href="/docs/reference/query-languages/esql/functions-operators/time-series-aggregation-functions#esql-rate"><code>RATE</code></a>. These functions are implicitly evaluated per time series, then aggregated by group using a secondary aggregation function. For example:</p>\n<pre class="esql"><code>TS metrics\n  | WHERE @timestamp &gt;= now() - 1 hour\n  | STATS SUM(RATE(search_requests)) BY TBUCKET(1 hour), host</code></pre>\nThis query calculates the total rate of search requests (tracked by the <code>search_requests</code> counter) per host and hour. The <code>RATE()</code> function is applied per time series in hourly buckets. These rates are summed for each host and hourly bucket (since each host can map to multiple time series). This paradigm—a pair of aggregation functions—is standard for time series querying. For supported inner (time series) functions per <a href="https://www.elastic.co/docs/manage-data/data-store/data-streams/time-series-data-stream-tsds#time-series-metric">metric type</a>, refer to <a href="https://www.elastic.co/docs/reference/query-languages/esql/functions-operators/time-series-aggregation-functions">ES|QL time series aggregation functions</a>. These functions also apply to downsampled data, with the same semantics as for raw data.\n<note>\n<p>If a query is missing an inner (time series) aggregation function, <a href="/docs/reference/query-languages/esql/functions-operators/time-series-aggregation-functions#esql-last_over_time"><code>LAST_OVER_TIME()</code></a> is assumed and used implicitly. For instance, the following two queries are equivalent, returning the average of the last memory usage values per time series: ```esql TS metrics | STATS AVG(memory_usage)</p>\nTS metrics | STATS AVG(LAST_OVER_TIME(memory_usage)) <code>To calculate the average memory usage across per-time-series averages, use   the following query:</code>esql TS metrics | STATS AVG(AVG_OVER_TIME(memory_usage)) ```\n</note>\n<p>Use regular (non-time-series) <a href="https://www.elastic.co/docs/reference/query-languages/esql/functions-operators/aggregation-functions">aggregation functions</a>, such as <code>SUM()</code>, as outer aggregation functions. Using a time series aggregation in combination with an inner function causes an error. For example, the following query is invalid:</p>\n<pre class="esql"><code>TS metrics | STATS AVG_OVER_TIME(RATE(memory_usage))</code></pre>\n<note>\nA <a href="https://www.elastic.co/docs/reference/query-languages/esql/functions-operators/time-series-aggregation-functions">time series</a> aggregation function must be wrapped inside a <a href="https://www.elastic.co/docs/reference/query-languages/esql/functions-operators/aggregation-functions">regular</a> aggregation function. For instance, the following query is invalid: <code>esql   TS metrics | STATS RATE(search_requests)</code>\n</note>\n<p><strong>Best practices</strong> - Avoid aggregating multiple metrics in the same query when those metrics have different dimensional cardinalities. For example, in <code>STATS max(rate(foo)) + rate(bar))</code>, if <code>foo</code> and <code>bar</code> don’t share the same dimension values, the rate for one metric will be null for some dimension combinations. Because the + operator returns null when either input is null, the entire result becomes null for those dimensions. Additionally, queries that aggregate a single metric can filter out null values more efficiently. - Use the <code>TS</code> command for aggregations on time series data, rather than <code>FROM</code>. The <code>FROM</code> command is still available (for example, for listing document contents), but it’s not optimized for procesing time series data and may produce unexpected results. - The <code>TS</code> command can’t be combined with certain operations (such as <a href="https://www.elastic.co/docs/reference/query-languages/esql/commands/fork"><code>FORK</code></a>) before the <code>STATS</code> command is applied. Once <code>STATS</code> is applied, you can process the tabular output with any applicable ES|QL operations. - Add a time range filter on <code>@timestamp</code> to limit the data volume scanned and improve query performance.</p>\n<p><strong>Examples</strong></p>\n<pre class="esql"><code>TS metrics\n| WHERE @timestamp &gt;= now() - 1 day\n| STATS SUM(AVG_OVER_TIME(memory_usage)) BY host, TBUCKET(1 hour)</code></pre>
"""),                     Map.entry("count_distinct", """
<h2 id="count_distinct"><code>COUNT_DISTINCT</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/count_distinct.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> Column or literal for which to count the number of distinct values. </definition> <definition term="precision"> Precision threshold. Refer to <a href="#esql-agg-count-distinct-approximate"><code>AGG-COUNT-DISTINCT-APPROXIMATE</code></a>. The maximum supported value is 40000. Thresholds above this number will have the same effect as a threshold of 40000. The default value is 3000. </definition> </definitions></p>\n<strong>Description</strong> Returns the approximate number of distinct values.\n<note>\n<a href="#esql-agg-count-distinct-approximate">Counts are approximate</a>.\n</note>\n<p><strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>precision</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>boolean</td>\n<td>integer</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>boolean</td>\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>boolean</td>\n<td>unsigned_long</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>boolean</td>\n<td></td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>date</td>\n<td>integer</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>date</td>\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>date</td>\n<td>unsigned_long</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>date</td>\n<td></td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>date_nanos</td>\n<td>integer</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>date_nanos</td>\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>date_nanos</td>\n<td>unsigned_long</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>date_nanos</td>\n<td></td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>double</td>\n<td>integer</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>double</td>\n<td>unsigned_long</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td></td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>integer</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>unsigned_long</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td></td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>ip</td>\n<td>integer</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>ip</td>\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>ip</td>\n<td>unsigned_long</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>ip</td>\n<td></td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>keyword</td>\n<td>integer</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>keyword</td>\n<td>unsigned_long</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td></td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>integer</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>unsigned_long</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td></td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>integer</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>unsigned_long</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td></td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>version</td>\n<td>integer</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>version</td>\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>version</td>\n<td>unsigned_long</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>version</td>\n<td></td>\n<td>long</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Examples</strong></p>\n<pre class="esql"><code>FROM hosts\n| STATS COUNT_DISTINCT(ip0), COUNT_DISTINCT(ip1)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>COUNT_DISTINCT(ip0):long</th>\n<th>COUNT_DISTINCT(ip1):long</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>7</td>\n<td>8</td>\n</tr>\n</tbody>\n</table>\n<p>With the optional second parameter to configure the precision threshold</p>\n<pre class="esql"><code>FROM hosts\n| STATS COUNT_DISTINCT(ip0, 80000), COUNT_DISTINCT(ip1, 5)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>COUNT_DISTINCT(ip0, 80000):long</th>\n<th>COUNT_DISTINCT(ip1, 5):long</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>7</td>\n<td>9</td>\n</tr>\n</tbody>\n</table>\n<p>The expression can use inline functions. This example splits a string into multiple values using the <code>SPLIT</code> function and counts the unique values</p>\n<pre class="esql"><code>ROW words=&quot;foo;bar;baz;qux;quux;foo&quot;\n| STATS distinct_word_count = COUNT_DISTINCT(SPLIT(words, &quot;;&quot;))</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>distinct_word_count:long</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>5</td>\n</tr>\n</tbody>\n</table>\n<h3 id="counts-are-approximate">Counts are approximate</h3>\n<p>Computing exact counts requires loading values into a set and returning its size. This doesn’t scale when working on high-cardinality sets and/or large values as the required memory usage and the need to communicate those per-shard sets between nodes would utilize too many resources of the cluster. This <code>COUNT_DISTINCT</code> function is based on the <a href="https://static.googleusercontent.com/media/research.google.com/fr//pubs/archive/40671.pdf">HyperLogLog++</a> algorithm, which counts based on the hashes of the values with some interesting properties: - configurable precision, which decides on how to trade memory for accuracy, - excellent accuracy on low-cardinality sets, - fixed memory usage: no matter if there are tens or billions of unique values, memory usage only depends on the configured precision.</p>\n<p>For a precision threshold of <code>c</code>, the implementation that we are using requires about <code>c * 8</code> bytes. The following chart shows how the error varies before and after the threshold: <img src="https://www.elastic.co/docs/reference/query-languages/images/cardinality_error.png" alt="cardinality error" /> For all 3 thresholds, counts have been accurate up to the configured threshold. Although not guaranteed, this is likely to be the case. Accuracy in practice depends on the dataset in question. In general, most datasets show consistently good accuracy. Also note that even with a threshold as low as 100, the error remains very low (1-6% as seen in the above graph) even when counting millions of items. The HyperLogLog++ algorithm depends on the leading zeros of hashed values, the exact distributions of hashes in a dataset can affect the accuracy of the cardinality. The <code>COUNT_DISTINCT</code> function takes an optional second parameter to configure the precision threshold. The <code>precision_threshold</code> options allows to trade memory for accuracy, and defines a unique count below which counts are expected to be close to accurate. Above this value, counts might become a bit more fuzzy. The maximum supported value is <code>40000</code>, thresholds above this number will have the same effect as a threshold of <code>40000</code>. The default value is <code>3000</code>.</p>
"""),                     Map.entry("date_parse", """
<h2 id="date_parse"><code>DATE_PARSE</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/date_parse.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="datePattern"> The date format. Refer to the <a href="https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/time/format/DateTimeFormatter.html"><code>DateTimeFormatter</code> documentation</a> for the syntax. If <code>null</code>, the function returns <code>null</code>. </definition> <definition term="dateString"> Date expression as a string. If <code>null</code> or an empty string, the function returns <code>null</code>. </definition> <definition term="options"> (Optional) Additional options for date parsing, specifying time zone and locale as <a href="/docs/reference/query-languages/esql/esql-syntax#esql-function-named-params">function named parameters</a>. </definition> </definitions></p>\n<p><strong>Description</strong> Returns a date by parsing the second argument using the format specified in the first argument. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>datePattern</th>\n<th>dateString</th>\n<th>options</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>keyword</td>\n<td>keyword</td>\n<td>named parameters</td>\n<td>date</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>keyword</td>\n<td></td>\n<td>date</td>\n</tr>\n<tr class="odd">\n<td>keyword</td>\n<td>text</td>\n<td></td>\n<td>date</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>keyword</td>\n<td></td>\n<td>date</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>text</td>\n<td></td>\n<td>date</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Supported function named parameters</strong> <definitions> <definition term="time_zone"> (keyword) Coordinated Universal Time (UTC) offset or IANA time zone used to convert date values in the query string to UTC. </definition> <definition term="locale"> (keyword) The locale to use when parsing the date, relevant when parsing month names or week days. </definition> </definitions></p>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW date_string = &quot;2022-05-06&quot;\n| EVAL date = DATE_PARSE(&quot;yyyy-MM-dd&quot;, date_string)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>date_string:keyword</th>\n<th>date:date</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>2022-05-06</td>\n<td>2022-05-06T00:00:00.000Z</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("mv_append", """
<h2 id="mv_append"><code>MV_APPEND</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/mv_append.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field1"> </definition> <definition term="field2"> </definition> </definitions></p>\n<p><strong>Description</strong> Concatenates values of two multi-value fields. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field1</th>\n<th>field2</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>boolean</td>\n<td>boolean</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>cartesian_point</td>\n<td>cartesian_point</td>\n<td>cartesian_point</td>\n</tr>\n<tr class="odd">\n<td>cartesian_shape</td>\n<td>cartesian_shape</td>\n<td>cartesian_shape</td>\n</tr>\n<tr class="even">\n<td>date</td>\n<td>date</td>\n<td>date</td>\n</tr>\n<tr class="odd">\n<td>date_nanos</td>\n<td>date_nanos</td>\n<td>date_nanos</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>geo_point</td>\n<td>geo_point</td>\n<td>geo_point</td>\n</tr>\n<tr class="even">\n<td>geo_shape</td>\n<td>geo_shape</td>\n<td>geo_shape</td>\n</tr>\n<tr class="odd">\n<td>geohash</td>\n<td>geohash</td>\n<td>geohash</td>\n</tr>\n<tr class="even">\n<td>geohex</td>\n<td>geohex</td>\n<td>geohex</td>\n</tr>\n<tr class="odd">\n<td>geotile</td>\n<td>geotile</td>\n<td>geotile</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>integer</td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>ip</td>\n<td>ip</td>\n<td>ip</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>keyword</td>\n<td>text</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>text</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>unsigned_long</td>\n<td>unsigned_long</td>\n<td>unsigned_long</td>\n</tr>\n<tr class="even">\n<td>version</td>\n<td>version</td>\n<td>version</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>FROM employees\n| WHERE emp_no == 10039 OR emp_no == 10040\n| SORT emp_no\n| EVAL dates = MV_APPEND(birth_date, hire_date)\n| KEEP emp_no, birth_date, hire_date, dates</code></pre>\n<table>\n<colgroup>\n<col style="width: 15%" />\n<col style="width: 20%" />\n<col style="width: 20%" />\n<col style="width: 43%" />\n</colgroup>\n<thead>\n<tr class="header">\n<th>emp_no:integer</th>\n<th>birth_date:date</th>\n<th>hire_date:date</th>\n<th>dates:date</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>10039</td>\n<td>1959-10-01T00:00:00Z</td>\n<td>1988-01-19T00:00:00Z</td>\n<td>[1959-10-01T00:00:00Z, 1988-01-19T00:00:00Z]</td>\n</tr>\n<tr class="even">\n<td>10040</td>\n<td>null</td>\n<td>1993-02-14T00:00:00Z</td>\n<td>null</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("cos", """
<h2 id="cos"><code>COS</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/cos.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="angle"> An angle, in radians. If <code>null</code>, the function returns <code>null</code>. </definition> </definitions></p>\n<p><strong>Description</strong> Returns the <a href="https://en.wikipedia.org/wiki/Sine_and_cosine">cosine</a> of an angle. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>angle</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW a=1.8\n| EVAL cos=COS(a)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:double</th>\n<th>cos:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>1.8</td>\n<td>-0.2272020946930871</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("eval", """
<h1 id="eval">EVAL</h1>\n<div class="sourceCode" id="cb1"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="fu">serverless</span><span class="kw">:</span><span class="at"> ga</span></span>\n<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="fu">stack</span><span class="kw">:</span><span class="at"> ga</span></span></code></pre></div>\n<p>The <code>EVAL</code> processing command enables you to append new columns with calculated values. <strong>Syntax</strong></p>\n<pre class="esql"><code>EVAL [column1 =] value1[, ..., [columnN =] valueN]</code></pre>\n<p><strong>Parameters</strong> <definitions> <definition term="columnX"> The column name. If a column with the same name already exists, the existing column is dropped. If a column name is used more than once, only the rightmost duplicate creates a column. </definition> <definition term="valueX"> The value for the column. Can be a literal, an expression, or a <a href="/docs/reference/query-languages/esql/esql-functions-operators#esql-functions">function</a>. Can use columns defined left of this one. </definition> </definitions></p>\n<p><strong>Description</strong> The <code>EVAL</code> processing command enables you to append new columns with calculated values. <code>EVAL</code> supports various functions for calculating values. Refer to <a href="/docs/reference/query-languages/esql/esql-functions-operators#esql-functions">Functions</a> for more information. <strong>Examples</strong></p>\n<pre class="esql"><code>FROM employees\n| SORT emp_no\n| KEEP first_name, last_name, height\n| EVAL height_feet = height * 3.281, height_cm = height * 100</code></pre>\n<table>\n<colgroup>\n<col style="width: 21%" />\n<col style="width: 20%" />\n<col style="width: 15%" />\n<col style="width: 21%" />\n<col style="width: 21%" />\n</colgroup>\n<thead>\n<tr class="header">\n<th>first_name:keyword</th>\n<th>last_name:keyword</th>\n<th>height:double</th>\n<th>height_feet:double</th>\n<th>height_cm:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>Georgi</td>\n<td>Facello</td>\n<td>2.03</td>\n<td>6.66043</td>\n<td>202.99999999999997</td>\n</tr>\n<tr class="even">\n<td>Bezalel</td>\n<td>Simmel</td>\n<td>2.08</td>\n<td>6.82448</td>\n<td>208.0</td>\n</tr>\n<tr class="odd">\n<td>Parto</td>\n<td>Bamford</td>\n<td>1.83</td>\n<td>6.004230000000001</td>\n<td>183.0</td>\n</tr>\n</tbody>\n</table>\n<p>If the specified column already exists, the existing column will be dropped, and the new column will be appended to the table:</p>\n<pre class="esql"><code>FROM employees\n| SORT emp_no\n| KEEP first_name, last_name, height\n| EVAL height = height * 3.281</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>first_name:keyword</th>\n<th>last_name:keyword</th>\n<th>height:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>Georgi</td>\n<td>Facello</td>\n<td>6.66043</td>\n</tr>\n<tr class="even">\n<td>Bezalel</td>\n<td>Simmel</td>\n<td>6.82448</td>\n</tr>\n<tr class="odd">\n<td>Parto</td>\n<td>Bamford</td>\n<td>6.004230000000001</td>\n</tr>\n</tbody>\n</table>\n<p>Specifying the output column name is optional. If not specified, the new column name is equal to the expression. The following query adds a column named <code>height*3.281</code>:</p>\n<pre class="esql"><code>FROM employees\n| SORT emp_no\n| KEEP first_name, last_name, height\n| EVAL height * 3.281</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>first_name:keyword</th>\n<th>last_name:keyword</th>\n<th>height:double</th>\n<th>height * 3.281:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>Georgi</td>\n<td>Facello</td>\n<td>2.03</td>\n<td>6.66043</td>\n</tr>\n<tr class="even">\n<td>Bezalel</td>\n<td>Simmel</td>\n<td>2.08</td>\n<td>6.82448</td>\n</tr>\n<tr class="odd">\n<td>Parto</td>\n<td>Bamford</td>\n<td>1.83</td>\n<td>6.004230000000001</td>\n</tr>\n</tbody>\n</table>\n<p>Because this name contains special characters, <a href="/docs/reference/query-languages/esql/esql-syntax#esql-identifiers">it needs to be quoted</a> with backticks (<code>) when using it in subsequent commands:</code>esql FROM employees | EVAL height * 3.281 | STATS avg_height_feet = AVG(<code>height * 3.281</code>) ```</p>\n<table>\n<thead>\n<tr class="header">\n<th>avg_height_feet:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>5.801464200000001</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("round", """
<h2 id="round"><code>ROUND</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/round.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="number"> The numeric value to round. If <code>null</code>, the function returns <code>null</code>. </definition> <definition term="decimals"> The number of decimal places to round to. Defaults to 0. If <code>null</code>, the function returns <code>null</code>. </definition> </definitions></p>\n<p><strong>Description</strong> Rounds a number to the specified number of decimal places. Defaults to 0, which returns the nearest integer. If the precision is a negative number, rounds to the number of digits left of the decimal point. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>number</th>\n<th>decimals</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>double</td>\n<td></td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>integer</td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>long</td>\n<td>integer</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td></td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>integer</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td></td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>integer</td>\n<td>unsigned_long</td>\n</tr>\n<tr class="odd">\n<td>unsigned_long</td>\n<td>long</td>\n<td>unsigned_long</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td></td>\n<td>unsigned_long</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>FROM employees\n| KEEP first_name, last_name, height\n| EVAL height_ft = ROUND(height * 3.281, 1)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>first_name:keyword</th>\n<th>last_name:keyword</th>\n<th>height:double</th>\n<th>height_ft:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>Arumugam</td>\n<td>Ossenbruggen</td>\n<td>2.1</td>\n<td>6.9</td>\n</tr>\n<tr class="even">\n<td>Kwee</td>\n<td>Schusler</td>\n<td>2.1</td>\n<td>6.9</td>\n</tr>\n<tr class="odd">\n<td>Saniya</td>\n<td>Kalloufi</td>\n<td>2.1</td>\n<td>6.9</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("to_dateperiod", """
<h2 id="to_dateperiod"><code>TO_DATEPERIOD</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/to_dateperiod.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> Input value. The input is a valid constant date period expression. </definition> </definitions></p>\n<p><strong>Description</strong> Converts an input value into a <code>date_period</code> value. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>date_period</td>\n<td>date_period</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>date_period</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>date_period</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW x = &quot;2024-01-01&quot;::datetime\n| EVAL y = x + &quot;3 DAYS&quot;::date_period, z = x - TO_DATEPERIOD(&quot;3 days&quot;);</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>x:datetime</th>\n<th>y:datetime</th>\n<th>z:datetime</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>2024-01-01</td>\n<td>2024-01-04</td>\n<td>2023-12-29</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("st_extent_agg", """
<h2 id="st_extent_agg"><code>ST_EXTENT_AGG</code></h2>\n<pre><code>stack: preview\nserverless: preview</code></pre>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/st_extent_agg.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> </definition> </definitions></p>\n<p><strong>Description</strong> Calculate the spatial extent over a field with geometry type. Returns a bounding box for all values of the field. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>cartesian_point</td>\n<td>cartesian_shape</td>\n</tr>\n<tr class="even">\n<td>cartesian_shape</td>\n<td>cartesian_shape</td>\n</tr>\n<tr class="odd">\n<td>geo_point</td>\n<td>geo_shape</td>\n</tr>\n<tr class="even">\n<td>geo_shape</td>\n<td>geo_shape</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>FROM airports\n| WHERE country == &quot;India&quot;\n| STATS extent = ST_EXTENT_AGG(location)</code></pre>\n<table>\n<colgroup>\n<col style="width: 100%" />\n</colgroup>\n<thead>\n<tr class="header">\n<th>extent:geo_shape</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>BBOX (70.77995480038226, 91.5882289968431, 33.9830909203738, 8.47650992218405)</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("hypot", """
<h2 id="hypot"><code>HYPOT</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/hypot.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="number1"> Numeric expression. If <code>null</code>, the function returns <code>null</code>. </definition> <definition term="number2"> Numeric expression. If <code>null</code>, the function returns <code>null</code>. </definition> </definitions></p>\n<p><strong>Description</strong> Returns the hypotenuse of two numbers. The input can be any numeric values, the return value is always a double. Hypotenuses of infinities are null. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>number1</th>\n<th>number2</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>double</td>\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>unsigned_long</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>unsigned_long</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td>unsigned_long</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>unsigned_long</td>\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>unsigned_long</td>\n<td>long</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>unsigned_long</td>\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW a = 3.0, b = 4.0\n| EVAL c = HYPOT(a, b)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:double</th>\n<th>b:double</th>\n<th>c:double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>3.0</td>\n<td>4.0</td>\n<td>5.0</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("tbucket", """
<h2 id="tbucket"><code>TBUCKET</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/tbucket.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="buckets"> Desired bucket size. </definition> </definitions></p>\n<p><strong>Description</strong> Creates groups of values - buckets - out of a <span class="citation" data-cites="timestamp">@timestamp</span> attribute. The size of the buckets must be provided directly. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>buckets</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>date_period</td>\n<td>date</td>\n</tr>\n<tr class="even">\n<td>date_period</td>\n<td>date_nanos</td>\n</tr>\n<tr class="odd">\n<td>time_duration</td>\n<td>date</td>\n</tr>\n<tr class="even">\n<td>time_duration</td>\n<td>date_nanos</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Examples</strong> Provide a bucket size as an argument.</p>\n<pre class="esql"><code>FROM sample_data\n| STATS min = MIN(@timestamp), max = MAX(@timestamp) BY bucket = TBUCKET(1 hour)\n| SORT min</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>min:datetime</th>\n<th>max:datetime</th>\n<th>bucket:datetime</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>2023-10-23T12:15:03.360Z</td>\n<td>2023-10-23T12:27:28.948Z</td>\n<td>2023-10-23T12:00:00.000Z</td>\n</tr>\n<tr class="even">\n<td>2023-10-23T13:33:34.937Z</td>\n<td>2023-10-23T13:55:01.543Z</td>\n<td>2023-10-23T13:00:00.000Z</td>\n</tr>\n</tbody>\n</table>\n<note>\nWhen providing the bucket size, it must be a time duration or date period. Also the reference is epoch, which starts at <code>0001-01-01T00:00:00Z</code>.\n</note>\n<p>Provide a string representation of bucket size as an argument.</p>\n<pre class="esql"><code>FROM sample_data\n| STATS min = MIN(@timestamp), max = MAX(@timestamp) BY bucket = TBUCKET(&quot;1 hour&quot;)\n| SORT min</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>min:datetime</th>\n<th>max:datetime</th>\n<th>bucket:datetime</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>2023-10-23T12:15:03.360Z</td>\n<td>2023-10-23T12:27:28.948Z</td>\n<td>2023-10-23T12:00:00.000Z</td>\n</tr>\n<tr class="even">\n<td>2023-10-23T13:33:34.937Z</td>\n<td>2023-10-23T13:55:01.543Z</td>\n<td>2023-10-23T13:00:00.000Z</td>\n</tr>\n</tbody>\n</table>\n<note>\nWhen providing the bucket size, it can be a string representation of time duration or date period. For example, “1 hour”. Also the reference is epoch, which starts at <code>0001-01-01T00:00:00Z</code>.\n</note>\n<note>\nThe <code>CATEGORIZE</code> function requires a <a href="https://www.elastic.co/subscriptions">platinum license</a>.\n</note>
"""),                     Map.entry("mv_sum", """
<h2 id="mv_sum"><code>MV_SUM</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/mv_sum.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="number"> Multivalue expression. </definition> </definitions></p>\n<p><strong>Description</strong> Converts a multivalued field into a single valued field containing the sum of all of the values. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>number</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n<td>double</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>unsigned_long</td>\n<td>unsigned_long</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW a=[3, 5, 6]\n| EVAL sum_a = MV_SUM(a)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:integer</th>\n<th>sum_a:integer</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>[3, 5, 6]</td>\n<td>14</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("e", """
<h2 id="e"><code>E</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/e.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <strong>Description</strong> Returns <a href="https://en.wikipedia.org/wiki/E_(mathematical_constant)">Euler’s number</a>. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>double</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW E()</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>E():double</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>2.718281828459045</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("coalesce", """
<h2 id="coalesce"><code>COALESCE</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/coalesce.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="first"> Expression to evaluate. </definition> <definition term="rest"> Other expression to evaluate. </definition> </definitions></p>\n<p><strong>Description</strong> Returns the first of its arguments that is not null. If all arguments are null, it returns <code>null</code>. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>first</th>\n<th>rest</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>boolean</td>\n<td>boolean</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>boolean</td>\n<td></td>\n<td>boolean</td>\n</tr>\n<tr class="odd">\n<td>cartesian_point</td>\n<td>cartesian_point</td>\n<td>cartesian_point</td>\n</tr>\n<tr class="even">\n<td>cartesian_shape</td>\n<td>cartesian_shape</td>\n<td>cartesian_shape</td>\n</tr>\n<tr class="odd">\n<td>date</td>\n<td>date</td>\n<td>date</td>\n</tr>\n<tr class="even">\n<td>date_nanos</td>\n<td>date_nanos</td>\n<td>date_nanos</td>\n</tr>\n<tr class="odd">\n<td>geo_point</td>\n<td>geo_point</td>\n<td>geo_point</td>\n</tr>\n<tr class="even">\n<td>geo_shape</td>\n<td>geo_shape</td>\n<td>geo_shape</td>\n</tr>\n<tr class="odd">\n<td>geohash</td>\n<td>geohash</td>\n<td>geohash</td>\n</tr>\n<tr class="even">\n<td>geohex</td>\n<td>geohex</td>\n<td>geohex</td>\n</tr>\n<tr class="odd">\n<td>geotile</td>\n<td>geotile</td>\n<td>geotile</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>integer</td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>integer</td>\n<td></td>\n<td>integer</td>\n</tr>\n<tr class="even">\n<td>ip</td>\n<td>ip</td>\n<td>ip</td>\n</tr>\n<tr class="odd">\n<td>keyword</td>\n<td>keyword</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td></td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>long</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>long</td>\n<td></td>\n<td>long</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>text</td>\n<td>keyword</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td></td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>version</td>\n<td>version</td>\n<td>version</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW a=null, b=&quot;b&quot;\n| EVAL COALESCE(a, b)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:null</th>\n<th>b:keyword</th>\n<th>COALESCE(a, b):keyword</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>null</td>\n<td>b</td>\n<td>b</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("to_cartesianpoint", """
<h2 id="to_cartesianpoint"><code>TO_CARTESIANPOINT</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/to_cartesianpoint.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> Input value. The input can be a single- or multi-valued column or an expression. </definition> </definitions></p>\n<p><strong>Description</strong> Converts an input value to a <code>cartesian_point</code> value. A string will only be successfully converted if it respects the <a href="https://en.wikipedia.org/wiki/Well-known_text_representation_of_geometry">WKT Point</a> format. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>cartesian_point</td>\n<td>cartesian_point</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>cartesian_point</td>\n</tr>\n<tr class="odd">\n<td>text</td>\n<td>cartesian_point</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Example</strong></p>\n<pre class="esql"><code>ROW wkt = [&quot;POINT(4297.11 -1475.53)&quot;, &quot;POINT(7580.93 2272.77)&quot;]\n| MV_EXPAND wkt\n| EVAL pt = TO_CARTESIANPOINT(wkt)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>wkt:keyword</th>\n<th>pt:cartesian_point</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>“POINT(4297.11 -1475.53)”</td>\n<td>POINT(4297.11 -1475.53)</td>\n</tr>\n<tr class="even">\n<td>“POINT(7580.93 2272.77)”</td>\n<td>POINT(7580.93 2272.77)</td>\n</tr>\n</tbody>\n</table>
"""),                     Map.entry("mv_slice", """
<h2 id="mv_slice"><code>MV_SLICE</code></h2>\n<p><strong>Syntax</strong> <img src="https://www.elastic.co/docs/reference/query-languages/esql/images/functions/mv_slice.svg" alt="Embedded" /></p>\n<p><strong>Parameters</strong> <definitions> <definition term="field"> Multivalue expression. If <code>null</code>, the function returns <code>null</code>. </definition> <definition term="start"> Start position. If <code>null</code>, the function returns <code>null</code>. The start argument can be negative. An index of -1 is used to specify the last value in the list. </definition> <definition term="end"> End position(included). Optional; if omitted, the position at <code>start</code> is returned. The end argument can be negative. An index of -1 is used to specify the last value in the list. </definition> </definitions></p>\n<p><strong>Description</strong> Returns a subset of the multivalued field using the start and end index values. This is most useful when reading from a function that emits multivalued columns in a known order like <a href="/docs/reference/query-languages/esql/functions-operators/string-functions#esql-split"><code>SPLIT</code></a> or <a href="#esql-mv_sort"><code>MV_SORT</code></a>. The order that <a href="https://www.elastic.co/docs/reference/query-languages/esql/esql-multivalued-fields">multivalued fields</a> are read from underlying storage is not guaranteed. It is <strong>frequently</strong> ascending, but don’t rely on that. <strong>Supported types</strong></p>\n<table>\n<thead>\n<tr class="header">\n<th>field</th>\n<th>start</th>\n<th>end</th>\n<th>result</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>boolean</td>\n<td>integer</td>\n<td>integer</td>\n<td>boolean</td>\n</tr>\n<tr class="even">\n<td>cartesian_point</td>\n<td>integer</td>\n<td>integer</td>\n<td>cartesian_point</td>\n</tr>\n<tr class="odd">\n<td>cartesian_shape</td>\n<td>integer</td>\n<td>integer</td>\n<td>cartesian_shape</td>\n</tr>\n<tr class="even">\n<td>date</td>\n<td>integer</td>\n<td>integer</td>\n<td>date</td>\n</tr>\n<tr class="odd">\n<td>date_nanos</td>\n<td>integer</td>\n<td>integer</td>\n<td>date_nanos</td>\n</tr>\n<tr class="even">\n<td>double</td>\n<td>integer</td>\n<td>integer</td>\n<td>double</td>\n</tr>\n<tr class="odd">\n<td>geo_point</td>\n<td>integer</td>\n<td>integer</td>\n<td>geo_point</td>\n</tr>\n<tr class="even">\n<td>geo_shape</td>\n<td>integer</td>\n<td>integer</td>\n<td>geo_shape</td>\n</tr>\n<tr class="odd">\n<td>geohash</td>\n<td>integer</td>\n<td>integer</td>\n<td>geohash</td>\n</tr>\n<tr class="even">\n<td>geohex</td>\n<td>integer</td>\n<td>integer</td>\n<td>geohex</td>\n</tr>\n<tr class="odd">\n<td>geotile</td>\n<td>integer</td>\n<td>integer</td>\n<td>geotile</td>\n</tr>\n<tr class="even">\n<td>integer</td>\n<td>integer</td>\n<td>integer</td>\n<td>integer</td>\n</tr>\n<tr class="odd">\n<td>ip</td>\n<td>integer</td>\n<td>integer</td>\n<td>ip</td>\n</tr>\n<tr class="even">\n<td>keyword</td>\n<td>integer</td>\n<td>integer</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>long</td>\n<td>integer</td>\n<td>integer</td>\n<td>long</td>\n</tr>\n<tr class="even">\n<td>text</td>\n<td>integer</td>\n<td>integer</td>\n<td>keyword</td>\n</tr>\n<tr class="odd">\n<td>unsigned_long</td>\n<td>integer</td>\n<td>integer</td>\n<td>unsigned_long</td>\n</tr>\n<tr class="even">\n<td>version</td>\n<td>integer</td>\n<td>integer</td>\n<td>version</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Examples</strong></p>\n<pre class="esql"><code>row a = [1, 2, 2, 3]\n| eval a1 = mv_slice(a, 1), a2 = mv_slice(a, 2, 3)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:integer</th>\n<th>a1:integer</th>\n<th>a2:integer</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>[1, 2, 2, 3]</td>\n<td>2</td>\n<td>[2, 3]</td>\n</tr>\n</tbody>\n</table>\n<pre class="esql"><code>row a = [1, 2, 2, 3]\n| eval a1 = mv_slice(a, -2), a2 = mv_slice(a, -3, -1)</code></pre>\n<table>\n<thead>\n<tr class="header">\n<th>a:integer</th>\n<th>a1:integer</th>\n<th>a2:integer</th>\n</tr>\n</thead>\n<tbody>\n<tr class="odd">\n<td>[1, 2, 2, 3]</td>\n<td>2</td>\n<td>[2, 2, 3]</td>\n</tr>\n</tbody>\n</table>
""")
    );

    public static @Nullable DocumentationResult getDocforCommand(String command) {
        String content = rawDocs.get(command);
        if (content != null) {
            return DocumentationResult.documentation("<p>" + content + "</p>");
        }
        return null;
    }
}
